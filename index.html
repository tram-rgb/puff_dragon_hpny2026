<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Puff Dragon AR Viewer</title>

    <style>
      @font-face {
        font-family: "BeautifulFreak";
        src: url("BeautifulFreak.otf") format("opentype");
        font-display: swap;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        height: 100%;
        touch-action: none;
      }

      .hidden {
        display: none !important;
      }

      /* =========================
         INTRO OVERLAY
      ========================= */
      #introOverlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      #introVideo {
        width: 100vw;
        height: auto;
        max-height: 100vh;
        object-fit: contain;
        background: #fff;
        display: block;
      }

      #introClosePuff {
        position: absolute;
        top: calc(14px + env(safe-area-inset-top));
        left: 50%;
        transform: translateX(-50%);
        width: min(22vw, 96px);
        height: auto;
        z-index: 3;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      #introClosePuff:active {
        transform: translateX(-50%) scale(0.96);
      }

      #exploreBtn {
        position: absolute;
        left: 50%;
        top: 55%;
        transform: translate(-50%, -50%);
        border: 0;
        border-radius: 16px;
        padding: 18px 34px;
        font-size: clamp(20px, 4.2vw, 30px);
        font-weight: 900;
        letter-spacing: 0.2px;
        color: #fff;
        background: #fa213f;
        cursor: pointer;
        z-index: 2;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      }

      #exploreBtn:active {
        transform: translate(-50%, -50%) scale(0.98);
      }

      /* =========================
         MAIN APP
      ========================= */
      #camera {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: 1;
        transform-origin: center;
      }

      #camera.mirror {
        transform: scaleX(-1);
      }

      #puff {
        position: fixed;
        left: 50%;
        top: 72%;
        width: min(90vw, 500px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1.55);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        z-index: 2;
        user-select: none;
        -webkit-user-drag: none;
      }

      #stickerLayer {
        position: fixed;
        inset: 0;
        z-index: 3;
        pointer-events: none;
      }

      .sticker {
        position: fixed;
        left: 50%;
        top: 40%;
        width: min(45vw, 260px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        user-select: none;
      }

      .sticker.selected {
        outline: 2px solid rgba(255, 255, 255, 0.6);
        outline-offset: 6px;
        border-radius: 14px;
      }

      /* =========================
         UI
      ========================= */
      #ui {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 7px;
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.65),
          rgba(0, 0, 0, 0)
        );
        z-index: 10;
      }

      .ui-row {
        display: flex;
        gap: 7px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      button {
        border: 0;
        border-radius: 9px;
        padding: 6px 10px;
        font-size: 12px;
        font-weight: 800;
        letter-spacing: 0.2px;
        color: #fff;
        background: #e11d2e;
        min-width: 92px;
      }

      #start {
        background: #fa213f;
      }

      button.secondary {
        background: rgba(255, 255, 255, 0.15);
      }

      button:disabled {
        opacity: 0.5;
      }

      #capture {
        background: #fff100;
        color: #060d3d;
        font-weight: 900;
        min-width: 110px;
      }

      #photoboothToggle.on {
        background: #01b7ff;
        color: #00131c;
        font-weight: 900;
      }

      /* Panels */
      #stickerPanel,
      #filterPanel {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        transform: translateY(110%);
        transition: transform 0.22s ease;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        padding: 12px 12px calc(12px + env(safe-area-inset-bottom));
        z-index: 20;
        border-top-left-radius: 18px;
        border-top-right-radius: 18px;

        max-height: min(78vh, 560px);
        display: flex;
        flex-direction: column;

        -webkit-overflow-scrolling: touch;
      }

      #stickerPanel.open,
      #filterPanel.open {
        transform: translateY(0);
      }

      #stickerPanelHeader,
      #filterPanelHeader {
        position: sticky;
        top: 0;
        z-index: 2;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);

        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        padding-bottom: 8px;
      }

      .panelBody {
        overflow-y: auto;
        flex: 1;
        padding-right: 2px;
      }

      #stickerGrid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 9px;
      }

      .stickerItem {
        background: rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 9px;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1 / 1;
      }

      .stickerItem img {
        max-width: 100%;
        max-height: 100%;
        display: block;
      }

      #filterList {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 9px;
      }

      .filterItem {
        border: 0;
        border-radius: 14px;
        padding: 10px 10px;
        background: rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.95);
        font: 800 12px system-ui;
        text-align: left;
      }

      .filterItem .sub {
        display: block;
        margin-top: 4px;
        opacity: 0.78;
        font: 700 10px system-ui;
        line-height: 1.1;
      }

      .filterItem.active {
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 2px;
      }

      .panelFooter {
        position: sticky;
        bottom: 0;
        z-index: 2;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        padding-top: 10px;
      }

      /* Desktop hint */
      #desktopHint {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 11;
        padding: 7px 9px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.45);
        color: rgba(255, 255, 255, 0.85);
        font: 700 11px system-ui;
        display: none;
        user-select: none;
      }

      @media (hover: hover) and (pointer: fine) {
        #desktopHint {
          display: block;
        }
      }

      /* =========================
         CAPTURED PANEL (movable, scrollable)
      ========================= */
      #capturedPanel {
        position: fixed;
        right: 14px;
        top: calc(14px + env(safe-area-inset-top));
        width: min(42vw, 240px);
        height: min(48vh, 360px);
        z-index: 50;
        border-radius: 14px;
        background: rgba(10, 10, 10, 0.65);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.12);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      #capturedPanel.hidden {
        display: none !important;
      }

      #capturedHeader {
        padding: 10px 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: rgba(0, 0, 0, 0.35);
        cursor: grab;
        user-select: none;
      }

      #capturedHeader .title {
        color: #fff;
        font: 900 12px system-ui;
        letter-spacing: 0.2px;
      }

      #capturedHeader button {
        min-width: unset;
        padding: 6px 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.14);
        color: rgba(255, 255, 255, 0.9);
      }

      #capturedList {
        flex: 1;
        overflow-y: auto;
        padding: 10px;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        align-content: start;
      }

      .capThumb {
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
        aspect-ratio: 4 / 3;
        cursor: pointer;
        position: relative;
      }

      .capThumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .capThumb.selected {
        outline: 2px solid rgba(255, 241, 0, 0.95);
        outline-offset: 2px;
      }

      #capturedFooter {
        padding: 10px;
        background: rgba(0, 0, 0, 0.35);
        display: flex;
        gap: 8px;
        justify-content: center;
      }

      #cueBtn {
        width: 100%;
        border-radius: 12px;
        background: #fff100;
        color: #060d3d;
        font-weight: 1000;
        min-width: unset;
      }

      #cueBtn:disabled {
        opacity: 0.5;
      }

      /* =========================
         BUILDER OVERLAY
      ========================= */
      #builderOverlay {
        position: fixed;
        inset: 0;
        z-index: 200;
        background: rgba(0, 0, 0, 0.72);
        backdrop-filter: blur(14px);
        padding: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #builderOverlay.hidden {
        display: none !important;
      }

      #builderShell {
        width: min(980px, 100%);
        height: min(720px, 100%);
        display: grid;
        grid-template-columns: 1.25fr 0.75fr;
        gap: 12px;
      }

      /* Mobile: bigger preview, smaller controls + preview scroll */
      @media (max-width: 860px) {
        #builderShell {
          grid-template-columns: 1fr;
          grid-template-rows: 1.2fr 0.8fr; /* preview bigger */
          height: 100%;
        }
      }

      #builderStageWrap {
        border-radius: 16px;
        overflow: auto; /* allow scroll to view full strip */
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.25);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px;
        -webkit-overflow-scrolling: touch;
      }

      #builderStage {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #stripCanvas {
        max-width: 100%;
        height: auto;
        image-rendering: auto;
        background: transparent;
        touch-action: none;
      }

      #builderControls {
        border-radius: 16px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.35);
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      #builderTopbar {
        padding: 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: rgba(0, 0, 0, 0.35);
      }

      #builderTopbar .label {
        color: #fff;
        font: 900 12px system-ui;
        opacity: 0.95;
      }

      #builderTopbar button {
        min-width: unset;
        padding: 6px 10px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.14);
      }

      #builderBody {
        padding: 10px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        min-height: 0;
      }

      .ctrlGroup {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.06);
      }

      .ctrlTitle {
        color: rgba(255, 255, 255, 0.92);
        font: 900 12px system-ui;
        margin-bottom: 8px;
      }

      .pillRow {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .pill {
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(255, 255, 255, 0.08);
        color: rgba(255, 255, 255, 0.92);
        padding: 7px 10px;
        border-radius: 999px;
        font: 900 11px system-ui;
        cursor: pointer;
        user-select: none;
      }

      .pill.active {
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 1px;
      }

      .hint {
        color: rgba(255, 255, 255, 0.75);
        font: 700 11px system-ui;
        line-height: 1.25;
      }

      #exportStripBtn {
        width: 100%;
        border-radius: 12px;
        background: #fff100;
        color: #060d3d;
        font-weight: 1000;
        padding: 10px 12px;
      }

      /* Slot selection hint */
      .slotHint {
        margin-top: 8px;
      }
    </style>
  </head>

  <body>
    <!-- =========================
         INTRO
    ========================= -->
    <div id="introOverlay">
      <video
        id="introVideo"
        autoplay
        playsinline
        webkit-playsinline
        muted
        preload="auto"
      >
        <source id="introMp4" src="" type="video/mp4" />
        <source id="introWebm" src="" type="video/webm" />
      </video>

      <img
        id="introClosePuff"
        src="puff-close.png"
        alt="Close intro"
        role="button"
      />

      <button id="exploreBtn" class="hidden" type="button">Explore</button>
    </div>

    <!-- =========================
         MAIN APP
    ========================= -->
    <div id="app" class="hidden">
      <div id="desktopHint">
        Desktop: drag=move • wheel=zoom • Alt/Shift/right-drag=rotate • click=select
      </div>

      <video id="camera" autoplay playsinline muted></video>

      <video
        id="puff"
        autoplay
        playsinline
        webkit-playsinline
        muted
        loop
        preload="auto"
        crossorigin="anonymous"
      ></video>

      <div id="stickerLayer"></div>

      <!-- Captured floating panel (photobooth ON) -->
      <div id="capturedPanel" class="hidden" aria-hidden="true">
        <div id="capturedHeader">
          <div class="title">Captured</div>
          <button id="clearCapturedBtn" type="button">Clear</button>
        </div>
        <div id="capturedList"></div>
        <div id="capturedFooter">
          <button id="cueBtn" type="button" disabled>Visuals, cue!</button>
        </div>
      </div>

      <div id="ui">
        <div class="ui-row">
          <button id="start">Start AR</button>
          <button id="flip" class="secondary" disabled>Flip Camera</button>
          <button id="mirror" class="secondary" disabled>Mirror: Auto</button>
        </div>

        <div class="ui-row">
          <button id="photoboothToggle" class="secondary" disabled>
            Photobooth: OFF
          </button>
          <button id="stickers" class="secondary" disabled>Sticker</button>
          <button id="filterBtn" class="secondary" disabled>Filter</button>
          <button id="capture" disabled>Puff It!</button>
        </div>
      </div>

      <!-- Sticker panel -->
      <div id="stickerPanel" aria-hidden="true">
        <div id="stickerPanelHeader">
          <div style="color:#fff;font:800 14px system-ui">Choose a sticker</div>
          <button id="stickerClose" class="secondary">Close</button>
        </div>

        <div class="panelBody">
          <div id="stickerGrid"></div>

          <div class="panelFooter">
            <div
              style="
                display: flex;
                gap: 8px;
                justify-content: center;
                flex-wrap: wrap;
              "
            >
              <button id="stickerRemove" class="secondary" disabled>
                Remove selected
              </button>
              <button id="stickerClear" class="secondary" disabled>
                Clear all
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Filter panel -->
      <div id="filterPanel" aria-hidden="true">
        <div id="filterPanelHeader">
          <div style="color:#fff;font:800 14px system-ui">Choose a filter</div>
          <button id="filterClose" class="secondary">Close</button>
        </div>

        <div class="panelBody">
          <div id="filterList"></div>
        </div>
      </div>
    </div>

    <!-- =========================
         BUILDER OVERLAY
    ========================= -->
    <div id="builderOverlay" class="hidden" aria-hidden="true">
      <div id="builderShell">
        <div id="builderStageWrap">
          <div id="builderStage">
            <canvas id="stripCanvas" width="400" height="1200"></canvas>
          </div>
        </div>

        <div id="builderControls">
          <div id="builderTopbar">
            <div class="label">Photoshoot Customize</div>
            <button id="builderCloseBtn" type="button">Close</button>
          </div>

          <div id="builderBody">
            <div class="ctrlGroup">
              <div class="ctrlTitle">Frame color</div>
              <div class="pillRow" id="frameColorRow"></div>
              <div class="hint" style="margin-top:8px">
                Logo auto-applies based on frame color.
              </div>
            </div>

            <div class="ctrlGroup">
              <div class="ctrlTitle">Layout</div>
              <div class="pillRow" id="layoutRow"></div>
              <div class="hint slotHint">
                Step 1: tap a thumbnail in Captured (select)<br/>
                Step 2: tap a panel area on the strip (assign)<br/>
                Step 3: on mobile, pinch/drag on the panel to scale/position.
              </div>
            </div>

            <div class="ctrlGroup">
              <button id="exportStripBtn" type="button">Export strip PNG</button>
              <div class="hint" style="margin-top:8px">
                Export adds random 3–5 stickers around the outer frame only (auto color-matched).
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      /* =========================
         CACHE BUSTING
      ========================= */
      const ASSET_VERSION = "27";
      const vq = (u) => `${u}${u.includes("?") ? "&" : "?"}v=${encodeURIComponent(ASSET_VERSION)}`;

      /* =========================
         MAIN APP ELEMENTS
      ========================= */
      const cameraEl = document.getElementById("camera");
      const puffEl = document.getElementById("puff");
      const stickerLayer = document.getElementById("stickerLayer");

      const startBtn = document.getElementById("start");
      const flipBtn = document.getElementById("flip");
      const mirrorBtn = document.getElementById("mirror");
      const stickersBtn = document.getElementById("stickers");
      const captureBtn = document.getElementById("capture");
      const photoboothToggleBtn = document.getElementById("photoboothToggle");

      const filterBtn = document.getElementById("filterBtn");
      const filterPanel = document.getElementById("filterPanel");
      const filterClose = document.getElementById("filterClose");
      const filterListEl = document.getElementById("filterList");

      const stickerPanel = document.getElementById("stickerPanel");
      const stickerGrid = document.getElementById("stickerGrid");
      const stickerClose = document.getElementById("stickerClose");
      const stickerRemove = document.getElementById("stickerRemove");
      const stickerClear = document.getElementById("stickerClear");

      /* =========================
         INTRO
      ========================= */
      const introOverlay = document.getElementById("introOverlay");
      const introVideo = document.getElementById("introVideo");
      const exploreBtn = document.getElementById("exploreBtn");
      const closePuff = document.getElementById("introClosePuff");
      const app = document.getElementById("app");
      const introMp4 = document.getElementById("introMp4");
      const introWebm = document.getElementById("introWebm");

      introMp4.src = vq("intro.mp4");
      introWebm.src = vq("intro.webm");
      introVideo.load();

      let introLoopStarted = false;
      introVideo.addEventListener("ended", async () => {
        if (introLoopStarted) return;
        introLoopStarted = true;
        exploreBtn.classList.remove("hidden");
        introVideo.loop = true;
        try {
          introVideo.currentTime = 0;
          await introVideo.play();
        } catch (_) {}
      });

      const tryPlayIntro = async () => {
        try { await introVideo.play(); } catch (_) {}
        window.removeEventListener("pointerdown", tryPlayIntro, true);
      };
      window.addEventListener("pointerdown", tryPlayIntro, true);

      async function closeIntro() {
        introOverlay.classList.add("hidden");
        app.classList.remove("hidden");
        try { await puffEl.play(); } catch (_) {}
      }
      closePuff.addEventListener("click", closeIntro);
      exploreBtn.addEventListener("click", closeIntro);

      /* =========================================================
         FILTERS (unchanged)
      ========================================================= */
      const clamp01 = (v) => Math.max(0, Math.min(1, v));
      const clamp255 = (v) => Math.max(0, Math.min(255, v));

      function srgbToLin(c) {
        c /= 255;
        return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      }
      function linToSrgb(c) {
        c = clamp01(c);
        const v = c <= 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
        return clamp255(v * 255);
      }
      function lumaLin(rLin, gLin, bLin) {
        return 0.2126 * rLin + 0.7152 * gLin + 0.0722 * bLin;
      }
      function applySaturationLin(r, g, b, sat) {
        const y = lumaLin(r, g, b);
        return [y + (r - y) * sat, y + (g - y) * sat, y + (b - y) * sat];
      }
      function adjustShadowsHighlightsLin(y, shadows, highlights) {
        let out = y;
        if (shadows !== 0) {
          const t = clamp01((0.45 - y) / 0.45);
          out += shadows * t * 0.35;
        }
        if (highlights !== 0) {
          const t = clamp01((y - 0.55) / 0.45);
          out += highlights * t * 0.35;
        }
        return clamp01(out);
      }
      function applyBrillianceLin(y, brilliance) {
        if (brilliance === 0) return y;
        const k = brilliance * 0.55;
        const s = y * y * (3 - 2 * y);
        return clamp01(y + (s - y) * k);
      }
      function applyFadeLin(y, fade) {
        if (!fade) return y;
        const lift = fade * 0.10;
        return clamp01(y * (1 - fade * 0.15) + lift);
      }
      function applyWarmthLin(r, g, b, warmth) {
        if (!warmth) return [r, g, b];
        const w = warmth * 0.10;
        return [r * (1 + w), g, b * (1 - w)];
      }
      function unsharpMask(imageData, amount = 0.35, radius = 1) {
        const { width: w, height: h, data } = imageData;
        const src = new Uint8ClampedArray(data);
        const idx = (x, y) => (y * w + x) * 4;
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let r = 0, g = 0, b = 0, n = 0;
            for (let dy = -radius; dy <= radius; dy++) {
              const yy = y + dy;
              if (yy < 0 || yy >= h) continue;
              for (let dx = -radius; dx <= radius; dx++) {
                const xx = x + dx;
                if (xx < 0 || xx >= w) continue;
                const p = idx(xx, yy);
                r += src[p]; g += src[p + 1]; b += src[p + 2]; n++;
              }
            }
            const p = idx(x, y);
            const br = r / n, bg = g / n, bb = b / n;
            data[p] = clamp255(src[p] + amount * (src[p] - br));
            data[p + 1] = clamp255(src[p + 1] + amount * (src[p + 1] - bg));
            data[p + 2] = clamp255(src[p + 2] + amount * (src[p + 2] - bb));
          }
        }
        return imageData;
      }
      function noiseReduceLight(imageData, strength = 0.15) {
        if (!strength) return imageData;
        const { width: w, height: h, data } = imageData;
        const src = new Uint8ClampedArray(data);
        const idx = (x, y) => (y * w + x) * 4;
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let r = 0, g = 0, b = 0, n = 0;
            for (let dy = -1; dy <= 1; dy++) {
              const yy = y + dy;
              if (yy < 0 || yy >= h) continue;
              for (let dx = -1; dx <= 1; dx++) {
                const xx = x + dx;
                if (xx < 0 || xx >= w) continue;
                const p = idx(xx, yy);
                r += src[p]; g += src[p + 1]; b += src[p + 2]; n++;
              }
            }
            const p = idx(x, y);
            const br = r / n, bg = g / n, bb = b / n;
            data[p] = clamp255(src[p] * (1 - strength) + br * strength);
            data[p + 1] = clamp255(src[p + 1] * (1 - strength) + bg * strength);
            data[p + 2] = clamp255(src[p + 2] * (1 - strength) + bb * strength);
          }
        }
        return imageData;
      }
      function recipe(params) {
        return {
          exposure: (params.exposure || 0) / 100,
          brilliance: (params.brilliance || 0) / 100,
          highlights: (params.highlights || 0) / 100,
          shadows: (params.shadows || 0) / 100,
          brightness: (params.brightness || 0) / 100,
          contrast: (params.contrast || 0) / 100,
          saturation: (params.saturation || 0) / 100,
          warmth: (params.warmth || 0) / 100,
          fade: (params.fade || 0) / 100,
          sharpness: (params.sharpness || 0) / 100,
          noiseReduce: (params.noiseReduce || 0) / 100,
        };
      }
      const FILTERS = [
        { id: "none", name: "None", recipe: recipe({}) },
        { id: "35mm04", name: "35mm 04", recipe: recipe({ exposure: -5, brilliance: -10, highlights: -30, shadows: +18, brightness: -10, contrast: -8, saturation: -6, warmth: -6, fade: +12, sharpness: -5, noiseReduce: +8 }) },
        { id: "vi4", name: "VI4", recipe: recipe({ exposure: +10, brilliance: +18, highlights: -35, shadows: +14, brightness: +6, contrast: -6, saturation: +10, warmth: +10, fade: +10, sharpness: +6, noiseReduce: +10 }) },
        { id: "cm1", name: "CM1", recipe: recipe({ exposure: +8, brilliance: +22, highlights: -25, shadows: +12, brightness: +4, contrast: -4, saturation: +12, warmth: +6, fade: +6, sharpness: +10, noiseReduce: +8 }) },
        { id: "sapa", name: "Sapa", recipe: recipe({ exposure: +12, brilliance: +10, highlights: -22, shadows: +18, brightness: +8, contrast: -10, saturation: +6, warmth: -10, fade: +16, sharpness: +6, noiseReduce: +10 }) },
        { id: "salt", name: "Salt", recipe: recipe({ exposure: +18, brilliance: +18, highlights: -40, shadows: +10, brightness: +10, contrast: -8, saturation: +14, warmth: +14, fade: +8, sharpness: +8, noiseReduce: +8 }) },
        { id: "in2", name: "IN2", recipe: recipe({ exposure: +10, brilliance: +8, highlights: -30, shadows: +16, brightness: +4, contrast: -12, saturation: -4, warmth: -8, fade: +18, sharpness: +6, noiseReduce: +12 }) },
        { id: "fl2", name: "FL2", recipe: recipe({ exposure: +14, brilliance: +14, highlights: -28, shadows: +10, brightness: +8, contrast: -6, saturation: +10, warmth: +8, fade: +10, sharpness: +8, noiseReduce: +10 }) },
        { id: "bwfilm", name: "B&W Film", recipe: recipe({ exposure: +6, brilliance: +10, highlights: -20, shadows: +10, brightness: +4, contrast: +10, saturation: -100, fade: +8, sharpness: +10, noiseReduce: +10 }) },
      ];
      let currentFilterId = "none";
      let currentRecipe = FILTERS[0].recipe;

      function recipeToPreviewCss(r) {
        const bright = 1 + r.exposure * 0.55 + r.brightness * 0.35;
        const cont = 1 + r.contrast * 0.6 + r.brilliance * 0.25;
        const sat = 1 + r.saturation * 0.75;
        const hue = r.warmth * -18;
        const sep = clamp01(r.warmth * 0.35 + 0.05);
        return `brightness(${bright.toFixed(3)}) contrast(${cont.toFixed(3)}) saturate(${sat.toFixed(3)}) sepia(${sep.toFixed(3)}) hue-rotate(${hue.toFixed(1)}deg)`;
      }
      function applyCameraFilterPreview() {
        cameraEl.style.filter = recipeToPreviewCss(currentRecipe);
      }
      function openFilterPanel() {
        filterPanel.classList.add("open");
        filterPanel.setAttribute("aria-hidden", "false");
      }
      function closeFilterPanel() {
        filterPanel.classList.remove("open");
        filterPanel.setAttribute("aria-hidden", "true");
      }
      function renderFilters() {
        filterListEl.innerHTML = "";
        FILTERS.forEach((f) => {
          const b = document.createElement("button");
          b.className = "filterItem" + (f.id === currentFilterId ? " active" : "");
          b.type = "button";
          const r = f.recipe;
          const recLine = f.id === "none" ? "no recipe" : `exp ${Math.round(r.exposure * 100)} • hi ${Math.round(r.highlights * 100)} • sh ${Math.round(r.shadows * 100)} • sat ${Math.round(r.saturation * 100)}`;
          b.innerHTML = `${f.name}<span class="sub">${recLine}</span>`;
          b.addEventListener("click", () => {
            currentFilterId = f.id;
            currentRecipe = f.recipe;
            applyCameraFilterPreview();
            renderFilters();
            closeFilterPanel();
          });
          filterListEl.appendChild(b);
        });
      }
      renderFilters();
      filterBtn.addEventListener("click", () => { if (!filterBtn.disabled) openFilterPanel(); });
      filterClose.addEventListener("click", closeFilterPanel);

      /* =========================
         PUFF RANDOM (weighted: puff more)
      ========================= */
      const puffBases = ["puff", "puff", "puff", "puff", "puff2", "puff3"]; // puff heavier
      const chosenBase = puffBases[Math.floor(Math.random() * puffBases.length)];

      function isAppleSafari() {
        const ua = navigator.userAgent;
        const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|Edg|OPR|Firefox/.test(ua);
        return isIOS || isSafari;
      }
      function setPuffSource(base) {
        const v = `v=${encodeURIComponent(ASSET_VERSION)}`;
        if (isAppleSafari()) {
          puffEl.innerHTML = `
            <source src="${base}.mov?${v}" type='video/quicktime; codecs="hvc1"'>
            <source src="${base}.mp4?${v}" type='video/mp4; codecs="hvc1"'>
          `;
        } else {
          puffEl.innerHTML = `
            <source src="${base}.webm?${v}" type='video/webm; codecs="vp09.00.10.08"'>
            <source src="${base}.webm?${v}" type="video/webm">
          `;
        }
        puffEl.load();
      }
      puffEl.setAttribute("playsinline", "");
      puffEl.setAttribute("webkit-playsinline", "");
      puffEl.muted = true;
      puffEl.crossOrigin = "anonymous";
      setPuffSource(chosenBase);

      /* =========================
         CAMERA + MIRROR
      ========================= */
      let currentFacingMode = "environment";
      let stream = null;
      let mirrorMode = "auto";

      function shouldMirrorPreview() {
        return mirrorMode === "on" || (mirrorMode === "auto" && currentFacingMode === "user");
      }
      function applyMirrorToPreview() {
        cameraEl.classList.toggle("mirror", shouldMirrorPreview());
        mirrorBtn.textContent = mirrorMode === "auto" ? "Mirror: Auto" : mirrorMode === "on" ? "Mirror: On" : "Mirror: Off";
      }
      function waitLoadedMetadata(videoEl, timeoutMs = 6000) {
        return new Promise((resolve, reject) => {
          if (videoEl.readyState >= 1 && videoEl.videoWidth > 0) return resolve();
          const t = setTimeout(() => { cleanup(); reject(new Error("metadata timeout")); }, timeoutMs);
          const onMeta = () => { cleanup(); resolve(); };
          const cleanup = () => {
            clearTimeout(t);
            videoEl.removeEventListener("loadedmetadata", onMeta);
          };
          videoEl.addEventListener("loadedmetadata", onMeta, { once: true });
        });
      }

      async function startCamera() {
        captureBtn.disabled = true;
        stickersBtn.disabled = true;
        mirrorBtn.disabled = true;
        filterBtn.disabled = true;
        photoboothToggleBtn.disabled = true;

        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }

        stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: currentFacingMode },
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        });

        cameraEl.srcObject = stream;

        await waitLoadedMetadata(cameraEl).catch(() => {});
        await cameraEl.play().catch(() => {});

        await waitLoadedMetadata(puffEl).catch(() => {});
        await puffEl.play().catch(() => {});

        flipBtn.disabled = false;
        captureBtn.disabled = false;
        stickersBtn.disabled = false;
        mirrorBtn.disabled = false;
        filterBtn.disabled = false;
        photoboothToggleBtn.disabled = false;

        applyMirrorToPreview();
        applyCameraFilterPreview();

        startBtn.textContent = "AR Running";
        startBtn.disabled = true;
      }

      startBtn.addEventListener("click", async () => {
        try { await startCamera(); }
        catch (e) {
          console.error(e);
          alert("Could not access camera. Please allow permission and use HTTPS.");
        }
      });

      flipBtn.addEventListener("click", async () => {
        currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
        startBtn.disabled = false;
        startBtn.textContent = "Restart AR";
        try { await startCamera(); } catch (e) { console.error(e); }
      });

      mirrorBtn.addEventListener("click", () => {
        mirrorMode = mirrorMode === "auto" ? "on" : mirrorMode === "on" ? "off" : "auto";
        applyMirrorToPreview();
      });

      /* =========================
         TRANSFORM HELPERS
      ========================= */
      function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
      function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
      function angleDeg(a, b) { return (Math.atan2(b.y - a.y, b.x - a.x) * 180) / Math.PI; }
      function applyTransform(el, state) {
        el.style.left = state.x + "%";
        el.style.top = state.y + "%";
        el.style.transform = `translate(-50%, -50%) scale(${state.scale}) rotate(${state.rotation}deg)`;
      }

      // Touch-first drag/pinch for Puff (reliable on iOS)
      function enableTouchDragPinch(el, state, onUpdate) {
        let mode = null;
        let start = null;

        const getTouch = (t) => ({ x: t.clientX, y: t.clientY });
        const dist2 = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
        const ang2 = (a, b) => (Math.atan2(b.y - a.y, b.x - a.x) * 180) / Math.PI;

        function toPct(dxPx, dyPx) {
          return { dx: (dxPx / innerWidth) * 100, dy: (dyPx / innerHeight) * 100 };
        }

        function onTouchStart(e) {
          e.preventDefault();
          if (e.touches.length === 1) {
            mode = "drag";
            const t = getTouch(e.touches[0]);
            start = { x: t.x, y: t.y, baseX: state.x, baseY: state.y };
          } else if (e.touches.length === 2) {
            mode = "pinch";
            const a = getTouch(e.touches[0]);
            const b = getTouch(e.touches[1]);
            start = { d: dist2(a, b), ang: ang2(a, b), baseScale: state.scale, baseRot: state.rotation };
          }
        }

        function onTouchMove(e) {
          if (!mode || !start) return;
          e.preventDefault();

          if (mode === "drag" && e.touches.length === 1) {
            const t = getTouch(e.touches[0]);
            const { dx, dy } = toPct(t.x - start.x, t.y - start.y);
            state.x = clamp(start.baseX + dx, 0, 100);
            state.y = clamp(start.baseY + dy, 0, 100);
            onUpdate();
          }

          if (mode === "pinch" && e.touches.length === 2) {
            const a = getTouch(e.touches[0]);
            const b = getTouch(e.touches[1]);
            const newD = dist2(a, b);
            const newAng = ang2(a, b);

            const s = newD / Math.max(10, start.d);
            state.scale = clamp(start.baseScale * s, 0.2, 6);
            state.rotation = start.baseRot + (newAng - start.ang);
            onUpdate();
          }
        }

        function onTouchEnd(e) {
          if (e.touches.length === 0) { mode = null; start = null; }
          else if (e.touches.length === 1) {
            mode = "drag";
            const t = getTouch(e.touches[0]);
            start = { x: t.x, y: t.y, baseX: state.x, baseY: state.y };
          }
        }

        // Mouse fallback (desktop)
        let mouseDown = false;
        let mouseStart = null;

        function onMouseDown(e) {
          e.preventDefault();
          mouseDown = true;
          mouseStart = { x: e.clientX, y: e.clientY, baseX: state.x, baseY: state.y };
          window.addEventListener("mousemove", onMouseMove, { passive: false });
          window.addEventListener("mouseup", onMouseUp, { passive: false });
        }
        function onMouseMove(e) {
          if (!mouseDown || !mouseStart) return;
          e.preventDefault();
          const { dx, dy } = toPct(e.clientX - mouseStart.x, e.clientY - mouseStart.y);
          state.x = clamp(mouseStart.baseX + dx, 0, 100);
          state.y = clamp(mouseStart.baseY + dy, 0, 100);
          onUpdate();
        }
        function onMouseUp() {
          mouseDown = false;
          mouseStart = null;
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
        }

        function onWheel(e) {
          e.preventDefault();
          const delta = -Math.sign(e.deltaY) * 0.08;
          state.scale = clamp(state.scale * (1 + delta), 0.2, 6);
          onUpdate();
        }

        el.addEventListener("touchstart", onTouchStart, { passive: false });
        el.addEventListener("touchmove", onTouchMove, { passive: false });
        el.addEventListener("touchend", onTouchEnd, { passive: false });
        el.addEventListener("touchcancel", onTouchEnd, { passive: false });
        el.addEventListener("mousedown", onMouseDown, { passive: false });
        el.addEventListener("wheel", onWheel, { passive: false });
      }

      // Stickers: pointer-based, 2-finger rotate supported naturally via pinch
      function makeTransformable(el, state, onUpdate) {
        const pointers = new Map();
        let gestureStart = null;
        let dragStart = null;

        el.addEventListener("contextmenu", (e) => e.preventDefault());

        el.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          el.setPointerCapture?.(e.pointerId);
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          if (pointers.size === 1) {
            dragStart = {
              x: e.clientX,
              y: e.clientY,
              baseX: state.x,
              baseY: state.y,
              w: innerWidth,
              h: innerHeight,
            };
            gestureStart = null;
          } else if (pointers.size === 2) {
            const pts = Array.from(pointers.values());
            const a = pts[0], b = pts[1];
            gestureStart = {
              distance: dist(a, b),
              angle: angleDeg(a, b),
              scale: state.scale,
              rotation: state.rotation,
            };
            dragStart = null;
          }
        });

        el.addEventListener("pointermove", (e) => {
          if (!pointers.has(e.pointerId)) return;
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          if (pointers.size === 1 && dragStart) {
            const dx = ((e.clientX - dragStart.x) / dragStart.w) * 100;
            const dy = ((e.clientY - dragStart.y) / dragStart.h) * 100;
            state.x = clamp(dragStart.baseX + dx, 0, 100);
            state.y = clamp(dragStart.baseY + dy, 0, 100);
            onUpdate();
          }

          if (pointers.size === 2 && gestureStart) {
            const pts = Array.from(pointers.values());
            const a = pts[0], b = pts[1];
            const newDistance = dist(a, b);
            const newAngle = angleDeg(a, b);

            state.scale = clamp(gestureStart.scale * (newDistance / gestureStart.distance), 0.2, 6);
            state.rotation = gestureStart.rotation + (newAngle - gestureStart.angle);
            onUpdate();
          }
        });

        const end = () => { pointers.clear(); dragStart = null; gestureStart = null; };
        el.addEventListener("pointerup", end);
        el.addEventListener("pointercancel", end);

        el.addEventListener("wheel", (e) => {
          e.preventDefault();
          const factor = e.deltaY > 0 ? 0.92 : 1.08;
          state.scale = clamp(state.scale * factor, 0.2, 6);
          onUpdate();
        }, { passive: false });
      }

      /* =========================
         PUFF transform
      ========================= */
      const puffState = { x: 50, y: 72, scale: 1.55, rotation: 0 };
      function updatePuff() { applyTransform(puffEl, puffState); }
      updatePuff();
      enableTouchDragPinch(puffEl, puffState, updatePuff);

      /* =========================
         MULTI-STICKERS (manual stickers, unchanged)
      ========================= */
      let stickersLoaded = false;
      const stickerStates = new Map();
      let selectedStickerEl = null;

      function setSelectedSticker(el) {
        if (selectedStickerEl && selectedStickerEl !== el) selectedStickerEl.classList.remove("selected");
        selectedStickerEl = el;
        if (selectedStickerEl) selectedStickerEl.classList.add("selected");
        stickerRemove.disabled = !selectedStickerEl;
        stickerClear.disabled = stickerStates.size === 0;
      }

      function createSticker(src) {
        const el = document.createElement("img");
        el.className = "sticker";
        el.alt = "sticker";
        el.crossOrigin = "anonymous";
        el.src = src;
        el.style.pointerEvents = "auto";
        stickerLayer.appendChild(el);

        const state = { x: 50, y: 40, scale: 1.0, rotation: 0 };
        stickerStates.set(el, state);

        function update() { applyTransform(el, state); }
        update();

        el.addEventListener("pointerdown", () => setSelectedSticker(el), true);
        el.addEventListener("click", () => setSelectedSticker(el));
        makeTransformable(el, state, update);

        setSelectedSticker(el);
        stickerClear.disabled = stickerStates.size === 0;
      }

      function openStickerPanel() {
        stickerPanel.classList.add("open");
        stickerPanel.setAttribute("aria-hidden", "false");
        if (!stickersLoaded) loadStickers();
      }
      function closeStickerPanel() {
        stickerPanel.classList.remove("open");
        stickerPanel.setAttribute("aria-hidden", "true");
      }

      stickersBtn.addEventListener("click", () => { if (!stickersBtn.disabled) openStickerPanel(); });
      stickerClose.addEventListener("click", closeStickerPanel);

      stickerRemove.addEventListener("click", () => {
        if (!selectedStickerEl) return;
        stickerStates.delete(selectedStickerEl);
        selectedStickerEl.remove();
        selectedStickerEl = null;
        const last = Array.from(stickerStates.keys()).pop() || null;
        setSelectedSticker(last);
        stickerClear.disabled = stickerStates.size === 0;
      });

      stickerClear.addEventListener("click", () => {
        for (const el of stickerStates.keys()) el.remove();
        stickerStates.clear();
        setSelectedSticker(null);
        stickerClear.disabled = true;
      });

      // We also reuse stickers.json for export-random-stickers.
      let stickerCatalog = []; // {src, ...maybe color/tags}
      async function loadStickers() {
        try {
          const res = await fetch(vq("./stickers.json"));
          const list = await res.json();
          stickersLoaded = true;
          stickerCatalog = Array.isArray(list) ? list : [];

          stickerGrid.innerHTML = "";
          stickerCatalog.forEach((item) => {
            const cell = document.createElement("button");
            cell.className = "stickerItem";
            cell.type = "button";
            cell.style.border = "0";
            cell.style.cursor = "pointer";

            const img = document.createElement("img");
            img.loading = "lazy";
            img.alt = item.name || item.id || "sticker";
            const encodedSrc = encodeURI(item.src);
            img.src = vq(encodedSrc);
            img.crossOrigin = "anonymous";

            cell.appendChild(img);

            cell.addEventListener("click", () => {
              createSticker(img.src);
              closeStickerPanel();
            });

            stickerGrid.appendChild(cell);
          });
        } catch (e) {
          console.error(e);
          stickerGrid.innerHTML =
            `<div style="color:#fff;font:700 12px system-ui;opacity:.9">
              Could not load stickers.json. Check ./stickers.json is deployed.
            </div>`;
        }
      }

      document.addEventListener("pointerdown", (e) => {
        const isSticker = e.target?.classList?.contains("sticker");
        const clickedPanel = stickerPanel.contains(e.target);
        const clickedFilter = filterPanel.contains(e.target);
        const clickedUI = document.getElementById("ui").contains(e.target);
        const clickedPuff = e.target === puffEl;

        if (!isSticker && !clickedPanel && !clickedFilter && !clickedUI && !clickedPuff) {
          if (selectedStickerEl) selectedStickerEl.classList.remove("selected");
          selectedStickerEl = null;
          stickerRemove.disabled = true;
          stickerClear.disabled = stickerStates.size === 0;
        }
      });

      /* =========================
         CAPTURE HELPERS
      ========================= */
      function applyRecipeToImageData(imageData, r) {
        const d = imageData.data;
        const sat = 1 + r.saturation * 0.9;
        const exposureGain = Math.pow(2, r.exposure);
        const brightnessGain = 1 + r.brightness * 0.35;
        const contrastGain = 1 + r.contrast * 0.6;

        for (let i = 0; i < d.length; i += 4) {
          let rLin = srgbToLin(d[i]);
          let gLin = srgbToLin(d[i + 1]);
          let bLin = srgbToLin(d[i + 2]);

          [rLin, gLin, bLin] = applyWarmthLin(rLin, gLin, bLin, r.warmth);

          rLin *= exposureGain * brightnessGain;
          gLin *= exposureGain * brightnessGain;
          bLin *= exposureGain * brightnessGain;

          let y = lumaLin(rLin, gLin, bLin);
          y = applyBrillianceLin(y, r.brilliance);
          y = adjustShadowsHighlightsLin(y, r.shadows, r.highlights);

          const y0 = Math.max(1e-6, lumaLin(rLin, gLin, bLin));
          const sc = y / y0;
          rLin *= sc; gLin *= sc; bLin *= sc;

          [rLin, gLin, bLin] = applySaturationLin(rLin, gLin, bLin, sat);

          const pivot = 0.18;
          rLin = (rLin - pivot) * contrastGain + pivot;
          gLin = (gLin - pivot) * contrastGain + pivot;
          bLin = (bLin - pivot) * contrastGain + pivot;

          const yFade = applyFadeLin(lumaLin(rLin, gLin, bLin), r.fade);
          const yNow = Math.max(1e-6, lumaLin(rLin, gLin, bLin));
          const s2 = yFade / yNow;
          rLin *= s2; gLin *= s2; bLin *= s2;

          d[i] = linToSrgb(rLin);
          d[i + 1] = linToSrgb(gLin);
          d[i + 2] = linToSrgb(bLin);
        }

        if (r.noiseReduce > 0.01) noiseReduceLight(imageData, clamp01(r.noiseReduce * 0.35));
        if (r.sharpness > 0.01) unsharpMask(imageData, clamp01(r.sharpness * 0.55), 1);
        return imageData;
      }

      // Capture EXACTLY what user sees on screen (full-screen preview framing)
      function captureToBlob(cb) {
        if (!stream || !cameraEl.videoWidth || !cameraEl.videoHeight) {
          alert("Start AR first.");
          return;
        }

        const out = document.createElement("canvas");
        out.width = cameraEl.videoWidth;
        out.height = cameraEl.videoHeight;
        const ctx = out.getContext("2d", { willReadFrequently: true });

        const vw = cameraEl.videoWidth, vh = cameraEl.videoHeight;

        // We want: match preview ("object-fit: cover") cropping, then render at native res.
        // Compute visible crop in video space based on viewport aspect ratio.
        const viewAR = innerWidth / innerHeight;
        const vidAR = vw / vh;
        let sx = 0, sy = 0, sw = vw, sh = vh;

        if (vidAR > viewAR) {
          // video wider => crop left/right
          sh = vh;
          sw = vh * viewAR;
          sx = (vw - sw) / 2;
        } else {
          // video taller => crop top/bottom
          sw = vw;
          sh = vw / viewAR;
          sy = (vh - sh) / 2;
        }

        const mirrorOutput = shouldMirrorPreview();

        // Draw camera crop to full canvas
        ctx.save();
        if (mirrorOutput) { ctx.translate(vw, 0); ctx.scale(-1, 1); }
        ctx.drawImage(cameraEl, sx, sy, sw, sh, 0, 0, vw, vh);
        ctx.restore();

        // Apply filter to the final output (not only preview)
        if (currentFilterId !== "none") {
          const imgData = ctx.getImageData(0, 0, vw, vh);
          applyRecipeToImageData(imgData, currentRecipe);
          ctx.putImageData(imgData, 0, 0);
        }

        // Helper: map DOM element center/size from screen->output pixels
        // Because output is the "cover" result, we map using viewport directly.
        function mapScreenToOut(px, py) {
          // Screen (0..innerWidth/innerHeight) -> within crop region -> output (0..vw/vh)
          // Since we rendered crop to full output, mapping is:
          // if vid wider: screen x maps to sx..sx+sw, else y maps to sy..sy+sh.
          const nx = px / innerWidth;
          const ny = py / innerHeight;

          const xVid = sx + nx * sw;
          const yVid = sy + ny * sh;

          // Now map to out, but we drew crop stretched to full canvas
          const xOut = ((xVid - sx) / sw) * vw;
          const yOut = ((yVid - sy) / sh) * vh;
          return { xOut, yOut };
        }

        // Map sizes: use element bounding box in screen px -> output px
        function mapRectToOut(domRect, aspectW, aspectH) {
          const cx = domRect.left + domRect.width / 2;
          const cy = domRect.top + domRect.height / 2;
          const center = mapScreenToOut(cx, cy);

          const wOut = (domRect.width / innerWidth) * vw;
          const hOut = (domRect.height / innerHeight) * vh;

          // Keep AR of actual media content where possible
          const ar = aspectW && aspectH ? (aspectW / aspectH) : (wOut / hOut);
          let drawW = wOut;
          let drawH = drawW / ar;
          if (drawH > hOut) {
            drawH = hOut;
            drawW = drawH * ar;
          }
          return { centerX: center.xOut, centerY: center.yOut, drawW, drawH };
        }

        function mirrorX(x) { return mirrorOutput ? vw - x : x; }

        // Puff
        const puffRect = puffEl.getBoundingClientRect();
        const puffDraw = mapRectToOut(puffRect, puffEl.videoWidth, puffEl.videoHeight);

        ctx.save();
        ctx.translate(mirrorX(puffDraw.centerX), puffDraw.centerY);
        const puffRotation = mirrorOutput ? -puffState.rotation : puffState.rotation;
        ctx.rotate((puffRotation * Math.PI) / 180);
        ctx.drawImage(puffEl, -puffDraw.drawW / 2, -puffDraw.drawH / 2, puffDraw.drawW, puffDraw.drawH);
        ctx.restore();

        // Stickers
        for (const [el, st] of stickerStates.entries()) {
          if (!el.complete || !el.naturalWidth) continue;
          const r = el.getBoundingClientRect();
          const d = mapRectToOut(r, el.naturalWidth, el.naturalHeight);
          ctx.save();
          ctx.translate(mirrorX(d.centerX), d.centerY);
          const stickerRotation = mirrorOutput ? -st.rotation : st.rotation;
          ctx.rotate((stickerRotation * Math.PI) / 180);
          ctx.drawImage(el, -d.drawW / 2, -d.drawH / 2, d.drawW, d.drawH);
          ctx.restore();
        }

        out.toBlob((blob) => cb(blob), "image/png");
      }

      /* =========================
         SINGLE CAPTURE (photobooth OFF)
      ========================= */
      function nextCaptureFilename() {
        const key = "puff_capture_counter";
        const current = parseInt(localStorage.getItem(key) || "0", 10) + 1;
        localStorage.setItem(key, String(current));
        const num = String(current).padStart(3, "0");
        return `Puff Dragon_HPNY2026_${num}.png`;
      }

      function openDownloadWindow(blob) {
        const win = window.open("about:blank", "_blank");
        if (!win) { alert("Popup blocked. Please allow popups for this site."); return; }
        const filename = nextCaptureFilename();
        const url = URL.createObjectURL(blob);

        win.document.write(`
          <title>${filename}</title>
          <div style="margin:0;background:#000;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:18px;">
            <img src="${url}" style="max-width:100%;height:auto;display:block;" />
            <a href="${url}" download="${filename}"
               style="display:inline-block;padding:10px 14px;border-radius:12px;background:#fff100;color:#060d3d;font:900 14px system-ui;text-decoration:none">
              Download (${filename})
            </a>
          </div>
        `);
        win.document.close();
        setTimeout(() => URL.revokeObjectURL(url), 15000);
      }

      /* =========================
         PHOTOBOOTH MODE
      ========================= */
      let photoboothOn = false;

      const capturedPanel = document.getElementById("capturedPanel");
      const capturedHeader = document.getElementById("capturedHeader");
      const capturedList = document.getElementById("capturedList");
      const cueBtn = document.getElementById("cueBtn");
      const clearCapturedBtn = document.getElementById("clearCapturedBtn");

      const capturedItems = []; // { blob, url }
      let selectedCaptureIndex = -1;

      function setPhotoboothMode(on) {
        photoboothOn = on;
        photoboothToggleBtn.textContent = on ? "Photobooth: ON" : "Photobooth: OFF";
        photoboothToggleBtn.classList.toggle("on", on);

        if (on) {
          capturedPanel.classList.remove("hidden");
          capturedPanel.setAttribute("aria-hidden", "false");
        } else {
          capturedPanel.classList.add("hidden");
          capturedPanel.setAttribute("aria-hidden", "true");
        }
        updateCapturedUI();
      }

      photoboothToggleBtn.addEventListener("click", () => {
        setPhotoboothMode(!photoboothOn);
      });

      function updateCapturedUI() {
        capturedList.innerHTML = "";
        capturedItems.forEach((it, idx) => {
          const cell = document.createElement("div");
          cell.className = "capThumb" + (idx === selectedCaptureIndex ? " selected" : "");
          const img = document.createElement("img");
          img.src = it.url;
          img.alt = "capture";
          cell.appendChild(img);
          cell.addEventListener("click", () => {
            selectedCaptureIndex = idx;
            updateCapturedUI();
          });
          capturedList.appendChild(cell);
        });
        cueBtn.disabled = capturedItems.length === 0;
      }

      clearCapturedBtn.addEventListener("click", () => {
        for (const it of capturedItems) URL.revokeObjectURL(it.url);
        capturedItems.length = 0;
        selectedCaptureIndex = -1;
        updateCapturedUI();
      });

      /* make captured panel movable */
      (function enableDragPanel() {
        let dragging = false;
        let start = null;

        capturedHeader.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          dragging = true;
          capturedHeader.setPointerCapture?.(e.pointerId);
          const rect = capturedPanel.getBoundingClientRect();
          start = { x: e.clientX, y: e.clientY, left: rect.left, top: rect.top };
          capturedHeader.style.cursor = "grabbing";
        });

        window.addEventListener("pointermove", (e) => {
          if (!dragging || !start) return;
          e.preventDefault();
          const dx = e.clientX - start.x;
          const dy = e.clientY - start.y;

          const newLeft = clamp(start.left + dx, 6, innerWidth - capturedPanel.offsetWidth - 6);
          const newTop = clamp(start.top + dy, 6, innerHeight - capturedPanel.offsetHeight - 6);

          capturedPanel.style.left = newLeft + "px";
          capturedPanel.style.top = newTop + "px";
          capturedPanel.style.right = "auto";
        }, { passive: false });

        window.addEventListener("pointerup", () => {
          dragging = false;
          start = null;
          capturedHeader.style.cursor = "grab";
        });
      })();

      /* =========================
         CAPTURE BUTTON
      ========================= */
      captureBtn.addEventListener("click", () => {
        if (!photoboothOn) {
          captureToBlob((blob) => {
            if (!blob) { alert("Capture failed."); return; }
            openDownloadWindow(blob);
          });
          return;
        }

        captureToBlob((blob) => {
          if (!blob) { alert("Capture failed."); return; }
          const url = URL.createObjectURL(blob);
          capturedItems.push({ blob, url });
          selectedCaptureIndex = capturedItems.length - 1;
          updateCapturedUI();
        });
      });

      /* =========================
         BUILDER (customize page)
      ========================= */
      const builderOverlay = document.getElementById("builderOverlay");
      const builderCloseBtn = document.getElementById("builderCloseBtn");
      const stripCanvas = document.getElementById("stripCanvas");
      const stripCtx = stripCanvas.getContext("2d");

      const frameColorRow = document.getElementById("frameColorRow");
      const layoutRow = document.getElementById("layoutRow");
      const exportStripBtn = document.getElementById("exportStripBtn");

      cueBtn.addEventListener("click", () => openBuilder());
      builderCloseBtn.addEventListener("click", closeBuilder);

      function openBuilder() {
        if (capturedItems.length === 0) return;
        builderOverlay.classList.remove("hidden");
        builderOverlay.setAttribute("aria-hidden", "false");
        syncCanvasToLayout();
        renderBuilderUI();
        drawStrip(false);
      }

      function closeBuilder() {
        builderOverlay.classList.add("hidden");
        builderOverlay.setAttribute("aria-hidden", "true");
        selectedSlotIndex = -1;
      }

      // Frame colors (ONLY 5)
      const FRAME_COLORS = [
        { id: "red",   name: "Imperial Red", value: "#fa213f", logo: "puff-logo-2.png" },
        { id: "blue",  name: "Dark Blue",    value: "#060d3d", logo: "puff-logo-3.png" },
        { id: "grey",  name: "Bright Grey",  value: "#e8eef1", logo: "puff-logo-1.png" },
        { id: "white", name: "White",        value: "#ffffff", logo: "puff-logo-1.png" },
        { id: "black", name: "Pure Black",   value: "#000000", logo: "puff-logo-3.png" }, // treat as Dark Blue rule
      ];

      // Layouts (L1–L11)
      const LAYOUTS = [
        { id: "L1",  name: "Layout 1" },
        { id: "L2",  name: "Layout 2" },
        { id: "L3",  name: "Layout 3" },
        { id: "L4",  name: "Layout 4" },
        { id: "L5",  name: "Layout 5" },
        { id: "L6",  name: "Layout 6" },
        { id: "L7",  name: "Layout 7" },
        { id: "L8",  name: "Layout 8" },
        { id: "L9",  name: "Layout 9" },
        { id: "L10", name: "Layout 10" },
        { id: "L11", name: "Layout 11" },
      ];

      // Each slot has transform for scaling/positioning (mobile pinch)
      // slotState: { capIndex, scale, ox, oy } where ox/oy are offsets in [-1..1] relative to slot size
      let builderState = {
        frameColorId: "blue",
        layoutId: "L2",
        slots: [], // dynamically sized
      };

      function slotsNeeded() {
        if (builderState.layoutId === "L3") return 4;
        if (builderState.layoutId === "L4" || builderState.layoutId === "L5") return 2;
        if (builderState.layoutId === "L6") return 2;
        if (builderState.layoutId === "L7") return 1;
        if (builderState.layoutId === "L8" || builderState.layoutId === "L9") return 2;
        if (builderState.layoutId === "L10") return 1;
        if (builderState.layoutId === "L11") return 2;
        return 3;
      }

      function ensureSlotStateCount() {
        const n = slotsNeeded();
        while (builderState.slots.length < n) builderState.slots.push({ capIndex: -1, scale: 1, ox: 0, oy: 0 });
        if (builderState.slots.length > n) builderState.slots = builderState.slots.slice(0, n);
      }

      // Canvas sizes
      function syncCanvasToLayout() {
        if (builderState.layoutId === "L1")  { stripCanvas.width = 1200; stripCanvas.height = 400;  return; } // 2x6 horizontal
        if (builderState.layoutId === "L2")  { stripCanvas.width = 400;  stripCanvas.height = 1200; return; } // 2x6 vertical
        if (builderState.layoutId === "L3")  { stripCanvas.width = 900;  stripCanvas.height = 1350; return; } // 4x6 vertical
        if (builderState.layoutId === "L4" || builderState.layoutId === "L5") { stripCanvas.width = 1200; stripCanvas.height = 400;  return; } // 2x6 horizontal 2 pose
        if (builderState.layoutId === "L6" || builderState.layoutId === "L7") { stripCanvas.width = 1350; stripCanvas.height = 900;  return; } // 4x6 horizontal
        if (builderState.layoutId === "L8" || builderState.layoutId === "L9") { stripCanvas.width = 1200; stripCanvas.height = 400;  return; } // 2x6 horizontal 2 pose + bar
        if (builderState.layoutId === "L10" || builderState.layoutId === "L11") { stripCanvas.width = 1200; stripCanvas.height = 900; return; } // 4x6 horizontal
      }

      // Logo cache
      const logoImgCache = new Map();
      function loadImage(src) {
        return new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => resolve(img);
          img.onerror = () => resolve(null);
          img.src = vq(src);
        });
      }

      async function getLogoImage() {
        const c = FRAME_COLORS.find((x) => x.id === builderState.frameColorId) || FRAME_COLORS[1];
        const src = c.logo;
        if (logoImgCache.has(src)) return logoImgCache.get(src);
        const img = await loadImage(src);
        logoImgCache.set(src, img);
        return img;
      }

      function getFrameColor() {
        const c = FRAME_COLORS.find((x) => x.id === builderState.frameColorId) || FRAME_COLORS[1];
        return c.value;
      }

      function renderBuilderUI() {
        ensureSlotStateCount();

        frameColorRow.innerHTML = "";
        FRAME_COLORS.forEach((c) => {
          const p = document.createElement("div");
          p.className = "pill" + (builderState.frameColorId === c.id ? " active" : "");
          p.textContent = c.name;
          p.addEventListener("click", () => {
            builderState.frameColorId = c.id;
            renderBuilderUI();
            drawStrip(false);
          });
          frameColorRow.appendChild(p);
        });

        layoutRow.innerHTML = "";
        LAYOUTS.forEach((l) => {
          const p = document.createElement("div");
          p.className = "pill" + (builderState.layoutId === l.id ? " active" : "");
          p.textContent = l.name;
          p.addEventListener("click", () => {
            builderState.layoutId = l.id;
            syncCanvasToLayout();
            ensureSlotStateCount();
            renderBuilderUI();
            drawStrip(false);
          });
          layoutRow.appendChild(p);
        });
      }

      // Layout geometry (single-color frame; tighter gaps; top margin > bottom)
      function getLayoutSlots() {
        const W = stripCanvas.width;
        const H = stripCanvas.height;
        const minSide = Math.min(W, H);

        const outerLR = Math.round(minSide * 0.055);
        const outerTop = Math.round(minSide * 0.075);   // top bigger
        const outerBot = Math.round(minSide * 0.050);   // bottom smaller

        const bar = Math.round(minSide * 0.13);         // top/bottom filled area
        const gap = Math.round(minSide * 0.020);        // tighter spacing

        const contentX = outerLR;
        const contentY = outerTop + bar;
        const contentW = W - outerLR * 2;
        const contentH = H - outerTop - outerBot - bar * 2;

        const topBarRect = { x: contentX, y: outerTop, w: contentW, h: bar };
        const botBarRect = { x: contentX, y: H - outerBot - bar, w: contentW, h: bar };

        // Helpers
        const res = (slots, bars) => ({ outerLR, outerTop, outerBot, bar, gap, topBar: topBarRect, botBar: botBarRect, slots, bars: bars || [] });

        if (builderState.layoutId === "L1") {
          // 3 photos left-to-right
          const slotW = Math.floor((contentW - gap * 2) / 3);
          const slotH = contentH;
          return res([
            { x: contentX, y: contentY, w: slotW, h: slotH },
            { x: contentX + slotW + gap, y: contentY, w: slotW, h: slotH },
            { x: contentX + (slotW + gap) * 2, y: contentY, w: slotW, h: slotH },
          ]);
        }

        if (builderState.layoutId === "L2") {
          // 3 photos top-to-bottom
          const slotH = Math.floor((contentH - gap * 2) / 3);
          const slotW = contentW;
          return res([
            { x: contentX, y: contentY, w: slotW, h: slotH },
            { x: contentX, y: contentY + slotH + gap, w: slotW, h: slotH },
            { x: contentX, y: contentY + (slotH + gap) * 2, w: slotW, h: slotH },
          ]);
        }

        if (builderState.layoutId === "L3") {
          // 2x2 grid
          const slotW = Math.floor((contentW - gap) / 2);
          const slotH = Math.floor((contentH - gap) / 2);
          return res([
            { x: contentX, y: contentY, w: slotW, h: slotH },
            { x: contentX + slotW + gap, y: contentY, w: slotW, h: slotH },
            { x: contentX, y: contentY + slotH + gap, w: slotW, h: slotH },
            { x: contentX + slotW + gap, y: contentY + slotH + gap, w: slotW, h: slotH },
          ]);
        }

        if (builderState.layoutId === "L4") {
          // 2 photos horizontal (like Layout 8/9 but without bar): 2 slots
          const slotW = Math.floor((contentW - gap) / 2);
          const slotH = contentH;
          return res([
            { x: contentX, y: contentY, w: slotW, h: slotH },
            { x: contentX + slotW + gap, y: contentY, w: slotW, h: slotH },
          ]);
        }

        if (builderState.layoutId === "L5") {
          // 2 photos vertical: 2 stacked
          const slotH = Math.floor((contentH - gap) / 2);
          const slotW = contentW;
          return res([
            { x: contentX, y: contentY, w: slotW, h: slotH },
            { x: contentX, y: contentY + slotH + gap, w: slotW, h: slotH },
          ]);
        }

        if (builderState.layoutId === "L6") {
          // 4x6 horizontal: 2 photos side-by-side
          const slotW = Math.floor((contentW - gap) / 2);
          const slotH = contentH;
          return res([
            { x: contentX, y: contentY, w: slotW, h: slotH },
            { x: contentX + slotW + gap, y: contentY, w: slotW, h: slotH },
          ]);
        }

        if (builderState.layoutId === "L7") {
          // 4x6 horizontal: 1 photo centered with frame
          const inset = Math.round(minSide * 0.04);
          return res([
            { x: contentX + inset, y: contentY + inset, w: contentW - inset * 2, h: contentH - inset * 2 },
          ]);
        }

        if (builderState.layoutId === "L8") {
          // Left black bar, two photos to the right
          const barW = Math.floor(contentW * 0.26);
          const photosW = contentW - barW - gap;
          const slotW = Math.floor((photosW - gap) / 2);
          const slotH = contentH;
          return res(
            [
              { x: contentX + barW + gap, y: contentY, w: slotW, h: slotH },
              { x: contentX + barW + gap + slotW + gap, y: contentY, w: slotW, h: slotH },
            ],
            [{ x: contentX, y: contentY, w: barW, h: slotH }]
          );
        }

        if (builderState.layoutId === "L9") {
          // Center black bar, two photos left/right
          const barW = Math.floor(contentW * 0.22);
          const photosW = contentW - barW - gap * 2;
          const slotW = Math.floor(photosW / 2);
          const slotH = contentH;

          const leftX = contentX;
          const barX = contentX + slotW + gap;
          const rightX = barX + barW + gap;

          return res(
            [
              { x: leftX, y: contentY, w: slotW, h: slotH },
              { x: rightX, y: contentY, w: slotW, h: slotH },
            ],
            [{ x: barX, y: contentY, w: barW, h: slotH }]
          );
        }

        if (builderState.layoutId === "L10") {
          // One big photo
          const inset = Math.round(minSide * 0.04);
          return res([{ x: contentX + inset, y: contentY + inset, w: contentW - inset * 2, h: contentH - inset * 2 }]);
        }

        if (builderState.layoutId === "L11") {
          // Two stacked photos on left + right bar
          const barW = Math.floor(contentW * 0.38);
          const leftW = contentW - barW - gap;
          const slotH = Math.floor((contentH - gap) / 2);
          return res(
            [
              { x: contentX, y: contentY, w: leftW, h: slotH },
              { x: contentX, y: contentY + slotH + gap, w: leftW, h: slotH },
            ],
            [{ x: contentX + leftW + gap, y: contentY, w: barW, h: contentH }]
          );
        }

        // fallback (shouldn't hit)
        return res([]);
      }

      // Draw image into rect, with optional user scale/offset inside slot
      function drawCoverWithTransform(ctx, img, slot, tr) {
        const iw = img.naturalWidth || img.width;
        const ih = img.naturalHeight || img.height;
        if (!iw || !ih) return;

        const baseS = Math.max(slot.w / iw, slot.h / ih);
        const extra = tr?.scale || 1;
        const s = baseS * extra;

        const dw = iw * s;
        const dh = ih * s;

        const ox = (tr?.ox || 0) * (slot.w * 0.35);
        const oy = (tr?.oy || 0) * (slot.h * 0.35);

        const dx = slot.x + (slot.w - dw) / 2 + ox;
        const dy = slot.y + (slot.h - dh) / 2 + oy;

        ctx.drawImage(img, dx, dy, dw, dh);
      }

      // Selection/assignment on canvas
      let selectedSlotIndex = -1;

      function canvasPoint(e) {
        const rect = stripCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (stripCanvas.width / rect.width);
        const y = (e.clientY - rect.top) * (stripCanvas.height / rect.height);
        return { x, y };
      }

      function hitSlot(pt, slots) {
        for (let i = 0; i < slots.length; i++) {
          const s = slots[i];
          if (pt.x >= s.x && pt.x <= s.x + s.w && pt.y >= s.y && pt.y <= s.y + s.h) return i;
        }
        return -1;
      }

      function assignSelectedCaptureToSlot(slotIdx) {
        if (slotIdx < 0) return;
        if (selectedCaptureIndex < 0) return;

        ensureSlotStateCount();
        builderState.slots[slotIdx] = { capIndex: selectedCaptureIndex, scale: 1, ox: 0, oy: 0 };
        selectedSlotIndex = slotIdx;
        drawStrip(false);
      }

      /* =========================
         RANDOM EXPORT STICKERS (3–5, unique, outer frame only, color-matched)
      ========================= */

      // Color tags (we try to read from stickers.json if provided; else infer from filename)
      const COLOR_TAG = {
        YELLOW: "yellow",
        AZURE: "azure",
        ORANGE: "orange",
        WHITE: "white",
        GREY: "grey",
        RED: "red",
        PINK: "pink",
        MAGENTA: "magenta",
        GREEN: "green",
        PURPLE: "purple",
        DARK: "dark",
      };

      function inferStickerTag(item) {
        const src = (item?.src || "").toLowerCase();
        const tags = (item?.tags || item?.tag || item?.color || item?.palette || "");
        const t = Array.isArray(tags) ? tags.join(" ").toLowerCase() : String(tags).toLowerCase();
        const s = `${src} ${t}`;
        if (s.includes("yellow") || s.includes("fluorescent")) return COLOR_TAG.YELLOW;
        if (s.includes("azure") || s.includes("blue1") || s.includes("cyan")) return COLOR_TAG.AZURE;
        if (s.includes("orange") || s.includes("safety")) return COLOR_TAG.ORANGE;
        if (s.includes("white")) return COLOR_TAG.WHITE;
        if (s.includes("grey") || s.includes("gray")) return COLOR_TAG.GREY;
        if (s.includes("vivid") || s.includes("imperial") || s.includes("red")) return COLOR_TAG.RED;
        if (s.includes("candy") || s.includes("pink")) return COLOR_TAG.PINK;
        if (s.includes("magenta") || s.includes("hot")) return COLOR_TAG.MAGENTA;
        if (s.includes("green")) return COLOR_TAG.GREEN;
        if (s.includes("purple")) return COLOR_TAG.PURPLE;
        if (s.includes("dark")) return COLOR_TAG.DARK;
        return "unknown";
      }

      // Frame -> allowed tags (your rules)
      function allowedTagsForFrame(frameId) {
        const f = frameId === "black" ? "blue" : frameId; // Pure Black behaves like Dark Blue
        if (f === "red") {
          return new Set([COLOR_TAG.YELLOW, COLOR_TAG.AZURE, COLOR_TAG.GREY, COLOR_TAG.WHITE]);
        }
        if (f === "blue") {
          return new Set([COLOR_TAG.YELLOW, COLOR_TAG.ORANGE, COLOR_TAG.PINK, COLOR_TAG.WHITE, COLOR_TAG.AZURE]);
        }
        if (f === "grey") {
          return new Set([COLOR_TAG.RED, COLOR_TAG.ORANGE, COLOR_TAG.MAGENTA, COLOR_TAG.AZURE, COLOR_TAG.GREEN, COLOR_TAG.PURPLE]);
        }
        if (f === "white") {
          return new Set([COLOR_TAG.RED, COLOR_TAG.ORANGE, COLOR_TAG.YELLOW, COLOR_TAG.MAGENTA, COLOR_TAG.AZURE, COLOR_TAG.PURPLE, "blue"]);
        }
        // fallback
        return new Set(["unknown", COLOR_TAG.YELLOW, COLOR_TAG.AZURE, COLOR_TAG.ORANGE, COLOR_TAG.RED, COLOR_TAG.PINK, COLOR_TAG.MAGENTA, COLOR_TAG.GREEN, COLOR_TAG.PURPLE, COLOR_TAG.WHITE]);
      }

      function avoidTagsForFrame(frameId) {
        const f = frameId === "black" ? "blue" : frameId;
        if (f === "red") return new Set(["deepcrimson", "coralpink", COLOR_TAG.PURPLE, COLOR_TAG.DARK]);
        if (f === "blue") return new Set([COLOR_TAG.DARK, COLOR_TAG.PURPLE]);
        if (f === "grey") return new Set([COLOR_TAG.WHITE]); // unless outline; we avoid by default
        if (f === "white") return new Set([COLOR_TAG.GREY]);  // avoid bright grey if no border
        return new Set();
      }

      function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
      function pickRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
      function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }

      // Outer-only placement regions (exclude photo slots)
      function buildOuterRegions(layout) {
        const W = stripCanvas.width;
        const H = stripCanvas.height;
        const regions = [];

        // top bar, bottom bar
        regions.push({ ...layout.topBar });
        regions.push({ ...layout.botBar });

        // left margin area between bars
        const leftW = layout.outerLR;
        const midY = layout.outerTop;
        const midH = H - layout.outerTop - layout.outerBot;
        regions.push({ x: 0, y: midY, w: leftW, h: midH });

        // right margin
        regions.push({ x: W - layout.outerLR, y: midY, w: layout.outerLR, h: midH });

        // inner "bars" (black blocks inside content)
        if (layout.bars?.length) {
          layout.bars.forEach((b) => regions.push({ ...b }));
        }

        // also allow slim strips around content area (outer frame around photos)
        const contentTop = layout.topBar.y + layout.topBar.h;
        const contentBot = layout.botBar.y;
        regions.push({ x: layout.topBar.x, y: contentTop, w: layout.topBar.w, h: Math.max(0, layout.gap) }); // tiny band
        regions.push({ x: layout.topBar.x, y: contentBot - layout.gap, w: layout.topBar.w, h: Math.max(0, layout.gap) });

        // Filter out too tiny regions
        return regions.filter((r) => r.w > 20 && r.h > 20);
      }

      function rectsIntersect(a, b) {
        return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
      }

      async function pickStickerImagesForExport() {
        if (!stickerCatalog.length) {
          // Try load silently if not loaded yet
          try {
            const res = await fetch(vq("./stickers.json"));
            const list = await res.json();
            stickerCatalog = Array.isArray(list) ? list : [];
          } catch (_) {}
        }
        const all = stickerCatalog.slice(0, 51); // ensure max 51 if file has more
        if (!all.length) return [];

        const allow = allowedTagsForFrame(builderState.frameColorId);
        const avoid = avoidTagsForFrame(builderState.frameColorId);

        // Build candidates by tag
        const candidates = [];
        for (const it of all) {
          const tag = inferStickerTag(it);
          // If we can match, great; else allow unknown but lower priority
          const ok = allow.has(tag) || tag === "unknown";
          if (!ok) continue;
          if (avoid.has(tag)) continue;
          candidates.push({ ...it, _tag: tag });
        }
        const pool = candidates.length ? candidates : all.map((it) => ({ ...it, _tag: inferStickerTag(it) }));

        // Random count 3–5, unique
        const count = Math.min(randInt(3, 5), pool.length);
        shuffle(pool);

        // Ensure unique by src
        const used = new Set();
        const chosen = [];
        for (const it of pool) {
          const key = it.src;
          if (used.has(key)) continue;
          used.add(key);
          chosen.push(it);
          if (chosen.length >= count) break;
        }
        return chosen;
      }

      async function renderRandomExportStickers(layout, slotRects) {
        // Load sticker images
        const picks = await pickStickerImagesForExport();
        if (!picks.length) return;

        const regions = buildOuterRegions(layout);
        const minSide = Math.min(stripCanvas.width, stripCanvas.height);

        // Place each sticker: small, random rotation, random scale; avoid slotRects.
        for (const it of picks) {
          const img = await loadImage(it.src);
          if (!img) continue;

          const iw = img.naturalWidth || img.width;
          const ih = img.naturalHeight || img.height;
          if (!iw || !ih) continue;

          // Target size: small
          const base = minSide * 0.14;
          const scale = (0.75 + Math.random() * 0.35); // smaller & natural
          const targetW = base * scale;
          const targetH = (ih / iw) * targetW;

          // Try multiple attempts to find safe placement
          let placed = false;
          for (let attempt = 0; attempt < 30 && !placed; attempt++) {
            const reg = pickRandom(regions);

            const pad = Math.round(minSide * 0.02);
            const x = reg.x + pad + Math.random() * Math.max(1, reg.w - targetW - pad * 2);
            const y = reg.y + pad + Math.random() * Math.max(1, reg.h - targetH - pad * 2);

            const bbox = { x, y, w: targetW, h: targetH };

            // Must NOT overlap photo slots (with a small buffer)
            const buffer = Math.round(minSide * 0.015);
            const expandedSlots = slotRects.map((s) => ({ x: s.x - buffer, y: s.y - buffer, w: s.w + buffer * 2, h: s.h + buffer * 2 }));

            if (expandedSlots.some((s) => rectsIntersect(bbox, s))) continue;

            // Lightly rotate
            const rot = (Math.random() * 18 - 9) * (Math.PI / 180);

            stripCtx.save();
            stripCtx.translate(x + targetW / 2, y + targetH / 2);
            stripCtx.rotate(rot);
            stripCtx.drawImage(img, -targetW / 2, -targetH / 2, targetW, targetH);
            stripCtx.restore();

            placed = true;
          }
        }
      }

      async function drawStrip(withExportStickers) {
        ensureSlotStateCount();

        // Preload selected capture images (by capIndex)
        const capImgs = await Promise.all(capturedItems.map((it) => loadImage(it.url)));

        const frameColor = getFrameColor();
        const layout = getLayoutSlots();

        // Background: single frame color only (no overlays)
        stripCtx.clearRect(0, 0, stripCanvas.width, stripCanvas.height);
        stripCtx.fillStyle = frameColor;
        stripCtx.fillRect(0, 0, stripCanvas.width, stripCanvas.height);

        // Black bars inside layout (if any)
        if (layout.bars?.length) {
          stripCtx.fillStyle = "#000000";
          layout.bars.forEach((b) => stripCtx.fillRect(b.x, b.y, b.w, b.h));
        }

        // Draw slots (only the slots that exist in this layout)
        for (let i = 0; i < layout.slots.length; i++) {
          const slot = layout.slots[i];
          const st = builderState.slots[i] || { capIndex: -1, scale: 1, ox: 0, oy: 0 };
          const img = st.capIndex >= 0 ? capImgs[st.capIndex] : null;

          // Empty slot: subtle dark fill ONLY (no stroke)
          if (!img) {
            stripCtx.fillStyle = "rgba(0,0,0,0.18)";
            stripCtx.fillRect(slot.x, slot.y, slot.w, slot.h);
          } else {
            // Clip to slot rect
            stripCtx.save();
            stripCtx.beginPath();
            stripCtx.rect(slot.x, slot.y, slot.w, slot.h);
            stripCtx.clip();
            drawCoverWithTransform(stripCtx, img, slot, st);
            stripCtx.restore();
          }

          // Selected slot highlight (very subtle; export unaffected)
          if (!withExportStickers && i === selectedSlotIndex) {
            stripCtx.save();
            stripCtx.strokeStyle = "rgba(255,241,0,0.9)";
            stripCtx.lineWidth = Math.max(2, Math.min(stripCanvas.width, stripCanvas.height) * 0.006);
            stripCtx.strokeRect(slot.x + 2, slot.y + 2, slot.w - 4, slot.h - 4);
            stripCtx.restore();
          }
        }

        // Logo bigger (top centered)
        const logoImg = await getLogoImage();
        if (logoImg) {
          const top = layout.topBar;
          const maxW = top.w * 0.38; // bigger
          const maxH = top.h * 0.78; // bigger
          const iw = logoImg.naturalWidth || logoImg.width;
          const ih = logoImg.naturalHeight || logoImg.height;
          if (iw && ih) {
            const s = Math.min(maxW / iw, maxH / ih);
            const w = iw * s;
            const h = ih * s;
            const x = top.x + (top.w - w) / 2;
            const y = top.y + (top.h - h) / 2;
            stripCtx.drawImage(logoImg, x, y, w, h);
          }
        }

        // Export stickers (random 3–5) on outer frame only
        if (withExportStickers) {
          await renderRandomExportStickers(layout, layout.slots);
        }
      }

      // Canvas interactions:
      // - Tap a slot to select it
      // - If a capture thumbnail is selected: tap slot assigns it
      // - Gesture on selected slot: 1-finger drag (move image), 2-finger pinch (scale + rotate? rotate NOT needed for photos)
      (function enableSlotGestures() {
        const pointers = new Map();
        let dragStart = null;
        let pinchStart = null;

        function currentSlotRects() {
          return getLayoutSlots().slots;
        }

        stripCanvas.addEventListener("pointerdown", (e) => {
          if (builderOverlay.classList.contains("hidden")) return;
          e.preventDefault();
          stripCanvas.setPointerCapture?.(e.pointerId);

          const pt = canvasPoint(e);
          const slots = currentSlotRects();
          const hit = hitSlot(pt, slots);

          if (hit >= 0) {
            // If user has selected a capture thumb, assign on tap
            if (selectedCaptureIndex >= 0) {
              assignSelectedCaptureToSlot(hit);
            } else {
              selectedSlotIndex = hit;
              drawStrip(false);
            }
          } else {
            selectedSlotIndex = -1;
            drawStrip(false);
          }

          pointers.set(e.pointerId, pt);

          if (selectedSlotIndex < 0) return;
          const st = builderState.slots[selectedSlotIndex];
          if (!st) return;

          if (pointers.size === 1) {
            dragStart = {
              x: pt.x, y: pt.y,
              baseOx: st.ox,
              baseOy: st.oy,
            };
            pinchStart = null;
          } else if (pointers.size === 2) {
            const pts = Array.from(pointers.values());
            const a = pts[0], b = pts[1];
            pinchStart = {
              d: dist(a, b),
              baseScale: st.scale,
            };
            dragStart = null;
          }
        }, { passive: false });

        stripCanvas.addEventListener("pointermove", (e) => {
          if (!pointers.has(e.pointerId)) return;
          e.preventDefault();
          const pt = canvasPoint(e);
          pointers.set(e.pointerId, pt);

          if (selectedSlotIndex < 0) return;
          const st = builderState.slots[selectedSlotIndex];
          if (!st) return;

          const slots = currentSlotRects();
          const slot = slots[selectedSlotIndex];
          if (!slot) return;

          if (pointers.size === 1 && dragStart) {
            // move image offsets
            const dx = (pt.x - dragStart.x) / slot.w;
            const dy = (pt.y - dragStart.y) / slot.h;
            st.ox = clamp(dragStart.baseOx + dx, -1, 1);
            st.oy = clamp(dragStart.baseOy + dy, -1, 1);
            drawStrip(false);
          }

          if (pointers.size === 2 && pinchStart) {
            const pts = Array.from(pointers.values());
            const a = pts[0], b = pts[1];
            const nd = dist(a, b);
            const s = nd / Math.max(10, pinchStart.d);
            st.scale = clamp(pinchStart.baseScale * s, 0.7, 3.0);
            drawStrip(false);
          }
        }, { passive: false });

        stripCanvas.addEventListener("pointerup", (e) => {
          pointers.delete(e.pointerId);
          if (pointers.size === 0) {
            dragStart = null;
            pinchStart = null;
          } else if (pointers.size === 1 && selectedSlotIndex >= 0) {
            const pt = Array.from(pointers.values())[0];
            const st = builderState.slots[selectedSlotIndex];
            dragStart = { x: pt.x, y: pt.y, baseOx: st.ox, baseOy: st.oy };
            pinchStart = null;
          }
        });

        stripCanvas.addEventListener("pointercancel", () => {
          pointers.clear();
          dragStart = null;
          pinchStart = null;
        });
      })();

      exportStripBtn.addEventListener("click", async () => {
        await drawStrip(true); // WITH random export stickers

        stripCanvas.toBlob((blob) => {
          if (!blob) { alert("Export failed."); return; }
          const url = URL.createObjectURL(blob);
          const win = window.open("about:blank", "_blank");
          if (!win) { alert("Popup blocked."); return; }
          const filename = `Puff_Dragon_Photobooth_${Date.now()}.png`;

          win.document.write(`
            <title>${filename}</title>
            <div style="margin:0;background:#000;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:18px;">
              <img src="${url}" style="max-width:100%;height:auto;display:block;background:#000" />
              <a href="${url}" download="${filename}"
                 style="display:inline-block;padding:10px 14px;border-radius:12px;background:#fff100;color:#060d3d;font:900 14px system-ui;text-decoration:none">
                Download (${filename})
              </a>
            </div>
          `);
          win.document.close();
          setTimeout(() => URL.revokeObjectURL(url), 15000);
        }, "image/png");
      });

      /* =========================
         Photobooth toggle availability after AR start
      ========================= */
      setPhotoboothMode(false);
      applyCameraFilterPreview();

      /* =========================
         Enable photobooth toggle only after AR starts
      ========================= */
      // done in startCamera()

      /* =========================
         Close builder on backdrop click
      ========================= */
      builderOverlay.addEventListener("pointerdown", (e) => {
        if (e.target === builderOverlay) closeBuilder();
      });
    </script>
  </body>
</html>
