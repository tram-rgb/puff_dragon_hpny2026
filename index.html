<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Puff Dragon AR Viewer</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        height: 100%;
        touch-action: none;
      }

      #camera {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
      }

      #puff {
        position: fixed;
        left: 50%;
        top: 72%;
        width: min(90vw, 500px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1.55);
        transform-origin: center;
      }

      #ui {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 16px;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        justify-content: center;
        align-items: center;
        padding-bottom: calc(16px + env(safe-area-inset-bottom));
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.65),
          rgba(0, 0, 0, 0)
        );
      }

      button {
        border: 0;
        border-radius: 12px;
        padding: 12px 18px;
        font-size: 16px;
        font-weight: 600;
        color: #fff;
        background: #e11d2e;
      }

      button.secondary {
        background: rgba(255, 255, 255, 0.15);
      }
      button:disabled {
        opacity: 0.5;
      }

      #capture {
        flex-basis: 100%;
        max-width: 220px;
      }
    </style>
  </head>

  <body>
    <video id="camera" autoplay playsinline muted></video>
    <video
      id="puff"
      autoplay
      playsinline
      muted
      loop
      preload="auto"
      crossorigin="anonymous"
    ></video>

    <div id="ui">
      <button id="start">Start AR</button>
      <button id="flip" class="secondary" disabled>Flip Camera</button>
      <button id="capture" class="secondary" disabled>Puff It!</button>
    </div>

    <script>
      const cameraEl = document.getElementById("camera");
      const puffEl = document.getElementById("puff");
      const startBtn = document.getElementById("start");
      const flipBtn = document.getElementById("flip");
      const captureBtn = document.getElementById("capture");

      /* =========================
         RANDOM 2 VIDEOS (KEEP .MOV + USE .MP4)
         Priority order:
           1) .mp4 (HEVC+alpha for iPhone Safari, best for web)
           2) .mov (kept as backup as you requested)
           3) .webm (VP9+alpha for Android/Chrome)
         Files supported:
           puff.mp4 / puff2.mp4
           puff.mov / puff2.mov
           puff.webm / puff2.webm
      ========================= */

      const puffBases = ["puff", "puff2"];
      const chosenBase =
        puffBases[Math.floor(Math.random() * puffBases.length)];

      puffEl.setAttribute("playsinline", "");
      puffEl.muted = true;
      puffEl.crossOrigin = "anonymous";

      // Build <source> tags so each browser picks what it supports.
      // IMPORTANT: put MP4 first so Safari chooses it reliably.
      puffEl.innerHTML = `
        <source src="${chosenBase}.mp4" type='video/mp4; codecs="hvc1"' />
        <source src="${chosenBase}.mov" type="video/quicktime" />
        <source src="${chosenBase}.webm" type='video/webm; codecs="vp9"' />
      `;
      puffEl.load();

      /* =========================
         CAMERA
      ========================= */
      let currentFacingMode = "environment";
      let stream;

      function waitLoadedMetadata(videoEl, timeoutMs = 4000) {
        return new Promise((resolve, reject) => {
          if (videoEl.readyState >= 1 && videoEl.videoWidth > 0)
            return resolve();
          const t = setTimeout(() => {
            cleanup();
            reject(new Error("metadata timeout"));
          }, timeoutMs);
          const onMeta = () => {
            cleanup();
            resolve();
          };
          const cleanup = () => {
            clearTimeout(t);
            videoEl.removeEventListener("loadedmetadata", onMeta);
          };
          videoEl.addEventListener("loadedmetadata", onMeta, { once: true });
        });
      }

      async function startCamera() {
        captureBtn.disabled = true;

        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }

        stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: currentFacingMode },
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        });

        cameraEl.srcObject = stream;

        await waitLoadedMetadata(cameraEl).catch(() => {});
        await cameraEl.play().catch(() => {});

        await waitLoadedMetadata(puffEl).catch(() => {});
        await puffEl.play().catch(() => {});

        flipBtn.disabled = false;
        captureBtn.disabled = false;
        startBtn.textContent = "AR Running";
        startBtn.disabled = true;
      }

      startBtn.addEventListener("click", async () => {
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
          alert(
            "Could not access camera. Please allow permission and use HTTPS."
          );
        }
      });

      flipBtn.addEventListener("click", async () => {
        currentFacingMode =
          currentFacingMode === "environment" ? "user" : "environment";
        startBtn.disabled = false;
        startBtn.textContent = "Restart AR";
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
        }
      });

      /* =========================
         DRAG + PINCH + ROTATE + INERTIA
      ========================= */
      let puffX = 50,
        puffY = 72,
        puffScale = 1.55,
        puffRotation = 0;

      function applyPuffTransform() {
        puffEl.style.left = puffX + "%";
        puffEl.style.top = puffY + "%";
        puffEl.style.transform = `translate(-50%, -50%) scale(${puffScale}) rotate(${puffRotation}deg)`;
      }
      applyPuffTransform();

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }
      function getDistance(t0, t1) {
        return Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
      }
      function getAngle(t0, t1) {
        return (
          (Math.atan2(t1.clientY - t0.clientY, t1.clientX - t0.clientX) * 180) /
          Math.PI
        );
      }

      let dragStart = null,
        gestureStart = null;
      let angularVelocity = 0,
        lastAngle = null,
        lastTime = null,
        inertiaRAF = null;

      function stopInertia() {
        if (inertiaRAF) cancelAnimationFrame(inertiaRAF);
        inertiaRAF = null;
      }
      function startInertia() {
        stopInertia();
        let prev = performance.now();
        function tick(now) {
          const dt = (now - prev) / 1000;
          prev = now;
          puffRotation += angularVelocity * dt;
          applyPuffTransform();
          angularVelocity *= 0.92;
          if (Math.abs(angularVelocity) < 5) return;
          inertiaRAF = requestAnimationFrame(tick);
        }
        inertiaRAF = requestAnimationFrame(tick);
      }

      puffEl.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          stopInertia();

          if (e.touches.length === 1) {
            const t = e.touches[0];
            dragStart = {
              x: t.clientX,
              y: t.clientY,
              puffX,
              puffY,
              w: innerWidth,
              h: innerHeight,
            };
            gestureStart = null;
          }

          if (e.touches.length === 2) {
            const angle = getAngle(e.touches[0], e.touches[1]);
            gestureStart = {
              distance: getDistance(e.touches[0], e.touches[1]),
              angle,
              scale: puffScale,
              rotation: puffRotation,
            };
            lastAngle = angle;
            lastTime = performance.now();
            dragStart = null;
          }
        },
        { passive: false }
      );

      puffEl.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();

          if (e.touches.length === 1 && dragStart) {
            const t = e.touches[0];
            const dx = ((t.clientX - dragStart.x) / dragStart.w) * 100;
            const dy = ((t.clientY - dragStart.y) / dragStart.h) * 100;
            puffX = clamp(dragStart.puffX + dx, 0, 100);
            puffY = clamp(dragStart.puffY + dy, 0, 100);
            applyPuffTransform();
          }

          if (e.touches.length === 2 && gestureStart) {
            const t0 = e.touches[0],
              t1 = e.touches[1];
            const newDistance = getDistance(t0, t1);
            const newAngle = getAngle(t0, t1);

            puffScale = clamp(
              gestureStart.scale * (newDistance / gestureStart.distance),
              0.9,
              4
            );
            puffRotation =
              gestureStart.rotation + (newAngle - gestureStart.angle);

            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            if (dt > 0) angularVelocity = (newAngle - lastAngle) / dt;
            lastAngle = newAngle;
            lastTime = now;

            applyPuffTransform();
          }
        },
        { passive: false }
      );

      puffEl.addEventListener("touchend", () => {
        if (Math.abs(angularVelocity) > 30) startInertia();
        dragStart = null;
        gestureStart = null;
      });

      /* =========================
         CAPTURE NAMING HELPERS
      ========================= */
      function nextCaptureFilename() {
        const key = "puff_capture_counter";
        const current = parseInt(localStorage.getItem(key) || "0", 10) + 1;
        localStorage.setItem(key, String(current));
        const num = String(current).padStart(3, "0");
        return `Puff Dragon_HPNY2026_${num}.png`;
      }

      /* =========================
         CAPTURE -> OPEN RESULT IN NEW TAB (FIX ASPECT RATIO)
      ========================= */
      function getCoverTransform(srcW, srcH, dstW, dstH) {
        const scale = Math.max(dstW / srcW, dstH / srcH);
        const drawW = srcW * scale;
        const drawH = srcH * scale;
        const offsetX = (dstW - drawW) / 2;
        const offsetY = (dstH - drawH) / 2;
        return { scale, drawW, drawH, offsetX, offsetY };
      }

      captureBtn.addEventListener("click", () => {
        const win = window.open("about:blank", "_blank");
        if (!win) {
          alert("Popup blocked. Please allow popups for this site.");
          return;
        }

        try {
          if (!stream || !cameraEl.videoWidth || !cameraEl.videoHeight) {
            win.close();
            alert("Start AR first.");
            return;
          }

          const out = document.createElement("canvas");
          out.width = cameraEl.videoWidth;
          out.height = cameraEl.videoHeight;
          const ctx = out.getContext("2d");

          ctx.drawImage(cameraEl, 0, 0, out.width, out.height);

          const camRect = cameraEl.getBoundingClientRect();
          const cover = getCoverTransform(
            out.width,
            out.height,
            camRect.width,
            camRect.height
          );

          const puffRect = puffEl.getBoundingClientRect();
          const puffCenterX_screen =
            puffRect.left + puffRect.width / 2 - camRect.left;
          const puffCenterY_screen =
            puffRect.top + puffRect.height / 2 - camRect.top;

          const puffCenterX_cam =
            (puffCenterX_screen - cover.offsetX) / cover.scale;
          const puffCenterY_cam =
            (puffCenterY_screen - cover.offsetY) / cover.scale;

          const puffW_cam = puffRect.width / cover.scale;
          const puffH_cam = puffRect.height / cover.scale;

          const puffAR =
            puffEl.videoWidth && puffEl.videoHeight
              ? puffEl.videoWidth / puffEl.videoHeight
              : puffRect.width / puffRect.height;

          let drawW = puffW_cam;
          let drawH = drawW / puffAR;
          if (drawH > puffH_cam) {
            drawH = puffH_cam;
            drawW = drawH * puffAR;
          }

          ctx.save();
          ctx.translate(puffCenterX_cam, puffCenterY_cam);
          ctx.rotate((puffRotation * Math.PI) / 180);
          ctx.drawImage(puffEl, -drawW / 2, -drawH / 2, drawW, drawH);
          ctx.restore();

          out.toBlob((blob) => {
            if (!blob) {
              win.document.write("<h3>Capture failed</h3>");
              win.document.close();
              return;
            }

            const filename = nextCaptureFilename();
            const url = URL.createObjectURL(blob);

            win.document.write(`
              <title>${filename}</title>
              <div style="margin:0;background:#000;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:18px;">
                <img src="${url}" style="max-width:100%;height:auto;display:block;" />
                <a
                  href="${url}"
                  download="${filename}"
                  style="display:inline-block;padding:12px 16px;border-radius:12px;background:#e11d2e;color:#fff;font:600 16px system-ui;text-decoration:none"
                >
                  Download (${filename})
                </a>
                <div style="color:#fff;font:14px system-ui;opacity:.8;text-align:center;max-width:520px;line-height:1.4">
                  Tip: The filename is reliable when clicking <b>Download</b>.
                  If you long-press/save the image on mobile, the browser may choose a different name.
                </div>
              </div>
            `);

            win.document.close();
            setTimeout(() => URL.revokeObjectURL(url), 15000);
          }, "image/png");
        } catch (err) {
          console.error(err);
          win.document.write(
            `<h3>Capture Error</h3><pre style="white-space:pre-wrap">${String(
              err
            )}</pre>`
          );
          win.document.close();
          alert("Capture failed. Try again.");
        }
      });
    </script>
  </body>
</html>
