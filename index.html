<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Puff Dragon AR Viewer</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        height: 100%;
        touch-action: none;
      }

      #camera {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: 1;
      }

      #puff {
        position: fixed;
        left: 50%;
        top: 72%;
        width: min(90vw, 500px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1.55);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        z-index: 2;
      }

      /* Sticker overlay (PNG only) */
      #sticker {
        position: fixed;
        left: 50%;
        top: 40%;
        width: min(45vw, 260px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        z-index: 3;
        display: none;
      }

      #ui {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 16px;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        justify-content: center;
        align-items: center;
        padding-bottom: calc(16px + env(safe-area-inset-bottom));
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.65),
          rgba(0, 0, 0, 0)
        );
        z-index: 10;
      }

      button {
        border: 0;
        border-radius: 12px;
        padding: 12px 18px;
        font-size: 16px;
        font-weight: 600;
        color: #fff;
        background: #e11d2e;
      }

      button.secondary {
        background: rgba(255, 255, 255, 0.15);
      }
      button:disabled {
        opacity: 0.5;
      }

      #capture {
        flex-basis: 100%;
        max-width: 220px;
      }

      /* Sticker picker panel */
      #stickerPanel {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        transform: translateY(110%);
        transition: transform 0.22s ease;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        padding: 14px 14px calc(14px + env(safe-area-inset-bottom));
        z-index: 20;
        border-top-left-radius: 18px;
        border-top-right-radius: 18px;
      }

      #stickerPanel.open {
        transform: translateY(0);
      }

      #stickerPanelHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        margin-bottom: 10px;
      }

      #stickerGrid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 10px;
      }

      .stickerItem {
        background: rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1 / 1;
      }

      .stickerItem img {
        max-width: 100%;
        max-height: 100%;
        display: block;
      }
    </style>
  </head>

  <body>
    <video id="camera" autoplay playsinline muted></video>

    <video
      id="puff"
      autoplay
      playsinline
      webkit-playsinline
      muted
      loop
      preload="auto"
      crossorigin="anonymous"
    ></video>

    <img id="sticker" alt="sticker" crossorigin="anonymous" />

    <div id="ui">
      <button id="start">Start AR</button>
      <button id="flip" class="secondary" disabled>Flip Camera</button>

      <!-- Sticker button is LEFT of Puff It -->
      <button id="stickers" class="secondary" disabled>Sticker</button>
      <button id="capture" class="secondary" disabled>Puff It!</button>
    </div>

    <div id="stickerPanel" aria-hidden="true">
      <div id="stickerPanelHeader">
        <div style="color:#fff;font:600 16px system-ui">Choose a sticker</div>
        <button id="stickerClose" class="secondary">Close</button>
      </div>

      <div id="stickerGrid"></div>

      <div
        style="
          display: flex;
          gap: 10px;
          margin-top: 12px;
          justify-content: center;
        "
      >
        <button id="stickerRemove" class="secondary">Remove sticker</button>
      </div>
    </div>

    <script>
      const cameraEl = document.getElementById("camera");
      const puffEl = document.getElementById("puff");
      const startBtn = document.getElementById("start");
      const flipBtn = document.getElementById("flip");
      const captureBtn = document.getElementById("capture");

      const stickersBtn = document.getElementById("stickers");
      const stickerEl = document.getElementById("sticker");
      const stickerPanel = document.getElementById("stickerPanel");
      const stickerGrid = document.getElementById("stickerGrid");
      const stickerClose = document.getElementById("stickerClose");
      const stickerRemove = document.getElementById("stickerRemove");

      /* =========================
         CACHE BUSTING
         bump this when you change videos OR stickers
      ========================= */
      const ASSET_VERSION = "21";

      const puffBases = ["puff", "puff2"];
      const chosenBase =
        puffBases[Math.floor(Math.random() * puffBases.length)];

      function isAppleSafari() {
        const ua = navigator.userAgent;
        const isIOS =
          /iPad|iPhone|iPod/.test(ua) ||
          (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const isSafari =
          /Safari/.test(ua) && !/Chrome|CriOS|Edg|OPR|Firefox/.test(ua);
        return isIOS || isSafari;
      }

      function setPuffSource(base) {
        const v = `v=${encodeURIComponent(ASSET_VERSION)}`;

        if (isAppleSafari()) {
          puffEl.innerHTML = `
            <source src="${base}.mov?${v}" type='video/quicktime; codecs="hvc1"'>
            <source src="${base}.mp4?${v}" type='video/mp4; codecs="hvc1"'>
          `;
        } else {
          puffEl.innerHTML = `
            <source src="${base}.webm?${v}" type='video/webm; codecs="vp09.00.10.08"'>
            <source src="${base}.webm?${v}" type="video/webm">
          `;
        }

        puffEl.load();
      }

      puffEl.setAttribute("playsinline", "");
      puffEl.setAttribute("webkit-playsinline", "");
      puffEl.muted = true;
      puffEl.crossOrigin = "anonymous";
      setPuffSource(chosenBase);

      /* =========================
         CAMERA
      ========================= */
      let currentFacingMode = "environment";
      let stream;

      function waitLoadedMetadata(videoEl, timeoutMs = 6000) {
        return new Promise((resolve, reject) => {
          if (videoEl.readyState >= 1 && videoEl.videoWidth > 0) return resolve();
          const t = setTimeout(() => {
            cleanup();
            reject(new Error("metadata timeout"));
          }, timeoutMs);
          const onMeta = () => {
            cleanup();
            resolve();
          };
          const cleanup = () => {
            clearTimeout(t);
            videoEl.removeEventListener("loadedmetadata", onMeta);
          };
          videoEl.addEventListener("loadedmetadata", onMeta, { once: true });
        });
      }

      async function startCamera() {
        captureBtn.disabled = true;
        stickersBtn.disabled = true;

        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }

        stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: currentFacingMode },
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        });

        cameraEl.srcObject = stream;

        await waitLoadedMetadata(cameraEl).catch(() => {});
        await cameraEl.play().catch(() => {});

        await waitLoadedMetadata(puffEl).catch(() => {});
        await puffEl.play().catch(() => {});

        flipBtn.disabled = false;
        captureBtn.disabled = false;
        stickersBtn.disabled = false;

        startBtn.textContent = "AR Running";
        startBtn.disabled = true;
      }

      startBtn.addEventListener("click", async () => {
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
          alert("Could not access camera. Please allow permission and use HTTPS.");
        }
      });

      flipBtn.addEventListener("click", async () => {
        currentFacingMode =
          currentFacingMode === "environment" ? "user" : "environment";
        startBtn.disabled = false;
        startBtn.textContent = "Restart AR";
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
        }
      });

      /* =========================
         gesture helpers
      ========================= */
      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }
      function getDistance(t0, t1) {
        return Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
      }
      function getAngle(t0, t1) {
        return (
          (Math.atan2(t1.clientY - t0.clientY, t1.clientX - t0.clientX) * 180) /
          Math.PI
        );
      }

      /* =========================
         PUFF drag/pinch/rotate/inertia
      ========================= */
      let puffX = 50,
        puffY = 72,
        puffScale = 1.55,
        puffRotation = 0;

      function applyPuffTransform() {
        puffEl.style.left = puffX + "%";
        puffEl.style.top = puffY + "%";
        puffEl.style.transform = `translate(-50%, -50%) scale(${puffScale}) rotate(${puffRotation}deg)`;
      }
      applyPuffTransform();

      let dragStart = null,
        gestureStart = null;
      let angularVelocity = 0,
        lastAngle = null,
        lastTime = null,
        inertiaRAF = null;

      function stopInertia() {
        if (inertiaRAF) cancelAnimationFrame(inertiaRAF);
        inertiaRAF = null;
      }
      function startInertia() {
        stopInertia();
        let prev = performance.now();
        function tick(now) {
          const dt = (now - prev) / 1000;
          prev = now;
          puffRotation += angularVelocity * dt;
          applyPuffTransform();
          angularVelocity *= 0.92;
          if (Math.abs(angularVelocity) < 5) return;
          inertiaRAF = requestAnimationFrame(tick);
        }
        inertiaRAF = requestAnimationFrame(tick);
      }

      puffEl.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          stopInertia();

          if (e.touches.length === 1) {
            const t = e.touches[0];
            dragStart = {
              x: t.clientX,
              y: t.clientY,
              puffX,
              puffY,
              w: innerWidth,
              h: innerHeight,
            };
            gestureStart = null;
          }

          if (e.touches.length === 2) {
            const angle = getAngle(e.touches[0], e.touches[1]);
            gestureStart = {
              distance: getDistance(e.touches[0], e.touches[1]),
              angle,
              scale: puffScale,
              rotation: puffRotation,
            };
            lastAngle = angle;
            lastTime = performance.now();
            dragStart = null;
          }
        },
        { passive: false }
      );

      puffEl.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();

          if (e.touches.length === 1 && dragStart) {
            const t = e.touches[0];
            const dx = ((t.clientX - dragStart.x) / dragStart.w) * 100;
            const dy = ((t.clientY - dragStart.y) / dragStart.h) * 100;
            puffX = clamp(dragStart.puffX + dx, 0, 100);
            puffY = clamp(dragStart.puffY + dy, 0, 100);
            applyPuffTransform();
          }

          if (e.touches.length === 2 && gestureStart) {
            const t0 = e.touches[0],
              t1 = e.touches[1];
            const newDistance = getDistance(t0, t1);
            const newAngle = getAngle(t0, t1);

            puffScale = clamp(
              gestureStart.scale * (newDistance / gestureStart.distance),
              0.9,
              4
            );
            puffRotation =
              gestureStart.rotation + (newAngle - gestureStart.angle);

            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            if (dt > 0) angularVelocity = (newAngle - lastAngle) / dt;
            lastAngle = newAngle;
            lastTime = now;

            applyPuffTransform();
          }
        },
        { passive: false }
      );

      puffEl.addEventListener("touchend", () => {
        if (Math.abs(angularVelocity) > 30) startInertia();
        dragStart = null;
        gestureStart = null;
      });

      /* =========================
         STICKERS (PNG only)
      ========================= */
      let stickersLoaded = false;

      function openStickerPanel() {
        stickerPanel.classList.add("open");
        stickerPanel.setAttribute("aria-hidden", "false");
        if (!stickersLoaded) loadStickers();
      }

      function closeStickerPanel() {
        stickerPanel.classList.remove("open");
        stickerPanel.setAttribute("aria-hidden", "true");
      }

      stickersBtn.addEventListener("click", () => {
        if (stickersBtn.disabled) return;
        openStickerPanel();
      });

      stickerClose.addEventListener("click", closeStickerPanel);

      stickerRemove.addEventListener("click", () => {
        stickerEl.style.display = "none";
        stickerEl.src = "";
        closeStickerPanel();
      });

      async function loadStickers() {
        try {
          const res = await fetch(
            `/stickers.json?v=${encodeURIComponent(ASSET_VERSION)}`
          );
          const list = await res.json();
          stickersLoaded = true;

          stickerGrid.innerHTML = "";
          list.forEach((item) => {
            const cell = document.createElement("button");
            cell.className = "stickerItem";
            cell.type = "button";
            cell.style.border = "0";
            cell.style.cursor = "pointer";

            const img = document.createElement("img");
            img.loading = "lazy";
            img.alt = item.name || item.id || "sticker";

            // handles spaces in filenames
            const encodedSrc = encodeURI(item.src);
            img.src = `${encodedSrc}?v=${encodeURIComponent(ASSET_VERSION)}`;
            img.crossOrigin = "anonymous";

            cell.appendChild(img);

            cell.addEventListener("click", () => {
              stickerEl.crossOrigin = "anonymous";
              stickerEl.src = img.src;
              stickerEl.style.display = "block";

              stickerX = 50;
              stickerY = 40;
              stickerScale = 1.0;
              stickerRotation = 0;
              applyStickerTransform();

              closeStickerPanel();
            });

            stickerGrid.appendChild(cell);
          });
        } catch (e) {
          console.error(e);
          stickerGrid.innerHTML =
            `<div style="color:#fff;font:500 14px system-ui;opacity:.9">
              Could not load stickers.json. Check that /stickers.json exists at repo root.
            </div>`;
        }
      }

      /* sticker gestures (same idea as puff) */
      let stickerX = 50,
        stickerY = 40,
        stickerScale = 1.0,
        stickerRotation = 0;

      function applyStickerTransform() {
        stickerEl.style.left = stickerX + "%";
        stickerEl.style.top = stickerY + "%";
        stickerEl.style.transform = `translate(-50%, -50%) scale(${stickerScale}) rotate(${stickerRotation}deg)`;
      }
      applyStickerTransform();

      let stickerDragStart = null,
        stickerGestureStart = null;

      let stickerAngularVelocity = 0,
        stickerLastAngle = null,
        stickerLastTime = null,
        stickerInertiaRAF = null;

      function stopStickerInertia() {
        if (stickerInertiaRAF) cancelAnimationFrame(stickerInertiaRAF);
        stickerInertiaRAF = null;
      }

      function startStickerInertia() {
        stopStickerInertia();
        let prev = performance.now();
        function tick(now) {
          const dt = (now - prev) / 1000;
          prev = now;
          stickerRotation += stickerAngularVelocity * dt;
          applyStickerTransform();
          stickerAngularVelocity *= 0.92;
          if (Math.abs(stickerAngularVelocity) < 5) return;
          stickerInertiaRAF = requestAnimationFrame(tick);
        }
        stickerInertiaRAF = requestAnimationFrame(tick);
      }

      stickerEl.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          stopStickerInertia();

          if (e.touches.length === 1) {
            const t = e.touches[0];
            stickerDragStart = {
              x: t.clientX,
              y: t.clientY,
              stickerX,
              stickerY,
              w: innerWidth,
              h: innerHeight,
            };
            stickerGestureStart = null;
          }

          if (e.touches.length === 2) {
            const angle = getAngle(e.touches[0], e.touches[1]);
            stickerGestureStart = {
              distance: getDistance(e.touches[0], e.touches[1]),
              angle,
              scale: stickerScale,
              rotation: stickerRotation,
            };
            stickerLastAngle = angle;
            stickerLastTime = performance.now();
            stickerDragStart = null;
          }
        },
        { passive: false }
      );

      stickerEl.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();

          if (e.touches.length === 1 && stickerDragStart) {
            const t = e.touches[0];
            const dx = ((t.clientX - stickerDragStart.x) / stickerDragStart.w) * 100;
            const dy = ((t.clientY - stickerDragStart.y) / stickerDragStart.h) * 100;
            stickerX = clamp(stickerDragStart.stickerX + dx, 0, 100);
            stickerY = clamp(stickerDragStart.stickerY + dy, 0, 100);
            applyStickerTransform();
          }

          if (e.touches.length === 2 && stickerGestureStart) {
            const t0 = e.touches[0],
              t1 = e.touches[1];
            const newDistance = getDistance(t0, t1);
            const newAngle = getAngle(t0, t1);

            stickerScale = clamp(
              stickerGestureStart.scale * (newDistance / stickerGestureStart.distance),
              0.2,
              6
            );
            stickerRotation =
              stickerGestureStart.rotation + (newAngle - stickerGestureStart.angle);

            const now = performance.now();
            const dt = (now - stickerLastTime) / 1000;
            if (dt > 0) stickerAngularVelocity = (newAngle - stickerLastAngle) / dt;
            stickerLastAngle = newAngle;
            stickerLastTime = now;

            applyStickerTransform();
          }
        },
        { passive: false }
      );

      stickerEl.addEventListener("touchend", () => {
        if (Math.abs(stickerAngularVelocity) > 30) startStickerInertia();
        stickerDragStart = null;
        stickerGestureStart = null;
      });

      /* =========================
         CAPTURE
      ========================= */
      function nextCaptureFilename() {
        const key = "puff_capture_counter";
        const current = parseInt(localStorage.getItem(key) || "0", 10) + 1;
        localStorage.setItem(key, String(current));
        const num = String(current).padStart(3, "0");
        return `Puff Dragon_HPNY2026_${num}.png`;
      }

      function getCoverTransform(srcW, srcH, dstW, dstH) {
        const scale = Math.max(dstW / srcW, dstH / srcH);
        const drawW = srcW * scale;
        const drawH = srcH * scale;
        const offsetX = (dstW - drawW) / 2;
        const offsetY = (dstH - drawH) / 2;
        return { scale, drawW, drawH, offsetX, offsetY };
      }

      captureBtn.addEventListener("click", () => {
        const win = window.open("about:blank", "_blank");
        if (!win) {
          alert("Popup blocked. Please allow popups for this site.");
          return;
        }

        try {
          if (!stream || !cameraEl.videoWidth || !cameraEl.videoHeight) {
            win.close();
            alert("Start AR first.");
            return;
          }

          const out = document.createElement("canvas");
          out.width = cameraEl.videoWidth;
          out.height = cameraEl.videoHeight;
          const ctx = out.getContext("2d");

          ctx.drawImage(cameraEl, 0, 0, out.width, out.height);

          const camRect = cameraEl.getBoundingClientRect();
          const cover = getCoverTransform(
            out.width,
            out.height,
            camRect.width,
            camRect.height
          );

          // draw puff
          const puffRect = puffEl.getBoundingClientRect();
          const puffCenterX_screen =
            puffRect.left + puffRect.width / 2 - camRect.left;
          const puffCenterY_screen =
            puffRect.top + puffRect.height / 2 - camRect.top;

          const puffCenterX_cam =
            (puffCenterX_screen - cover.offsetX) / cover.scale;
          const puffCenterY_cam =
            (puffCenterY_screen - cover.offsetY) / cover.scale;

          const puffW_cam = puffRect.width / cover.scale;
          const puffH_cam = puffRect.height / cover.scale;

          const puffAR =
            puffEl.videoWidth && puffEl.videoHeight
              ? puffEl.videoWidth / puffEl.videoHeight
              : puffRect.width / puffRect.height;

          let drawW = puffW_cam;
          let drawH = drawW / puffAR;
          if (drawH > puffH_cam) {
            drawH = puffH_cam;
            drawW = drawH * puffAR;
          }

          ctx.save();
          ctx.translate(puffCenterX_cam, puffCenterY_cam);
          ctx.rotate((puffRotation * Math.PI) / 180);
          ctx.drawImage(puffEl, -drawW / 2, -drawH / 2, drawW, drawH);
          ctx.restore();

          // draw sticker (optional)
          if (stickerEl.style.display !== "none" && stickerEl.src) {
            const stickerRect = stickerEl.getBoundingClientRect();

            const stickerCenterX_screen =
              stickerRect.left + stickerRect.width / 2 - camRect.left;
            const stickerCenterY_screen =
              stickerRect.top + stickerRect.height / 2 - camRect.top;

            const stickerCenterX_cam =
              (stickerCenterX_screen - cover.offsetX) / cover.scale;
            const stickerCenterY_cam =
              (stickerCenterY_screen - cover.offsetY) / cover.scale;

            const stickerW_cam = stickerRect.width / cover.scale;
            const stickerH_cam = stickerRect.height / cover.scale;

            const stickerAR =
              stickerEl.naturalWidth && stickerEl.naturalHeight
                ? stickerEl.naturalWidth / stickerEl.naturalHeight
                : stickerRect.width / stickerRect.height;

            let sDrawW = stickerW_cam;
            let sDrawH = sDrawW / stickerAR;
            if (sDrawH > stickerH_cam) {
              sDrawH = stickerH_cam;
              sDrawW = sDrawH * stickerAR;
            }

            ctx.save();
            ctx.translate(stickerCenterX_cam, stickerCenterY_cam);
            ctx.rotate((stickerRotation * Math.PI) / 180);
            ctx.drawImage(stickerEl, -sDrawW / 2, -sDrawH / 2, sDrawW, sDrawH);
            ctx.restore();
          }

          out.toBlob((blob) => {
            if (!blob) {
              win.document.write("<h3>Capture failed</h3>");
              win.document.close();
              return;
            }

            const filename = nextCaptureFilename();
            const url = URL.createObjectURL(blob);

            win.document.write(`
              <title>${filename}</title>
              <div style="margin:0;background:#000;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:18px;">
                <img src="${url}" style="max-width:100%;height:auto;display:block;" />
                <a
                  href="${url}"
                  download="${filename}"
                  style="display:inline-block;padding:12px 16px;border-radius:12px;background:#e11d2e;color:#fff;font:600 16px system-ui;text-decoration:none"
                >
                  Download (${filename})
                </a>
              </div>
            `);

            win.document.close();
            setTimeout(() => URL.revokeObjectURL(url), 15000);
          }, "image/png");
        } catch (err) {
          console.error(err);
          win.document.write(
            `<h3>Capture Error</h3><pre style="white-space:pre-wrap">${String(err)}</pre>`
          );
          win.document.close();
          alert("Capture failed. Try again.");
        }
      });
    </script>
  </body>
</html>
