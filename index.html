<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Puff Dragon AR Viewer</title>

    <style>
      @font-face {
        font-family: "BeautifulFreak";
        src: url("BeautifulFreak.otf") format("opentype");
        font-display: swap;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        height: 100%;
        touch-action: none;
      }

      .hidden {
        display: none !important;
      }

      /* =========================
         INTRO OVERLAY
      ========================= */
      #introOverlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      #introVideo {
        width: 100vw;
        height: auto;
        max-height: 100vh;
        object-fit: contain;
        background: #fff;
        display: block;
      }

      #introClosePuff {
        position: absolute;
        top: calc(14px + env(safe-area-inset-top));
        left: 50%;
        transform: translateX(-50%);
        width: min(22vw, 96px);
        height: auto;
        z-index: 3;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      #introClosePuff:active {
        transform: translateX(-50%) scale(0.96);
      }

      #exploreBtn {
        position: absolute;
        left: 50%;
        top: 55%;
        transform: translate(-50%, -50%);
        border: 0;
        border-radius: 16px;
        padding: 18px 34px;
        font-size: clamp(20px, 4.2vw, 30px);
        font-weight: 900;
        letter-spacing: 0.2px;
        color: #fff;
        background: #fa213f;
        cursor: pointer;
        z-index: 2;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      }

      #exploreBtn:active {
        transform: translate(-50%, -50%) scale(0.98);
      }

      /* =========================
         MAIN APP
      ========================= */
      #camera {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: 1;
        transform-origin: center;
      }

      #camera.mirror {
        transform: scaleX(-1);
      }

      #cameraFx {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
        display: none;
        background: #000;
      }

      #cameraFx.mirror {
        transform: scaleX(-1);
        transform-origin: center;
      }

      /* Puff overlay (ONLY ONE, always the same element) */
      #puff {
        position: fixed;
        left: 50%;
        top: 72%;
        width: min(90vw, 500px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1.55);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        z-index: 2;
        user-select: none;
      }

      #stickerLayer {
        position: fixed;
        inset: 0;
        z-index: 3;
        pointer-events: none;
      }

      .sticker {
        position: fixed;
        left: 50%;
        top: 40%;
        width: min(45vw, 260px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        user-select: none;
      }

      .sticker.selected {
        outline: 2px solid rgba(255, 255, 255, 0.6);
        outline-offset: 6px;
        border-radius: 14px;
      }

      #textLayer {
        position: fixed;
        inset: 0;
        z-index: 4;
        pointer-events: none;
      }

      .textItem {
        position: fixed;
        left: 50%;
        top: 30%;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        transform-origin: center;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        padding: 6px 10px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.18);
        backdrop-filter: blur(6px);
        color: #fff;
        font-family: "BeautifulFreak", system-ui;
        font-size: 44px;
        line-height: 1;
        white-space: pre;
        will-change: transform;
      }

      .textItem.selected {
        outline: 2px solid rgba(255, 255, 255, 0.65);
        outline-offset: 6px;
      }

      /* =========================
         UI
      ========================= */
      #ui {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 7px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.65),
          rgba(0, 0, 0, 0)
        );
        z-index: 10;
      }

      .ui-row {
        display: flex;
        gap: 7px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      button {
        border: 0;
        border-radius: 9px;
        padding: 6px 9px;
        font-size: 11px;
        font-weight: 900;
        letter-spacing: 0.2px;
        color: #fff;
        background: #e11d2e;
        min-width: 74px;
        line-height: 1;
        cursor: pointer;
      }

      #start {
        background: #fa213f;
      }

      button.secondary {
        background: rgba(255, 255, 255, 0.15);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #capture {
        background: #fff100;
        color: #060d3d;
        font-weight: 900;
        min-width: 86px;
      }

      #boothBtn {
        min-width: 96px;
      }

      /* =========================
         PANELS
      ========================= */
      #stickerPanel,
      #filterPanel,
      #boothPanel,
      #textPanel {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        transform: translateY(110%);
        transition: transform 0.22s ease;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        padding: 12px 12px calc(12px + env(safe-area-inset-bottom));
        z-index: 20;
        border-top-left-radius: 18px;
        border-top-right-radius: 18px;
        max-height: min(80vh, 600px);
        display: flex;
        flex-direction: column;
        -webkit-overflow-scrolling: touch;
      }

      #stickerPanel.open,
      #filterPanel.open,
      #boothPanel.open,
      #textPanel.open {
        transform: translateY(0);
      }

      #stickerPanelHeader,
      #filterPanelHeader,
      #boothPanelHeader,
      #textPanelHeader {
        position: sticky;
        top: 0;
        z-index: 2;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        padding-bottom: 8px;
      }

      .panelBody {
        overflow-y: auto;
        flex: 1;
        padding-right: 2px;
      }

      #stickerGrid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 9px;
      }

      .stickerItem {
        background: rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 9px;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1 / 1;
      }

      .stickerItem img {
        max-width: 100%;
        max-height: 100%;
        display: block;
      }

      #filterList {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 9px;
      }

      .filterItem {
        border: 0;
        border-radius: 14px;
        padding: 10px 10px;
        background: rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.95);
        font: 900 12px system-ui;
        text-align: left;
      }

      .filterItem .sub {
        display: block;
        margin-top: 4px;
        opacity: 0.78;
        font: 700 10px system-ui;
        line-height: 1.1;
      }

      .filterItem.active {
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 2px;
      }

      .boothRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        margin-bottom: 10px;
      }

      .pill {
        border: 0;
        border-radius: 999px;
        padding: 9px 12px;
        background: rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.95);
        font: 900 12px system-ui;
        cursor: pointer;
      }

      .pill.active {
        outline: 2px solid rgba(255, 255, 255, 0.75);
        outline-offset: 2px;
      }

      .fieldLabel {
        color: rgba(255, 255, 255, 0.85);
        font: 800 11px system-ui;
        margin: 10px 0 6px;
        text-align: center;
      }

      select,
      input[type="range"],
      input[type="text"] {
        width: 100%;
        border: 0;
        border-radius: 12px;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.95);
        font: 800 12px system-ui;
        outline: none;
      }

      input[type="range"] {
        padding: 10px 8px;
      }

      /* =========================
         CAPTURED PANEL (scroll list + visible cue button)
      ========================= */
      #capturedDock {
        position: fixed;
        top: calc(10px + env(safe-area-inset-top));
        right: calc(10px + env(safe-area-inset-right));
        width: min(44vw, 360px);
        height: min(72vh, 720px);
        z-index: 30;
        display: none; /* shown only when photobooth ON */
        border-radius: 18px;
        background: rgba(0, 0, 0, 0.45);
        backdrop-filter: blur(10px);
        overflow: hidden;
        box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      }

      #capturedDockHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      #capturedDockHeader .title {
        color: rgba(255, 255, 255, 0.92);
        font: 900 14px system-ui;
      }

      #capturedClear {
        border-radius: 999px;
        padding: 7px 11px;
        min-width: unset;
      }

      #capturedList {
        height: calc(100% - 52px - 62px);
        overflow-y: auto;
        padding: 10px;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        -webkit-overflow-scrolling: touch;
      }

      .capThumb {
        position: relative;
        border-radius: 14px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.06);
        aspect-ratio: 4 / 3;
        cursor: pointer;
        user-select: none;
      }

      .capThumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .capBadge {
        position: absolute;
        top: 8px;
        left: 8px;
        width: 26px;
        height: 26px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.55);
        color: rgba(255, 255, 255, 0.92);
        font: 900 12px system-ui;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #cueBar {
        height: 62px;
        padding: 10px 12px;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        display: flex;
        align-items: center;
        gap: 10px;
        background: rgba(0, 0, 0, 0.25);
      }

      #cueBtn {
        flex: 1;
        border-radius: 12px;
        background: #fff100;
        color: #060d3d;
        font: 900 12px system-ui;
        padding: 12px 12px;
        min-width: unset;
      }

      /* =========================
         STRIP BUILDER (NOT full screen)
      ========================= */
      #builderOverlay {
        position: fixed;
        inset: 0;
        z-index: 40;
        display: none;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
      }

      #builderCard {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: min(92vw, 1080px);
        height: min(82vh, 760px);
        background: rgba(15, 15, 15, 0.72);
        border: 1px solid rgba(255, 255, 255, 0.10);
        border-radius: 18px;
        overflow: hidden;
        display: grid;
        grid-template-columns: 1.35fr 0.65fr;
      }

      #builderLeft {
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      #builderTopbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }

      #builderTitle {
        color: rgba(255, 255, 255, 0.92);
        font: 900 14px system-ui;
      }

      #builderActions {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #builderDone,
      #builderClose {
        border-radius: 999px;
        padding: 8px 12px;
        min-width: unset;
      }

      #builderDone {
        background: #fff100;
        color: #060d3d;
      }

      /* Preview area: keeps real strip aspect; no rounded “ugly” outlines */
      #stripPreviewWrap {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 8px;
        overflow: hidden;
      }

      #stripPreview {
        width: min(100%, 720px);
        height: auto;
        max-height: 100%;
        aspect-ratio: 2 / 6; /* default 3-vertical */
        background: transparent;
      }

      /* Right controls */
      #builderRight {
        border-left: 1px solid rgba(255, 255, 255, 0.10);
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      #builderRightHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      #builderRightHeader .t {
        color: rgba(255, 255, 255, 0.92);
        font: 900 14px system-ui;
      }

      #builderHelp {
        color: rgba(255, 255, 255, 0.70);
        font: 700 11px system-ui;
        line-height: 1.35;
      }

      #assignGrid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        overflow-y: auto;
        flex: 1;
        padding-right: 2px;
      }

      .assignThumb {
        border-radius: 14px;
        overflow: hidden;
        aspect-ratio: 4 / 3;
        background: rgba(255, 255, 255, 0.06);
        cursor: pointer;
        position: relative;
      }
      .assignThumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .groupLabel {
        color: rgba(255, 255, 255, 0.78);
        font: 800 11px system-ui;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        margin-top: 6px;
      }

      /* =========================
         Desktop hint
      ========================= */
      #desktopHint {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 11;
        padding: 7px 9px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.45);
        color: rgba(255, 255, 255, 0.85);
        font: 800 11px system-ui;
        display: none;
        user-select: none;
      }

      @media (hover: hover) and (pointer: fine) {
        #desktopHint {
          display: block;
        }
      }
    </style>
  </head>

  <body>
    <!-- =========================
         INTRO
    ========================= -->
    <div id="introOverlay">
      <video
        id="introVideo"
        autoplay
        playsinline
        webkit-playsinline
        muted
        preload="auto"
      >
        <source
          id="introMp4"
          src=""
          type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'
        />
        <source
          id="introWebm"
          src=""
          type='video/webm; codecs="vp09.00.10.08"'
        />
      </video>

      <img
        id="introClosePuff"
        src="puff-close.png"
        alt="Close intro"
        role="button"
      />

      <button id="exploreBtn" class="hidden" type="button">Explore</button>
    </div>

    <!-- =========================
         MAIN APP
    ========================= -->
    <div id="app" class="hidden">
      <div id="desktopHint">
        Desktop: drag=move • wheel=zoom • Alt/Shift/right-drag=rotate • click=select
      </div>

      <video id="camera" autoplay playsinline muted></video>
      <canvas id="cameraFx"></canvas>

      <video
        id="puff"
        autoplay
        playsinline
        webkit-playsinline
        muted
        loop
        preload="auto"
        crossorigin="anonymous"
      ></video>

      <div id="stickerLayer"></div>
      <div id="textLayer"></div>

      <!-- Captured dock (photobooth ON only) -->
      <div id="capturedDock" aria-hidden="true">
        <div id="capturedDockHeader">
          <div class="title">Captured</div>
          <button id="capturedClear" class="secondary" type="button">
            Clear
          </button>
        </div>
        <div id="capturedList"></div>
        <div id="cueBar">
          <button id="cueBtn" type="button">Visuals, cue!</button>
        </div>
      </div>

      <div id="ui">
        <div class="ui-row">
          <button id="start">Start AR</button>
          <button id="flip" class="secondary" disabled>Flip Camera</button>
          <button id="mirror" class="secondary" disabled>Mirror: Auto</button>
        </div>

        <div class="ui-row">
          <button id="filterBtn" class="secondary" disabled>Filter</button>
          <button id="boothBtn" class="secondary" disabled>Photobooth: Off</button>
          <button id="stickers" class="secondary" disabled>Sticker</button>
          <button id="textBtn" class="secondary" disabled>Text</button>
          <button id="capture" disabled>Puff It</button>
        </div>
      </div>

      <!-- Sticker panel -->
      <div id="stickerPanel" aria-hidden="true">
        <div id="stickerPanelHeader">
          <div style="color:#fff;font:900 14px system-ui">Choose a sticker</div>
          <button id="stickerClose" class="secondary">Close</button>
        </div>

        <div class="panelBody">
          <div id="stickerGrid"></div>

          <div class="panelFooter" style="margin-top:12px;">
            <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
              <button id="stickerRemove" class="secondary" disabled>
                Remove selected
              </button>
              <button id="stickerClear" class="secondary" disabled>Clear all</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Text panel -->
      <div id="textPanel" aria-hidden="true">
        <div id="textPanelHeader">
          <div style="color:#fff;font:900 14px system-ui">Texts (Beautiful Freak)</div>
          <button id="textClose" class="secondary">Close</button>
        </div>

        <div class="panelBody">
          <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
            <button id="addText" class="secondary" type="button">Add Text</button>
            <button id="removeText" class="secondary" type="button" disabled>
              Remove selected
            </button>
            <button id="clearText" class="secondary" type="button" disabled>
              Clear all
            </button>
          </div>

          <div style="margin-top:10px;">
            <div class="fieldLabel">Selected text content</div>
            <input id="textContent" type="text" placeholder="Type your text…" />
          </div>

          <div style="margin-top:10px;">
            <div class="fieldLabel">Text color</div>
            <select id="textColor"></select>
          </div>

          <div style="margin-top:10px;">
            <div class="fieldLabel">Text size</div>
            <input id="textSize" type="range" min="18" max="120" value="44" />
          </div>

          <div style="margin-top:12px;">
            <div
              style="color:rgba(255,255,255,0.82);font:700 12px system-ui;line-height:1.35;text-align:center;"
            >
              Tip: Drag/Pinch/Rotate texts on screen.
            </div>
          </div>
        </div>
      </div>

      <!-- Filter panel -->
      <div id="filterPanel" aria-hidden="true">
        <div id="filterPanelHeader">
          <div style="color:#fff;font:900 14px system-ui">Choose a filter</div>
          <button id="filterClose" class="secondary">Close</button>
        </div>

        <div class="panelBody">
          <div id="filterList"></div>
        </div>
      </div>

      <!-- Booth panel (only toggles ON/OFF + explain flow) -->
      <div id="boothPanel" aria-hidden="true">
        <div id="boothPanelHeader">
          <div style="color:#fff;font:900 14px system-ui">Photobooth</div>
          <button id="boothClose" class="secondary">Close</button>
        </div>

        <div class="panelBody">
          <div
            style="color:rgba(255,255,255,0.86);font:800 12px system-ui;line-height:1.45;text-align:center;"
          >
            Photobooth ON = capture many images → press <b>Visuals, cue!</b> to build a strip (choose layout/color and export).
          </div>
        </div>
      </div>

      <!-- Strip Builder -->
      <div id="builderOverlay" aria-hidden="true">
        <div id="builderCard" role="dialog" aria-modal="true">
          <div id="builderLeft">
            <div id="builderTopbar">
              <div id="builderTitle">Strip Builder</div>
              <div id="builderActions">
                <button id="builderDone" type="button">Export strip PNG</button>
                <button id="builderClose" class="secondary" type="button">Close</button>
              </div>
            </div>

            <div id="stripPreviewWrap">
              <canvas id="stripPreview"></canvas>
            </div>
          </div>

          <div id="builderRight">
            <div id="builderRightHeader">
              <div class="t">Frames</div>
              <button id="builderClose2" class="secondary" type="button">Close</button>
            </div>

            <div class="groupLabel">Layout</div>
            <div class="boothRow" id="layoutRow"></div>

            <div class="groupLabel">Frame color</div>
            <div class="boothRow" id="colorRow"></div>

            <div id="builderHelp">
              Tap a panel in the preview to select it, then tap an image thumbnail to assign.
              (Builder does not add Puff/stickers/text again — it uses exactly what was captured.)
            </div>

            <div class="groupLabel">Captured</div>
            <div id="assignGrid"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      /* =========================
         CACHE BUSTING
      ========================= */
      const ASSET_VERSION = "final-2026-02-16-1";

      /* =========================
         COLORS / LOGOS
      ========================= */
      const BOOTH_COLORS = [
        { id: "imperialRed", name: "Imperial Red", hex: "#fa213f" },
        { id: "darkBlue", name: "Dark Blue", hex: "#060d3d" },
        { id: "brightGrey", name: "Bright Grey", hex: "#e8eef1" },
        { id: "white", name: "White", hex: "#ffffff" },
      ];

      const TEXT_COLORS = [
        { name: "Imperial Red", hex: "#fa213f" },
        { name: "Dark Blue", hex: "#060d3d" },
        { name: "Bright Grey", hex: "#e8eef1" },
        { name: "Pure White", hex: "#ffffff" },
        { name: "Fluorescent Yellow", hex: "#fff100" },
        { name: "Safety Orange", hex: "#ff7800" },
        { name: "Azure Blue", hex: "#01b7ff" },
        { name: "Vivid Red", hex: "#ff1212" },
      ];

      function logoForBg(bgHex) {
        const c = bgHex.toLowerCase();
        if (c === "#fa213f") return "puff-logo-2.png";
        if (c === "#060d3d") return "puff-logo-3.png";
        return "puff-logo-1.png";
      }

      /* =========================
         FONT LOADING
      ========================= */
      let BEAUTIFUL_FREAK_READY = false;
      (async () => {
        try {
          const ff = new FontFace("BeautifulFreak", "url(BeautifulFreak.otf)");
          await ff.load();
          document.fonts.add(ff);
          await document.fonts.ready;
          BEAUTIFUL_FREAK_READY = true;
        } catch (_) {
          BEAUTIFUL_FREAK_READY = false;
        }
      })();

      /* =========================
         ELEMENTS
      ========================= */
      const cameraEl = document.getElementById("camera");
      const cameraFx = document.getElementById("cameraFx");
      const puffEl = document.getElementById("puff");
      const stickerLayer = document.getElementById("stickerLayer");
      const textLayer = document.getElementById("textLayer");

      const startBtn = document.getElementById("start");
      const flipBtn = document.getElementById("flip");
      const mirrorBtn = document.getElementById("mirror");
      const filterBtn = document.getElementById("filterBtn");
      const boothBtn = document.getElementById("boothBtn");
      const stickersBtn = document.getElementById("stickers");
      const textBtn = document.getElementById("textBtn");
      const captureBtn = document.getElementById("capture");

      const filterPanel = document.getElementById("filterPanel");
      const filterClose = document.getElementById("filterClose");
      const filterListEl = document.getElementById("filterList");

      const boothPanel = document.getElementById("boothPanel");
      const boothClose = document.getElementById("boothClose");

      const stickerPanel = document.getElementById("stickerPanel");
      const stickerGrid = document.getElementById("stickerGrid");
      const stickerClose = document.getElementById("stickerClose");
      const stickerRemove = document.getElementById("stickerRemove");
      const stickerClear = document.getElementById("stickerClear");

      const textPanel = document.getElementById("textPanel");
      const textClose = document.getElementById("textClose");
      const addTextBtn = document.getElementById("addText");
      const removeTextBtn = document.getElementById("removeText");
      const clearTextBtn = document.getElementById("clearText");
      const textContentInput = document.getElementById("textContent");
      const textColorSelect = document.getElementById("textColor");
      const textSizeRange = document.getElementById("textSize");

      const capturedDock = document.getElementById("capturedDock");
      const capturedList = document.getElementById("capturedList");
      const capturedClearBtn = document.getElementById("capturedClear");
      const cueBtn = document.getElementById("cueBtn");

      const builderOverlay = document.getElementById("builderOverlay");
      const builderClose = document.getElementById("builderClose");
      const builderClose2 = document.getElementById("builderClose2");
      const builderDone = document.getElementById("builderDone");
      const stripPreview = document.getElementById("stripPreview");
      const layoutRow = document.getElementById("layoutRow");
      const colorRow = document.getElementById("colorRow");
      const assignGrid = document.getElementById("assignGrid");

      /* =========================
         INTRO LOGIC
      ========================= */
      const introOverlay = document.getElementById("introOverlay");
      const introVideo = document.getElementById("introVideo");
      const exploreBtn = document.getElementById("exploreBtn");
      const closePuff = document.getElementById("introClosePuff");
      const app = document.getElementById("app");
      const introMp4 = document.getElementById("introMp4");
      const introWebm = document.getElementById("introWebm");

      introMp4.src = `intro.mp4?v=${encodeURIComponent(ASSET_VERSION)}`;
      introWebm.src = `intro.webm?v=${encodeURIComponent(ASSET_VERSION)}`;
      introVideo.load();

      let introLoopStarted = false;
      introVideo.addEventListener("ended", async () => {
        if (!introLoopStarted) {
          introLoopStarted = true;
          exploreBtn.classList.remove("hidden");
          introVideo.loop = true;
          try {
            introVideo.currentTime = 0;
            await introVideo.play();
          } catch (_) {}
        }
      });

      const tryPlayIntro = async () => {
        try {
          await introVideo.play();
        } catch (_) {}
        window.removeEventListener("pointerdown", tryPlayIntro, true);
      };
      window.addEventListener("pointerdown", tryPlayIntro, true);

      async function closeIntro() {
        introOverlay.classList.add("hidden");
        app.classList.remove("hidden");
        try {
          await puffEl.play();
        } catch (_) {}
      }
      closePuff.addEventListener("click", closeIntro);
      exploreBtn.addEventListener("click", closeIntro);

      /* =========================
         FILTER PIPELINE (same as final)
      ========================= */
      const clamp01 = (v) => Math.max(0, Math.min(1, v));
      const clamp255 = (v) => Math.max(0, Math.min(255, v));

      function srgbToLin(c) {
        c /= 255;
        return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      }
      function linToSrgb(c) {
        c = clamp01(c);
        const v = c <= 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
        return clamp255(v * 255);
      }
      function lumaLin(rLin, gLin, bLin) {
        return 0.2126 * rLin + 0.7152 * gLin + 0.0722 * bLin;
      }
      function applySaturationLin(r, g, b, sat) {
        const y = lumaLin(r, g, b);
        return [y + (r - y) * sat, y + (g - y) * sat, y + (b - y) * sat];
      }
      function adjustShadowsHighlightsLin(y, shadows, highlights) {
        let out = y;
        if (shadows !== 0) {
          const t = clamp01((0.45 - y) / 0.45);
          out += shadows * t * 0.35;
        }
        if (highlights !== 0) {
          const t = clamp01((y - 0.55) / 0.45);
          out += highlights * t * 0.35;
        }
        return clamp01(out);
      }
      function applyBrillianceLin(y, brilliance) {
        if (brilliance === 0) return y;
        const k = brilliance * 0.55;
        const s = y * y * (3 - 2 * y);
        return clamp01(y + (s - y) * k);
      }
      function applyFadeLin(y, fade) {
        if (!fade) return y;
        const lift = fade * 0.10;
        return clamp01(y * (1 - fade * 0.15) + lift);
      }
      function applyWarmthLin(r, g, b, warmth) {
        if (!warmth) return [r, g, b];
        const w = warmth * 0.10;
        return [r * (1 + w), g, b * (1 - w)];
      }

      function unsharpMask(imageData, amount = 0.35, radius = 1) {
        const { width: w, height: h, data } = imageData;
        const src = new Uint8ClampedArray(data);
        const idx = (x, y) => (y * w + x) * 4;

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let r = 0, g = 0, b = 0, n = 0;
            for (let dy = -radius; dy <= radius; dy++) {
              const yy = y + dy;
              if (yy < 0 || yy >= h) continue;
              for (let dx = -radius; dx <= radius; dx++) {
                const xx = x + dx;
                if (xx < 0 || xx >= w) continue;
                const p = idx(xx, yy);
                r += src[p];
                g += src[p + 1];
                b += src[p + 2];
                n++;
              }
            }
            const p = idx(x, y);
            const br = r / n, bg = g / n, bb = b / n;

            data[p] = clamp255(src[p] + amount * (src[p] - br));
            data[p + 1] = clamp255(src[p + 1] + amount * (src[p + 1] - bg));
            data[p + 2] = clamp255(src[p + 2] + amount * (src[p + 2] - bb));
          }
        }
        return imageData;
      }

      function noiseReduceLight(imageData, strength = 0.15) {
        if (!strength) return imageData;
        const { width: w, height: h, data } = imageData;
        const src = new Uint8ClampedArray(data);
        const idx = (x, y) => (y * w + x) * 4;

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let r = 0, g = 0, b = 0, n = 0;
            for (let dy = -1; dy <= 1; dy++) {
              const yy = y + dy;
              if (yy < 0 || yy >= h) continue;
              for (let dx = -1; dx <= 1; dx++) {
                const xx = x + dx;
                if (xx < 0 || xx >= w) continue;
                const p = idx(xx, yy);
                r += src[p];
                g += src[p + 1];
                b += src[p + 2];
                n++;
              }
            }
            const p = idx(x, y);
            const br = r / n, bg = g / n, bb = b / n;

            data[p] = clamp255(src[p] * (1 - strength) + br * strength);
            data[p + 1] = clamp255(src[p + 1] * (1 - strength) + bg * strength);
            data[p + 2] = clamp255(src[p + 2] * (1 - strength) + bb * strength);
          }
        }
        return imageData;
      }

      function recipe(params) {
        return {
          exposure: (params.exposure || 0) / 100,
          brilliance: (params.brilliance || 0) / 100,
          highlights: (params.highlights || 0) / 100,
          shadows: (params.shadows || 0) / 100,
          brightness: (params.brightness || 0) / 100,
          contrast: (params.contrast || 0) / 100,
          saturation: (params.saturation || 0) / 100,
          warmth: (params.warmth || 0) / 100,
          fade: (params.fade || 0) / 100,
          sharpness: (params.sharpness || 0) / 100,
          noiseReduce: (params.noiseReduce || 0) / 100,
        };
      }

      const FILTERS = [
        { id: "none", name: "None", recipe: recipe({}) },
        {
          id: "35mm04",
          name: "35mm 04",
          recipe: recipe({
            exposure: -5, brilliance: -10, highlights: -30, shadows: +18,
            brightness: -10, contrast: -8, saturation: -6, warmth: -6,
            fade: +12, sharpness: -5, noiseReduce: +8,
          }),
        },
        {
          id: "vi4",
          name: "VI4",
          recipe: recipe({
            exposure: +10, brilliance: +18, highlights: -35, shadows: +14,
            brightness: +6, contrast: -6, saturation: +10, warmth: +10,
            fade: +10, sharpness: +6, noiseReduce: +10,
          }),
        },
        {
          id: "cm1",
          name: "CM1",
          recipe: recipe({
            exposure: +8, brilliance: +22, highlights: -25, shadows: +12,
            brightness: +4, contrast: -4, saturation: +12, warmth: +6,
            fade: +6, sharpness: +10, noiseReduce: +8,
          }),
        },
        {
          id: "sapa",
          name: "Sapa",
          recipe: recipe({
            exposure: +12, brilliance: +10, highlights: -22, shadows: +18,
            brightness: +8, contrast: -10, saturation: +6, warmth: -10,
            fade: +16, sharpness: +6, noiseReduce: +10,
          }),
        },
        {
          id: "salt",
          name: "Salt",
          recipe: recipe({
            exposure: +18, brilliance: +18, highlights: -40, shadows: +10,
            brightness: +10, contrast: -8, saturation: +14, warmth: +14,
            fade: +8, sharpness: +8, noiseReduce: +8,
          }),
        },
        {
          id: "in2",
          name: "IN2",
          recipe: recipe({
            exposure: +10, brilliance: +8, highlights: -30, shadows: +16,
            brightness: +4, contrast: -12, saturation: -4, warmth: -8,
            fade: +18, sharpness: +6, noiseReduce: +12,
          }),
        },
        {
          id: "fl2",
          name: "FL2",
          recipe: recipe({
            exposure: +14, brilliance: +14, highlights: -28, shadows: +10,
            brightness: +8, contrast: -6, saturation: +10, warmth: +8,
            fade: +10, sharpness: +8, noiseReduce: +10,
          }),
        },
        {
          id: "bwfilm",
          name: "B&W Film",
          recipe: recipe({
            exposure: +6, brilliance: +10, highlights: -20, shadows: +10,
            brightness: +4, contrast: +10, saturation: -100, fade: +8,
            sharpness: +10, noiseReduce: +10,
          }),
        },
      ];

      let currentFilterId = "none";
      let currentRecipe = FILTERS[0].recipe;

      function applyRecipeToImageData(imageData, r) {
        const d = imageData.data;
        const sat = 1 + r.saturation * 0.9;
        const exposureGain = Math.pow(2, r.exposure);
        const brightnessGain = 1 + r.brightness * 0.35;
        const contrastGain = 1 + r.contrast * 0.6;

        for (let i = 0; i < d.length; i += 4) {
          let rLin = srgbToLin(d[i]);
          let gLin = srgbToLin(d[i + 1]);
          let bLin = srgbToLin(d[i + 2]);

          [rLin, gLin, bLin] = applyWarmthLin(rLin, gLin, bLin, r.warmth);

          rLin *= exposureGain * brightnessGain;
          gLin *= exposureGain * brightnessGain;
          bLin *= exposureGain * brightnessGain;

          let y = lumaLin(rLin, gLin, bLin);
          y = applyBrillianceLin(y, r.brilliance);
          y = adjustShadowsHighlightsLin(y, r.shadows, r.highlights);

          const y0 = Math.max(1e-6, lumaLin(rLin, gLin, bLin));
          const sc = y / y0;
          rLin *= sc;
          gLin *= sc;
          bLin *= sc;

          [rLin, gLin, bLin] = applySaturationLin(rLin, gLin, bLin, sat);

          const pivot = 0.18;
          rLin = (rLin - pivot) * contrastGain + pivot;
          gLin = (gLin - pivot) * contrastGain + pivot;
          bLin = (bLin - pivot) * contrastGain + pivot;

          const yFade = applyFadeLin(lumaLin(rLin, gLin, bLin), r.fade);
          const yNow = Math.max(1e-6, lumaLin(rLin, gLin, bLin));
          const s2 = yFade / yNow;
          rLin *= s2;
          gLin *= s2;
          bLin *= s2;

          d[i] = linToSrgb(rLin);
          d[i + 1] = linToSrgb(gLin);
          d[i + 2] = linToSrgb(bLin);
        }

        if (r.noiseReduce > 0.01) noiseReduceLight(imageData, clamp01(r.noiseReduce * 0.35));
        if (r.sharpness > 0.01) unsharpMask(imageData, clamp01(r.sharpness * 0.55), 1);

        return imageData;
      }

      /* =========================
         Filter preview canvas
      ========================= */
      let fxRunning = false;
      let fxRaf = null;
      let fxLast = 0;

      function stopFx() {
        fxRunning = false;
        if (fxRaf) cancelAnimationFrame(fxRaf);
        fxRaf = null;
        cameraFx.style.display = "none";
        cameraEl.style.visibility = "visible";
      }

      function startFx() {
        if (fxRunning) return;
        fxRunning = true;

        cameraFx.style.display = "block";
        cameraEl.style.visibility = "hidden";

        const ctx = cameraFx.getContext("2d", { willReadFrequently: true });

        const tick = (t) => {
          if (!fxRunning) return;

          if (t - fxLast < 66) {
            fxRaf = requestAnimationFrame(tick);
            return;
          }
          fxLast = t;

          if (!cameraEl.videoWidth || !cameraEl.videoHeight) {
            fxRaf = requestAnimationFrame(tick);
            return;
          }

          const maxW = 900;
          const vw = cameraEl.videoWidth;
          const vh = cameraEl.videoHeight;
          const s = Math.min(1, maxW / vw);
          const rw = Math.max(2, Math.floor(vw * s));
          const rh = Math.max(2, Math.floor(vh * s));

          if (cameraFx.width !== rw || cameraFx.height !== rh) {
            cameraFx.width = rw;
            cameraFx.height = rh;
          }

          ctx.drawImage(cameraEl, 0, 0, rw, rh);
          if (currentFilterId !== "none") {
            const img = ctx.getImageData(0, 0, rw, rh);
            applyRecipeToImageData(img, currentRecipe);
            ctx.putImageData(img, 0, 0);
          }

          fxRaf = requestAnimationFrame(tick);
        };

        fxRaf = requestAnimationFrame(tick);
      }

      function applyCameraFilterPreview() {
        if (currentFilterId === "none") stopFx();
        else startFx();
      }

      function openFilterPanel() {
        filterPanel.classList.add("open");
        filterPanel.setAttribute("aria-hidden", "false");
      }
      function closeFilterPanel() {
        filterPanel.classList.remove("open");
        filterPanel.setAttribute("aria-hidden", "true");
      }

      function renderFilters() {
        filterListEl.innerHTML = "";
        FILTERS.forEach((f) => {
          const b = document.createElement("button");
          b.className = "filterItem" + (f.id === currentFilterId ? " active" : "");
          b.type = "button";

          const r = f.recipe;
          const recLine =
            f.id === "none"
              ? "no recipe"
              : `exp ${Math.round(r.exposure * 100)} • hi ${Math.round(r.highlights * 100)} • sh ${Math.round(
                  r.shadows * 100
                )} • sat ${Math.round(r.saturation * 100)}`;

          b.innerHTML = `${f.name}<span class="sub">${recLine}</span>`;

          b.addEventListener("click", () => {
            currentFilterId = f.id;
            currentRecipe = f.recipe;
            applyCameraFilterPreview();
            renderFilters();
            closeFilterPanel();
          });

          filterListEl.appendChild(b);
        });
      }
      renderFilters();

      filterBtn.addEventListener("click", () => {
        if (!filterBtn.disabled) openFilterPanel();
      });
      filterClose.addEventListener("click", closeFilterPanel);

      /* =========================
         PUFF VIDEO SOURCE (3 variants)
      ========================= */
      const puffBases = ["puff", "puff2", "puff3"];
      const chosenBase = puffBases[Math.floor(Math.random() * puffBases.length)];

      function isAppleSafari() {
        const ua = navigator.userAgent;
        const isIOS =
          /iPad|iPhone|iPod/.test(ua) ||
          (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|Edg|OPR|Firefox/.test(ua);
        return isIOS || isSafari;
      }

      function setPuffSource(base) {
        const v = `v=${encodeURIComponent(ASSET_VERSION)}`;
        if (isAppleSafari()) {
          puffEl.innerHTML = `
            <source src="${base}.mov?${v}" type='video/quicktime; codecs="hvc1"'>
            <source src="${base}.mp4?${v}" type='video/mp4; codecs="hvc1"'>
          `;
        } else {
          puffEl.innerHTML = `
            <source src="${base}.webm?${v}" type='video/webm; codecs="vp09.00.10.08"'>
            <source src="${base}.webm?${v}" type="video/webm">
          `;
        }
        puffEl.load();
      }

      puffEl.setAttribute("playsinline", "");
      puffEl.setAttribute("webkit-playsinline", "");
      puffEl.muted = true;
      puffEl.crossOrigin = "anonymous";
      setPuffSource(chosenBase);

      /* =========================
         CAMERA + MIRROR
      ========================= */
      let currentFacingMode = "environment";
      let stream = null;
      let mirrorMode = "auto";

      function shouldMirrorPreview() {
        return mirrorMode === "on" || (mirrorMode === "auto" && currentFacingMode === "user");
      }

      function applyMirrorToPreview() {
        cameraEl.classList.toggle("mirror", shouldMirrorPreview());
        cameraFx.classList.toggle("mirror", shouldMirrorPreview());
        mirrorBtn.textContent =
          mirrorMode === "auto" ? "Mirror: Auto" : mirrorMode === "on" ? "Mirror: On" : "Mirror: Off";
      }

      function waitLoadedMetadata(videoEl, timeoutMs = 6000) {
        return new Promise((resolve, reject) => {
          if (videoEl.readyState >= 1 && videoEl.videoWidth > 0) return resolve();
          const t = setTimeout(() => {
            cleanup();
            reject(new Error("metadata timeout"));
          }, timeoutMs);
          const onMeta = () => {
            cleanup();
            resolve();
          };
          const cleanup = () => {
            clearTimeout(t);
            videoEl.removeEventListener("loadedmetadata", onMeta);
          };
          videoEl.addEventListener("loadedmetadata", onMeta, { once: true });
        });
      }

      async function startCamera() {
        captureBtn.disabled = true;
        boothBtn.disabled = true;
        mirrorBtn.disabled = true;
        filterBtn.disabled = true;
        stickersBtn.disabled = true;
        textBtn.disabled = true;

        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }

        stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: currentFacingMode },
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        });

        cameraEl.srcObject = stream;

        await waitLoadedMetadata(cameraEl).catch(() => {});
        await cameraEl.play().catch(() => {});

        await waitLoadedMetadata(puffEl).catch(() => {});
        await puffEl.play().catch(() => {});

        flipBtn.disabled = false;
        captureBtn.disabled = false;
        boothBtn.disabled = false;
        mirrorBtn.disabled = false;
        filterBtn.disabled = false;

        // stickers/text should work normally regardless photobooth mode
        stickersBtn.disabled = false;
        textBtn.disabled = false;

        applyMirrorToPreview();
        applyCameraFilterPreview();

        startBtn.textContent = "AR Running";
        startBtn.disabled = true;
      }

      startBtn.addEventListener("click", async () => {
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
          alert("Could not access camera. Please allow permission and use HTTPS.");
        }
      });

      flipBtn.addEventListener("click", async () => {
        currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
        startBtn.disabled = false;
        startBtn.textContent = "Restart AR";
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
        }
      });

      mirrorBtn.addEventListener("click", () => {
        mirrorMode = mirrorMode === "auto" ? "on" : mirrorMode === "on" ? "off" : "auto";
        applyMirrorToPreview();
      });

      /* =========================
         TRANSFORM HELPERS (NO INERTIA)
      ========================= */
      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function dist(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }
      function angleDeg(a, b) {
        return (Math.atan2(b.y - a.y, b.x - a.x) * 180) / Math.PI;
      }

      function applyTransform(el, state) {
        el.style.left = state.x + "%";
        el.style.top = state.y + "%";
        el.style.transform = `translate(-50%, -50%) scale(${state.scale}) rotate(${state.rotation}deg)`;
      }

      function makeTransformable(el, state, onUpdate) {
        const pointers = new Map();
        let gestureStart = null;
        let dragStart = null;

        el.addEventListener("contextmenu", (e) => e.preventDefault());

        el.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          el.setPointerCapture?.(e.pointerId);
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          const isRightButtonRotate =
            e.pointerType === "mouse" && (e.buttons === 2 || e.button === 2);

          if (pointers.size === 1) {
            dragStart = {
              x: e.clientX,
              y: e.clientY,
              baseX: state.x,
              baseY: state.y,
              w: innerWidth,
              h: innerHeight,
              rotating: !!e.altKey || !!e.shiftKey || isRightButtonRotate,
              baseRotation: state.rotation,
            };
            gestureStart = null;
          } else if (pointers.size === 2) {
            const pts = Array.from(pointers.values());
            const a = pts[0], b = pts[1];
            gestureStart = {
              distance: dist(a, b),
              angle: angleDeg(a, b),
              scale: state.scale,
              rotation: state.rotation,
            };
            dragStart = null;
          }
        });

        el.addEventListener("pointermove", (e) => {
          if (!pointers.has(e.pointerId)) return;
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          if (pointers.size === 1 && dragStart) {
            const dx = ((e.clientX - dragStart.x) / dragStart.w) * 100;
            const dy = ((e.clientY - dragStart.y) / dragStart.h) * 100;

            if (dragStart.rotating) {
              // fix “rotate too fast”: 1:1-ish mapping (gentler)
              state.rotation = dragStart.baseRotation + dx * 1.1;
            } else {
              state.x = clamp(dragStart.baseX + dx, 0, 100);
              state.y = clamp(dragStart.baseY + dy, 0, 100);
            }
            onUpdate();
          }

          if (pointers.size === 2 && gestureStart) {
            const pts = Array.from(pointers.values());
            const a = pts[0], b = pts[1];
            const newDistance = dist(a, b);
            const newAngle = angleDeg(a, b);
            const scaleFactor = newDistance / Math.max(1, gestureStart.distance);

            state.scale = clamp(gestureStart.scale * scaleFactor, 0.25, 6);
            state.rotation = gestureStart.rotation + (newAngle - gestureStart.angle);
            onUpdate();
          }
        });

        function endPointer(e) {
          if (!pointers.has(e.pointerId)) return;
          pointers.delete(e.pointerId);
          if (pointers.size < 2) gestureStart = null;
          if (pointers.size === 0) dragStart = null;
        }

        el.addEventListener("pointerup", endPointer);
        el.addEventListener("pointercancel", endPointer);
        el.addEventListener("pointerleave", endPointer);

        // desktop zoom
        el.addEventListener(
          "wheel",
          (e) => {
            if (e.ctrlKey) return; // let browser zoom
            e.preventDefault();
            const delta = -Math.sign(e.deltaY) * 0.06;
            state.scale = clamp(state.scale * (1 + delta), 0.25, 6);
            onUpdate();
          },
          { passive: false }
        );
      }

      /* =========================
         SELECT / STATE for stickers + texts
      ========================= */
      let selectedStickerId = null;
      let selectedTextId = null;

      const stickersState = new Map(); // id -> { el, x,y,scale,rotation,src }
      const textsState = new Map(); // id -> { el, x,y,scale,rotation,text,color,size }

      function deselectAll() {
        selectedStickerId = null;
        selectedTextId = null;
        [...stickerLayer.querySelectorAll(".sticker")].forEach((n) => n.classList.remove("selected"));
        [...textLayer.querySelectorAll(".textItem")].forEach((n) => n.classList.remove("selected"));
        stickerRemove.disabled = true;
        removeTextBtn.disabled = true;

        // important: do NOT reset text controls to white here.
        syncTextControls();
      }

      function selectSticker(id) {
        deselectAll();
        selectedStickerId = id;
        const s = stickersState.get(id);
        if (s) s.el.classList.add("selected");
        stickerRemove.disabled = !s;
      }

      function selectText(id) {
        deselectAll();
        selectedTextId = id;
        const t = textsState.get(id);
        if (t) t.el.classList.add("selected");
        removeTextBtn.disabled = !t;
        syncTextControls();
      }

      function syncTextControls() {
        const t = selectedTextId ? textsState.get(selectedTextId) : null;
        const has = !!t;
        textContentInput.disabled = !has;
        textColorSelect.disabled = !has;
        textSizeRange.disabled = !has;
        if (!t) {
          textContentInput.value = "";
          // keep select value as-is (don’t force white)
          return;
        }
        textContentInput.value = t.text;
        textColorSelect.value = t.color;
        textSizeRange.value = String(t.size);
      }

      // click empty area to deselect
      window.addEventListener("pointerdown", (e) => {
        const hitSticker = e.target.classList?.contains("sticker");
        const hitText = e.target.classList?.contains("textItem");
        const hitUi = e.target.closest("#ui, #stickerPanel, #textPanel, #filterPanel, #boothPanel, #capturedDock, #builderOverlay");
        if (!hitSticker && !hitText && !hitUi) deselectAll();
      });

      /* =========================
         STICKERS
      ========================= */
      const STICKERS = [
        "sticker-1.png",
        "sticker-2.png",
        "sticker-3.png",
        "sticker-4.png",
        "sticker-5.png",
        "sticker-6.png",
        "sticker-7.png",
        "sticker-8.png",
      ];

      function openStickerPanel() {
        stickerPanel.classList.add("open");
        stickerPanel.setAttribute("aria-hidden", "false");
      }
      function closeStickerPanel() {
        stickerPanel.classList.remove("open");
        stickerPanel.setAttribute("aria-hidden", "true");
      }

      function renderStickerGrid() {
        stickerGrid.innerHTML = "";
        STICKERS.forEach((src) => {
          const item = document.createElement("div");
          item.className = "stickerItem";
          const img = document.createElement("img");
          img.src = `${src}?v=${encodeURIComponent(ASSET_VERSION)}`;
          img.alt = src;
          item.appendChild(img);
          item.addEventListener("click", () => addSticker(src));
          stickerGrid.appendChild(item);
        });
      }

      function addSticker(src) {
        const id = "s_" + Math.random().toString(36).slice(2, 9);
        const img = document.createElement("img");
        img.className = "sticker";
        img.src = `${src}?v=${encodeURIComponent(ASSET_VERSION)}`;
        img.alt = src;
        img.draggable = false;

        const state = { x: 50, y: 40, scale: 1, rotation: 0 };
        stickersState.set(id, { el: img, ...state, src: img.src });

        applyTransform(img, state);

        img.addEventListener("pointerdown", () => selectSticker(id));
        makeTransformable(img, state, () => {
          applyTransform(img, state);
          const s = stickersState.get(id);
          if (s) Object.assign(s, state);
        });

        stickerLayer.appendChild(img);
        selectSticker(id);

        stickerClear.disabled = stickersState.size === 0;
      }

      stickerRemove.addEventListener("click", () => {
        if (!selectedStickerId) return;
        const s = stickersState.get(selectedStickerId);
        if (s) s.el.remove();
        stickersState.delete(selectedStickerId);
        selectedStickerId = null;
        stickerRemove.disabled = true;
        stickerClear.disabled = stickersState.size === 0;
      });

      stickerClear.addEventListener("click", () => {
        stickersState.forEach((s) => s.el.remove());
        stickersState.clear();
        selectedStickerId = null;
        stickerRemove.disabled = true;
        stickerClear.disabled = true;
      });

      stickersBtn.addEventListener("click", () => {
        if (!stickersBtn.disabled) openStickerPanel();
      });
      stickerClose.addEventListener("click", closeStickerPanel);

      /* =========================
         TEXTS
      ========================= */
      // populate color select
      (function initTextColors() {
        textColorSelect.innerHTML = "";
        TEXT_COLORS.forEach((c) => {
          const opt = document.createElement("option");
          opt.value = c.hex;
          opt.textContent = c.name;
          textColorSelect.appendChild(opt);
        });
        // default selection to white (only initial)
        textColorSelect.value = "#ffffff";
      })();

      function openTextPanel() {
        textPanel.classList.add("open");
        textPanel.setAttribute("aria-hidden", "false");
        syncTextControls();
      }
      function closeTextPanel() {
        textPanel.classList.remove("open");
        textPanel.setAttribute("aria-hidden", "true");
      }

      function addText() {
        const id = "t_" + Math.random().toString(36).slice(2, 9);
        const div = document.createElement("div");
        div.className = "textItem";
        div.textContent = "Hello";
        div.style.color = textColorSelect.value; // use currently selected color
        div.style.fontSize = textSizeRange.value + "px";

        const state = { x: 50, y: 30, scale: 1, rotation: 0 };
        const data = {
          el: div,
          ...state,
          text: div.textContent,
          color: div.style.color,
          size: parseInt(textSizeRange.value, 10),
        };
        textsState.set(id, data);

        applyTransform(div, state);

        div.addEventListener("pointerdown", () => selectText(id));
        makeTransformable(div, state, () => {
          applyTransform(div, state);
          const t = textsState.get(id);
          if (t) Object.assign(t, state);
        });

        textLayer.appendChild(div);
        selectText(id);

        clearTextBtn.disabled = textsState.size === 0;
      }

      addTextBtn.addEventListener("click", addText);

      removeTextBtn.addEventListener("click", () => {
        if (!selectedTextId) return;
        const t = textsState.get(selectedTextId);
        if (t) t.el.remove();
        textsState.delete(selectedTextId);
        selectedTextId = null;
        removeTextBtn.disabled = true;
        clearTextBtn.disabled = textsState.size === 0;
        syncTextControls();
      });

      clearTextBtn.addEventListener("click", () => {
        textsState.forEach((t) => t.el.remove());
        textsState.clear();
        selectedTextId = null;
        removeTextBtn.disabled = true;
        clearTextBtn.disabled = true;
        syncTextControls();
      });

      textContentInput.addEventListener("input", () => {
        if (!selectedTextId) return;
        const t = textsState.get(selectedTextId);
        if (!t) return;
        t.text = textContentInput.value;
        t.el.textContent = t.text;
      });

      textColorSelect.addEventListener("change", () => {
        if (!selectedTextId) return;
        const t = textsState.get(selectedTextId);
        if (!t) return;
        t.color = textColorSelect.value;
        t.el.style.color = t.color; // FIX: persist chosen color, no auto revert
      });

      textSizeRange.addEventListener("input", () => {
        if (!selectedTextId) return;
        const t = textsState.get(selectedTextId);
        if (!t) return;
        t.size = parseInt(textSizeRange.value, 10);
        t.el.style.fontSize = t.size + "px";
      });

      textBtn.addEventListener("click", () => {
        if (!textBtn.disabled) openTextPanel();
      });
      textClose.addEventListener("click", closeTextPanel);

      /* =========================
         PANELS open/close
      ========================= */
      function openBoothPanel() {
        boothPanel.classList.add("open");
        boothPanel.setAttribute("aria-hidden", "false");
      }
      function closeBoothPanel() {
        boothPanel.classList.remove("open");
        boothPanel.setAttribute("aria-hidden", "true");
      }
      boothClose.addEventListener("click", closeBoothPanel);

      boothBtn.addEventListener("click", () => {
        if (boothBtn.disabled) return;
        // quick toggle ON/OFF
        photoboothOn = !photoboothOn;
        boothBtn.textContent = photoboothOn ? "Photobooth: On" : "Photobooth: Off";
        if (photoboothOn) {
          capturedDock.style.display = "block";
          capturedDock.setAttribute("aria-hidden", "false");
          openBoothPanel();
        } else {
          capturedDock.style.display = "none";
          capturedDock.setAttribute("aria-hidden", "true");
          closeBoothPanel();
          closeBuilder();
        }
      });

      /* =========================
         CAPTURED STORAGE (Photobooth ON = store many)
      ========================= */
      let photoboothOn = false;
      const captured = []; // { url, w, h }

      function renderCapturedDock() {
        capturedList.innerHTML = "";
        captured.forEach((c, idx) => {
          const card = document.createElement("div");
          card.className = "capThumb";
          const img = document.createElement("img");
          img.src = c.url;
          img.alt = "capture " + (idx + 1);
          const badge = document.createElement("div");
          badge.className = "capBadge";
          badge.textContent = String(idx + 1);

          card.appendChild(img);
          card.appendChild(badge);
          capturedList.appendChild(card);
        });

        cueBtn.disabled = captured.length === 0;
        capturedClearBtn.disabled = captured.length === 0;
      }

      capturedClearBtn.addEventListener("click", () => {
        captured.forEach((c) => URL.revokeObjectURL(c.url));
        captured.length = 0;
        renderCapturedDock();
        // also clear assignments in builder
        stripState.assignments.fill(null);
        drawStripPreview();
      });

      /* =========================
         CAPTURE (bake camera + puff + stickers + texts)
      ========================= */
      function getPreviewSourceCanvas() {
        // draw full-res camera frame to canvas (with filter) at capture time
        const vw = cameraEl.videoWidth;
        const vh = cameraEl.videoHeight;
        if (!vw || !vh) return null;

        const canvas = document.createElement("canvas");
        canvas.width = vw;
        canvas.height = vh;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });

        // mirror handling: if preview is mirrored, bake mirrored result to match what user sees
        const mirrored = shouldMirrorPreview();
        if (mirrored) {
          ctx.translate(vw, 0);
          ctx.scale(-1, 1);
        }
        ctx.drawImage(cameraEl, 0, 0, vw, vh);

        // apply filter to capture
        if (currentFilterId !== "none") {
          const img = ctx.getImageData(0, 0, vw, vh);
          applyRecipeToImageData(img, currentRecipe);
          ctx.putImageData(img, 0, 0);
        }

        // reset transform for overlays (so we can compute positions in screen space)
        if (mirrored) {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        return canvas;
      }

      function getElementRectOnScreen(el) {
        const r = el.getBoundingClientRect();
        return r;
      }

      async function drawPuffFrameTo(ctx, outW, outH) {
        // draw current puff video frame (no duplication; this is the ONLY puff)
        if (!puffEl.videoWidth || !puffEl.videoHeight) return;
        const puffRect = getElementRectOnScreen(puffEl);

        // map from screen coords to capture canvas coords (camera cover)
        // We captured camera at native video size; need mapping from screen -> video pixels.
        // Use object-fit: cover mapping.
        const map = screenToVideoMapper(outW, outH);
        const dst = map.rectToVideoPixels(puffRect);

        // draw puff video into those pixels
        ctx.drawImage(puffEl, dst.x, dst.y, dst.w, dst.h);
      }

      function drawStickerTo(ctx, outW, outH, stickerEl) {
        const r = getElementRectOnScreen(stickerEl);
        const map = screenToVideoMapper(outW, outH);
        const dst = map.rectToVideoPixels(r);
        ctx.drawImage(stickerEl, dst.x, dst.y, dst.w, dst.h);
      }

      function drawTextTo(ctx, outW, outH, t) {
        const r = getElementRectOnScreen(t.el);
        const map = screenToVideoMapper(outW, outH);
        const dst = map.rectToVideoPixels(r);

        // approximate rotation/scale using stored state
        ctx.save();
        ctx.translate(dst.x + dst.w / 2, dst.y + dst.h / 2);
        ctx.rotate((t.rotation * Math.PI) / 180);
        ctx.scale(t.scale, t.scale);

        // font size: based on element font-size but needs mapping to pixels
        const sizePx = t.size * (map.videoScale); // scale by cover factor
        ctx.font = `900 ${Math.max(10, sizePx)}px BeautifulFreak, system-ui`;
        ctx.fillStyle = t.color || "#ffffff";
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";

        // subtle bg like UI? (optional: keep clean; user didn’t ask for bg in export)
        const text = (t.text || "").toString();
        // multi-line support
        const lines = text.split("\n");
        const lh = Math.max(12, sizePx * 1.05);
        const totalH = lh * lines.length;

        // draw each line centered
        lines.forEach((line, i) => {
          const y = (i - (lines.length - 1) / 2) * lh;
          ctx.fillText(line, 0, y);
        });

        ctx.restore();
      }

      function screenToVideoMapper(vw, vh) {
        // screen -> camera video pixels mapping for object-fit: cover
        const sw = innerWidth;
        const sh = innerHeight;

        const videoAspect = vw / vh;
        const screenAspect = sw / sh;

        let drawW, drawH, offX, offY;
        if (screenAspect > videoAspect) {
          // screen wider -> fit height, crop width
          drawH = sh;
          drawW = sh * videoAspect;
          offX = (sw - drawW) / 2;
          offY = 0;
        } else {
          // screen taller -> fit width, crop height
          drawW = sw;
          drawH = sw / videoAspect;
          offX = 0;
          offY = (sh - drawH) / 2;
        }

        const scaleX = vw / drawW;
        const scaleY = vh / drawH;

        return {
          videoScale: (scaleX + scaleY) / 2,
          rectToVideoPixels(rect) {
            const x = (rect.left - offX) * scaleX;
            const y = (rect.top - offY) * scaleY;
            const w = rect.width * scaleX;
            const h = rect.height * scaleY;
            return { x, y, w, h };
          },
        };
      }

      async function captureNow() {
        const base = getPreviewSourceCanvas();
        if (!base) return;

        const ctx = base.getContext("2d");

        // overlays:
        await drawPuffFrameTo(ctx, base.width, base.height);

        // stickers
        const stickerEls = [...stickerLayer.querySelectorAll(".sticker")];
        for (const el of stickerEls) drawStickerTo(ctx, base.width, base.height, el);

        // texts
        const ts = [...textsState.values()];
        // ensure font is ready (best-effort)
        if (BEAUTIFUL_FREAK_READY) {
          // already ready
        } else {
          try { await document.fonts.ready; } catch (_) {}
        }
        for (const t of ts) drawTextTo(ctx, base.width, base.height, t);

        return new Promise((resolve) => {
          base.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            resolve({ url, w: base.width, h: base.height });
          }, "image/png", 0.92);
        });
      }

      /* =========================
         Photobooth ON/OFF: capture behavior
         - OFF: just downloads single photo
         - ON: stores into captured list
      ========================= */
      function downloadBlobUrl(url, filename) {
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      captureBtn.addEventListener("click", async () => {
        if (captureBtn.disabled) return;
        captureBtn.disabled = true;
        try {
          const res = await captureNow();
          if (!res) return;

          if (!photoboothOn) {
            // normal mode: download immediately
            downloadBlobUrl(res.url, `puff-${Date.now()}.png`);
            // revoke later
            setTimeout(() => URL.revokeObjectURL(res.url), 8000);
          } else {
            captured.unshift(res);
            renderCapturedDock();
            // also update builder thumb list (if open)
            renderAssignGrid();
          }
        } catch (e) {
          console.error(e);
        } finally {
          captureBtn.disabled = false;
        }
      });

      /* =========================
         BOOTH PANEL open/close
      ========================= */
      function openBoothPanelSoft() {
        boothPanel.classList.add("open");
        boothPanel.setAttribute("aria-hidden", "false");
      }
      boothBtn.addEventListener("contextmenu", (e) => e.preventDefault());

      /* =========================
         STICKER/TEXT/FILTER panel buttons
      ========================= */
      stickerClose.addEventListener("click", closeStickerPanel);
      textClose.addEventListener("click", closeTextPanel);

      /* =========================
         FILTER UI
      ========================= */
      function openPanel(panel) {
        panel.classList.add("open");
        panel.setAttribute("aria-hidden", "false");
      }
      function closePanel(panel) {
        panel.classList.remove("open");
        panel.setAttribute("aria-hidden", "true");
      }

      /* =========================
         Build UI actions
      ========================= */
      filterBtn.addEventListener("click", () => {
        if (!filterBtn.disabled) openPanel(filterPanel);
      });
      filterClose.addEventListener("click", () => closePanel(filterPanel));

      stickersBtn.addEventListener("click", () => {
        if (!stickersBtn.disabled) openPanel(stickerPanel);
      });

      textBtn.addEventListener("click", () => {
        if (!textBtn.disabled) {
          openPanel(textPanel);
          syncTextControls();
        }
      });

      boothBtn.addEventListener("click", () => {
        if (boothBtn.disabled) return;
        // toggled above; also open explanation sheet
        if (photoboothOn) openBoothPanelSoft();
      });

      /* =========================
         Render sticker grid
      ========================= */
      renderStickerGrid();

      /* =========================
         STRIP BUILDER (common ratios + square outlines, no shadow, no numbering)
      ========================= */
      const LAYOUTS = [
        { id: "one", name: "1 Photo", slots: 1, aspectW: 2, aspectH: 6, grid: { cols: 1, rows: 1 } },
        // common refs:
        // 3 vertical = 6x2 (W:H = 2:6)
        { id: "v3", name: "3 Vertical", slots: 3, aspectW: 2, aspectH: 6, grid: { cols: 1, rows: 3 } },
        // 3 horizontal = 2x6 (W:H = 6:2)
        { id: "h3", name: "3 Horizontal", slots: 3, aspectW: 6, aspectH: 2, grid: { cols: 3, rows: 1 } },
        // 4 grid = 4x6 (W:H = 6:4)
        { id: "g4", name: "4 Grid", slots: 4, aspectW: 6, aspectH: 4, grid: { cols: 2, rows: 2 } },
      ];

      const stripState = {
        layoutId: "v3",
        frameHex: "#060d3d",
        assignments: new Array(3).fill(null), // index -> captured index
        selectedPanel: 0,
      };

      function setLayout(layoutId) {
        stripState.layoutId = layoutId;
        const L = LAYOUTS.find((x) => x.id === layoutId);
        stripState.assignments = new Array(L.slots).fill(null);
        stripState.selectedPanel = 0;

        // set preview aspect ratio to match
        stripPreview.style.aspectRatio = `${L.aspectW} / ${L.aspectH}`;
        drawStripPreview();
        renderLayoutPills();
      }

      function setFrameColor(hex) {
        stripState.frameHex = hex;
        drawStripPreview();
        renderColorPills();
      }

      function renderLayoutPills() {
        layoutRow.innerHTML = "";
        LAYOUTS.forEach((l) => {
          const b = document.createElement("button");
          b.className = "pill" + (stripState.layoutId === l.id ? " active" : "");
          b.type = "button";
          b.textContent = l.name;
          b.addEventListener("click", () => setLayout(l.id));
          layoutRow.appendChild(b);
        });
      }

      function renderColorPills() {
        colorRow.innerHTML = "";
        BOOTH_COLORS.forEach((c) => {
          const b = document.createElement("button");
          b.className = "pill" + (stripState.frameHex.toLowerCase() === c.hex.toLowerCase() ? " active" : "");
          b.type = "button";
          b.textContent = c.name;
          b.addEventListener("click", () => setFrameColor(c.hex));
          colorRow.appendChild(b);
        });
      }

      function renderAssignGrid() {
        assignGrid.innerHTML = "";
        captured.forEach((c, idx) => {
          const d = document.createElement("div");
          d.className = "assignThumb";
          const img = document.createElement("img");
          img.src = c.url;
          img.alt = "cap " + (idx + 1);
          d.appendChild(img);
          d.addEventListener("click", () => {
            if (stripState.selectedPanel == null) return;
            stripState.assignments[stripState.selectedPanel] = idx;
            drawStripPreview();
          });
          assignGrid.appendChild(d);
        });
      }

      function openBuilder() {
        if (captured.length === 0) return;
        builderOverlay.style.display = "block";
        builderOverlay.setAttribute("aria-hidden", "false");

        // init pills if first time
        renderLayoutPills();
        renderColorPills();
        renderAssignGrid();

        // ensure aspect
        const L = LAYOUTS.find((x) => x.id === stripState.layoutId) || LAYOUTS[1];
        stripPreview.style.aspectRatio = `${L.aspectW} / ${L.aspectH}`;

        drawStripPreview();
      }

      function closeBuilder() {
        builderOverlay.style.display = "none";
        builderOverlay.setAttribute("aria-hidden", "true");
      }

      builderClose.addEventListener("click", closeBuilder);
      builderClose2.addEventListener("click", closeBuilder);

      cueBtn.addEventListener("click", openBuilder);

      /* =========================
         Draw strip preview (square outlines, spacing filled with frame color)
      ========================= */
      function drawStripPreview() {
        const L = LAYOUTS.find((x) => x.id === stripState.layoutId) || LAYOUTS[1];

        // Choose preview resolution (not huge). Keep consistent aspect.
        const base = 1200;
        const aspect = L.aspectW / L.aspectH;
        let cw, ch;
        if (aspect >= 1) {
          cw = base;
          ch = Math.round(base / aspect);
        } else {
          ch = base;
          cw = Math.round(base * aspect);
        }

        stripPreview.width = cw;
        stripPreview.height = ch;

        const ctx = stripPreview.getContext("2d");
        ctx.clearRect(0, 0, cw, ch);

        // frame background
        ctx.fillStyle = stripState.frameHex;
        ctx.fillRect(0, 0, cw, ch);

        // margins & gaps (in frame color anyway)
        const margin = Math.round(Math.min(cw, ch) * 0.08);
        const gap = Math.round(Math.min(cw, ch) * 0.055);

        // logo at top (small)
        const logoYPad = Math.round(margin * 0.35);
        const logoH = Math.round(Math.min(cw, ch) * 0.06);
        const logoW = Math.round(logoH * 3.2);

        // reserve top brand bar only for layouts that are strips (v3/h3/g4/one)
        const topBar = Math.round(logoH + logoYPad * 2);

        // panels area
        const panelsX = margin;
        const panelsY = margin + topBar;
        const panelsW = cw - margin * 2;
        const panelsH = ch - panelsY - margin;

        // draw logo
        const logoImg = new Image();
        logoImg.onload = () => {
          ctx.save();
          ctx.globalAlpha = 1;
          ctx.drawImage(logoImg, Math.round((cw - logoW) / 2), margin + logoYPad, logoW, logoH);
          ctx.restore();

          drawPanels();
        };
        logoImg.onerror = () => drawPanels();
        logoImg.src = `${logoForBg(stripState.frameHex)}?v=${encodeURIComponent(ASSET_VERSION)}`;

        function drawPanels() {
          const cols = L.grid.cols;
          const rows = L.grid.rows;

          const cellW = Math.floor((panelsW - gap * (cols - 1)) / cols);
          const cellH = Math.floor((panelsH - gap * (rows - 1)) / rows);

          // Square outlines (no curves), no shadow, no numbers
          ctx.lineWidth = Math.max(2, Math.round(Math.min(cw, ch) * 0.003));
          // outline color: subtle contrast
          ctx.strokeStyle =
            stripState.frameHex.toLowerCase() === "#ffffff" || stripState.frameHex.toLowerCase() === "#e8eef1"
              ? "rgba(0,0,0,0.35)"
              : "rgba(255,255,255,0.55)";

          // selected panel highlight for preview only
          const selStroke =
            stripState.frameHex.toLowerCase() === "#ffffff" || stripState.frameHex.toLowerCase() === "#e8eef1"
              ? "rgba(0,0,0,0.65)"
              : "rgba(255,255,255,0.85)";

          for (let i = 0; i < L.slots; i++) {
            const r = Math.floor(i / cols);
            const c = i % cols;

            const x = panelsX + c * (cellW + gap);
            const y = panelsY + r * (cellH + gap);

            // panel outline
            ctx.strokeStyle = i === stripState.selectedPanel ? selStroke : ctx.strokeStyle;
            ctx.strokeRect(x, y, cellW, cellH);

            // image if assigned
            const capIdx = stripState.assignments[i];
            if (capIdx != null && captured[capIdx]) {
              const img = new Image();
              img.onload = () => {
                // cover fit inside cell (no rounding)
                const iw = img.naturalWidth || 1;
                const ih = img.naturalHeight || 1;
                const s = Math.max(cellW / iw, cellH / ih);
                const dw = iw * s;
                const dh = ih * s;
                const dx = x + (cellW - dw) / 2;
                const dy = y + (cellH - dh) / 2;

                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, cellW, cellH);
                ctx.clip();
                ctx.drawImage(img, dx, dy, dw, dh);
                ctx.restore();

                // redraw outline on top
                ctx.save();
                ctx.strokeStyle = i === stripState.selectedPanel ? selStroke : (ctx.strokeStyle);
                ctx.strokeRect(x, y, cellW, cellH);
                ctx.restore();
              };
              img.src = captured[capIdx].url;
            }

            // clickable regions: store for hit test
          }

          // build hit map for selecting panel
          stripPreview._hit = { L, margin, topBar, panelsX, panelsY, panelsW, panelsH, gap, cellW, cellH };
        }
      }

      stripPreview.addEventListener("pointerdown", (e) => {
        const hit = stripPreview._hit;
        if (!hit) return;
        const rect = stripPreview.getBoundingClientRect();
        const px = ((e.clientX - rect.left) / rect.width) * stripPreview.width;
        const py = ((e.clientY - rect.top) / rect.height) * stripPreview.height;

        const { L, panelsX, panelsY, gap, cellW, cellH } = hit;
        const cols = L.grid.cols;

        for (let i = 0; i < L.slots; i++) {
          const r = Math.floor(i / cols);
          const c = i % cols;
          const x = panelsX + c * (cellW + gap);
          const y = panelsY + r * (cellH + gap);
          if (px >= x && px <= x + cellW && py >= y && py <= y + cellH) {
            stripState.selectedPanel = i;
            drawStripPreview();
            break;
          }
        }
      });

      /* =========================
         Export strip PNG (exact “common size” proportions)
      ========================= */
      async function exportStripPng() {
        const L = LAYOUTS.find((x) => x.id === stripState.layoutId) || LAYOUTS[1];

        // choose export pixel size that respects the reference ratios:
        // v3/one: 2:6 => 1200 x 3600
        // h3: 6:2 => 3600 x 1200
        // g4: 6:4 => 3000 x 2000
        let outW = 1200, outH = 3600;
        if (L.id === "h3") { outW = 3600; outH = 1200; }
        if (L.id === "g4") { outW = 3000; outH = 2000; }
        if (L.id === "one") { outW = 1200; outH = 3600; }

        const canvas = document.createElement("canvas");
        canvas.width = outW;
        canvas.height = outH;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = stripState.frameHex;
        ctx.fillRect(0, 0, outW, outH);

        const margin = Math.round(Math.min(outW, outH) * 0.08);
        const gap = Math.round(Math.min(outW, outH) * 0.055);

        // logo
        const logoYPad = Math.round(margin * 0.35);
        const logoH = Math.round(Math.min(outW, outH) * 0.06);
        const logoW = Math.round(logoH * 3.2);
        const topBar = Math.round(logoH + logoYPad * 2);

        const panelsX = margin;
        const panelsY = margin + topBar;
        const panelsW = outW - margin * 2;
        const panelsH = outH - panelsY - margin;

        const cols = L.grid.cols;
        const rows = L.grid.rows;

        const cellW = Math.floor((panelsW - gap * (cols - 1)) / cols);
        const cellH = Math.floor((panelsH - gap * (rows - 1)) / rows);

        // outline
        ctx.lineWidth = Math.max(3, Math.round(Math.min(outW, outH) * 0.003));
        ctx.strokeStyle =
          stripState.frameHex.toLowerCase() === "#ffffff" || stripState.frameHex.toLowerCase() === "#e8eef1"
            ? "rgba(0,0,0,0.35)"
            : "rgba(255,255,255,0.55)";

        // draw logo
        await new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            ctx.drawImage(img, Math.round((outW - logoW) / 2), margin + logoYPad, logoW, logoH);
            resolve();
          };
          img.onerror = () => resolve();
          img.src = `${logoForBg(stripState.frameHex)}?v=${encodeURIComponent(ASSET_VERSION)}`;
        });

        // draw panels + assigned images
        for (let i = 0; i < L.slots; i++) {
          const rr = Math.floor(i / cols);
          const cc = i % cols;
          const x = panelsX + cc * (cellW + gap);
          const y = panelsY + rr * (cellH + gap);

          // image
          const capIdx = stripState.assignments[i];
          if (capIdx != null && captured[capIdx]) {
            await new Promise((resolve) => {
              const img = new Image();
              img.onload = () => {
                const iw = img.naturalWidth || 1;
                const ih = img.naturalHeight || 1;
                const s = Math.max(cellW / iw, cellH / ih);
                const dw = iw * s;
                const dh = ih * s;
                const dx = x + (cellW - dw) / 2;
                const dy = y + (cellH - dh) / 2;

                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, cellW, cellH);
                ctx.clip();
                ctx.drawImage(img, dx, dy, dw, dh);
                ctx.restore();
                resolve();
              };
              img.onerror = () => resolve();
              img.src = captured[capIdx].url;
            });
          }

          // outline (square)
          ctx.strokeRect(x, y, cellW, cellH);
        }

        return new Promise((resolve) => {
          canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            resolve(url);
          }, "image/png", 0.92);
        });
      }

      builderDone.addEventListener("click", async () => {
        if (captured.length === 0) return;
        builderDone.disabled = true;
        try {
          const url = await exportStripPng();
          downloadBlobUrl(url, `puff-strip-${Date.now()}.png`);
          setTimeout(() => URL.revokeObjectURL(url), 12000);
        } catch (e) {
          console.error(e);
        } finally {
          builderDone.disabled = false;
        }
      });

      /* =========================
         Init builder defaults
      ========================= */
      setLayout("v3");
      setFrameColor("#060d3d");

      /* =========================
         Open booth panel button
      ========================= */
      boothPanel.addEventListener("click", (e) => {
        // tap outside? no-op
      });

      /* =========================
         Set sticker/text/filter buttons after AR starts
      ========================= */
      function enableUiAfterStart() {
        filterBtn.disabled = false;
        boothBtn.disabled = false;
        stickersBtn.disabled = false;
        textBtn.disabled = false;
        captureBtn.disabled = false;
      }

      /* =========================
         Start AR triggers
      ========================= */
      startBtn.addEventListener("click", async () => {
        try {
          await startCamera();
          enableUiAfterStart();
        } catch (e) {
          console.error(e);
        }
      });

      /* =========================
         Sticker/Text panel close
      ========================= */
      stickerClose.addEventListener("click", () => closePanel(stickerPanel));
      textClose.addEventListener("click", () => closePanel(textPanel));

      /* =========================
         Booth panel close
      ========================= */
      boothClose.addEventListener("click", () => closePanel(boothPanel));

      /* =========================
         Render initial captured dock
      ========================= */
      renderCapturedDock();
    </script>
  </body>
</html>
