<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Puff Dragon AR Viewer</title>

    <style>
      @font-face {
        font-family: "BeautifulFreak";
        src: url("BeautifulFreak.otf") format("opentype");
        font-display: swap;
      }

      :root {
        --imperial-red: #fa213f;
        --dark-blue: #060d3d;
        --bright-grey: #e8eef1;
        --white: #ffffff;
        --puff-yellow: #fff100;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        height: 100%;
        touch-action: none;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }

      .hidden {
        display: none !important;
      }

      /* =========================
         INTRO OVERLAY
      ========================= */
      #introOverlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      /* Full width; top/bottom bars stay white */
      #introVideo {
        width: 100vw;
        height: 100vh;
        object-fit: contain;
        background: #fff;
        display: block;
      }

      #introClosePuff {
        position: absolute;
        top: calc(14px + env(safe-area-inset-top));
        left: 50%;
        transform: translateX(-50%);
        width: min(22vw, 96px);
        height: auto;
        z-index: 3;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      #introClosePuff:active {
        transform: translateX(-50%) scale(0.96);
      }

      #exploreBtn {
        position: absolute;
        left: 50%;
        top: 55%;
        transform: translate(-50%, -50%);
        border: 0;
        border-radius: 16px;
        padding: 18px 34px;
        font-size: clamp(20px, 4.2vw, 30px);
        font-weight: 900;
        letter-spacing: 0.2px;
        color: #fff;
        background: var(--imperial-red);
        cursor: pointer;
        z-index: 2;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      }

      #exploreBtn:active {
        transform: translate(-50%, -50%) scale(0.98);
      }

      /* =========================
         MAIN APP
      ========================= */
      #app {
        position: fixed;
        inset: 0;
      }

      #camera {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: 1;
        transform-origin: center;
      }
      #camera.mirror {
        transform: scaleX(-1);
      }

      /* Filtered preview canvas (closer to final) */
      #cameraFx {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
        display: none;
        background: #000;
      }
      #cameraFx.mirror {
        transform: scaleX(-1);
        transform-origin: center;
      }

      #puff {
        position: fixed;
        left: 50%;
        top: 72%;
        width: min(90vw, 500px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1.55);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        z-index: 2;
        user-select: none;
      }

      /* Stickers & Text on live camera */
      #stickerLayer {
        position: fixed;
        inset: 0;
        z-index: 3;
        pointer-events: none;
      }
      #textLayer {
        position: fixed;
        inset: 0;
        z-index: 4;
        pointer-events: none;
      }

      .sticker {
        position: fixed;
        left: 50%;
        top: 40%;
        width: min(45vw, 260px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        user-select: none;
      }
      .sticker.selected {
        outline: 2px solid rgba(255, 255, 255, 0.6);
        outline-offset: 6px;
        border-radius: 14px;
      }

      .textItem {
        position: fixed;
        left: 50%;
        top: 30%;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        transform-origin: center;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        padding: 6px 10px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.18);
        backdrop-filter: blur(6px);
        color: #fff;
        font-family: "BeautifulFreak", system-ui;
        font-size: 44px;
        line-height: 1;
        white-space: pre;
        will-change: transform;
      }
      .textItem.selected {
        outline: 2px solid rgba(255, 255, 255, 0.65);
        outline-offset: 6px;
      }

      /* =========================
         UI
      ========================= */
      #ui {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 7px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.65),
          rgba(0, 0, 0, 0)
        );
        z-index: 10;
      }
      .ui-row {
        display: flex;
        gap: 7px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      button {
        border: 0;
        border-radius: 9px;
        padding: 6px 9px;
        font-size: 11px;
        font-weight: 900;
        letter-spacing: 0.2px;
        color: #fff;
        background: #e11d2e;
        min-width: 72px;
        line-height: 1;
        cursor: pointer;
      }
      button.secondary {
        background: rgba(255, 255, 255, 0.15);
      }
      button:disabled {
        opacity: 0.5;
        cursor: default;
      }

      #start {
        background: var(--imperial-red);
      }
      #capture {
        background: var(--puff-yellow);
        color: var(--dark-blue);
        font-weight: 900;
        min-width: 84px;
      }
      #boothBtn {
        min-width: 120px;
      }

      /* Desktop hint */
      #desktopHint {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 11;
        padding: 7px 9px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.45);
        color: rgba(255, 255, 255, 0.85);
        font: 800 11px system-ui;
        display: none;
        user-select: none;
      }
      @media (hover: hover) and (pointer: fine) {
        #desktopHint {
          display: block;
        }
      }

      /* =========================
         PANELS (bottom sheets)
      ========================= */
      #stickerPanel,
      #filterPanel,
      #textPanel,
      #builderPanel {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        transform: translateY(110%);
        transition: transform 0.22s ease;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        padding: 12px 12px calc(12px + env(safe-area-inset-bottom));
        z-index: 30;
        border-top-left-radius: 18px;
        border-top-right-radius: 18px;
        max-height: min(82vh, 650px);
        display: flex;
        flex-direction: column;
        -webkit-overflow-scrolling: touch;
      }
      #stickerPanel.open,
      #filterPanel.open,
      #textPanel.open,
      #builderPanel.open {
        transform: translateY(0);
      }

      .panelHeader {
        position: sticky;
        top: 0;
        z-index: 2;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
        padding-bottom: 8px;
      }
      .panelTitle {
        color: #fff;
        font: 900 14px system-ui;
      }
      .panelBody {
        overflow-y: auto;
        flex: 1;
        padding-right: 2px;
      }

      #stickerGrid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 9px;
      }
      .stickerItem {
        background: rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 9px;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1 / 1;
        border: 0;
        cursor: pointer;
      }
      .stickerItem img {
        max-width: 100%;
        max-height: 100%;
        display: block;
      }

      #filterList {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 9px;
      }
      .filterItem {
        border: 0;
        border-radius: 14px;
        padding: 10px 10px;
        background: rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.95);
        font: 900 12px system-ui;
        text-align: left;
        cursor: pointer;
      }
      .filterItem .sub {
        display: block;
        margin-top: 4px;
        opacity: 0.78;
        font: 700 10px system-ui;
        line-height: 1.1;
      }
      .filterItem.active {
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 2px;
      }

      .fieldLabel {
        color: rgba(255, 255, 255, 0.85);
        font: 800 11px system-ui;
        margin: 10px 0 6px;
        text-align: center;
      }
      select,
      input[type="range"],
      input[type="text"] {
        width: 100%;
        border: 0;
        border-radius: 12px;
        padding: 10px 12px;
        background: rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.95);
        font: 800 12px system-ui;
        outline: none;
      }
      input[type="range"] {
        padding: 10px 8px;
      }

      /* =========================
         PHOTOBOOTH MODE (gallery sidebar)
      ========================= */
      #boothSidebar {
        position: fixed;
        top: 0;
        right: 0;
        height: 100vh;
        width: min(34vw, 340px);
        padding: calc(12px + env(safe-area-inset-top)) 10px
          calc(12px + env(safe-area-inset-bottom));
        z-index: 15;
        display: none;
        background: linear-gradient(
          to left,
          rgba(0, 0, 0, 0.72),
          rgba(0, 0, 0, 0)
        );
        pointer-events: none;
      }
      #boothSidebar.open {
        display: block;
      }
      #boothSidebarCard {
        height: 100%;
        border-radius: 16px;
        background: rgba(0, 0, 0, 0.55);
        backdrop-filter: blur(10px);
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: auto;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      #boothSidebarHead {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      #boothSidebarHead .label {
        color: rgba(255, 255, 255, 0.92);
        font: 900 12px system-ui;
      }
      #galleryGrid {
        flex: 1;
        overflow: auto;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        padding-right: 2px;
      }
      .shotThumb {
        border-radius: 12px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.08);
        cursor: pointer;
        position: relative;
      }
      .shotThumb img {
        width: 100%;
        height: auto;
        display: block;
      }
      .shotThumb .n {
        position: absolute;
        top: 6px;
        left: 6px;
        width: 22px;
        height: 22px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.55);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font: 900 12px system-ui;
      }
      .shotThumb.active {
        outline: 2px solid rgba(255, 255, 255, 0.75);
        outline-offset: 2px;
      }

      #visualsCue {
        width: 100%;
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        background: var(--imperial-red);
        color: #fff;
      }

      /* =========================
         STRIP BUILDER (full-screen modal)
      ========================= */
      #builderModal {
        position: fixed;
        inset: 0;
        z-index: 50;
        display: none;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        padding: calc(12px + env(safe-area-inset-top)) 12px
          calc(12px + env(safe-area-inset-bottom));
      }
      #builderModal.open {
        display: block;
      }

      #builderWrap {
        height: 100%;
        display: grid;
        grid-template-columns: 1fr min(340px, 34vw);
        gap: 12px;
      }

      @media (max-width: 860px) {
        #builderWrap {
          grid-template-columns: 1fr;
          grid-template-rows: 1fr auto;
        }
      }

      #builderMain {
        border-radius: 18px;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.35);
        display: flex;
        flex-direction: column;
      }

      #builderTopbar {
        padding: 10px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        background: rgba(0, 0, 0, 0.45);
      }
      #builderTopbar .title {
        color: #fff;
        font: 900 13px system-ui;
      }
      #builderTopbar .right {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      #stripStage {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px;
      }

      /* The preview strip always shows at correct aspect for the chosen layout */
      #stripPreview {
        width: min(78vh, 72vw, 780px);
        height: auto;
        aspect-ratio: 2 / 3; /* will be updated by JS per layout */
        background: var(--dark-blue);
        border-radius: 18px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
      }

      /* top + bottom bands (frame color), logo at top */
      .stripBandTop {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        height: 14%;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2;
        pointer-events: none;
      }
      .stripBandTop img {
        height: 42%;
        width: auto;
        max-width: 70%;
        object-fit: contain;
        opacity: 0.95;
      }
      .stripBandBottom {
        position: absolute;
        left: 0;
        bottom: 0;
        right: 0;
        height: 12%;
        background: transparent;
        z-index: 2;
        pointer-events: none;
      }

      .stripInner {
        position: absolute;
        left: 0;
        right: 0;
        top: 14%;
        bottom: 12%;
        padding: 5.8%;
        box-sizing: border-box;
        display: grid;
        gap: 5.4%;
        z-index: 1;
        background: transparent; /* margins/gaps are frame color via stripPreview bg */
      }

      /* panel card */
      .stripPanel {
        position: relative;
        border-radius: 16px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.06);
        border: 2px solid rgba(255, 255, 255, 0.18);
        box-shadow:
          inset 0 10px 20px rgba(0, 0, 0, 0.28),
          inset 0 -8px 16px rgba(0, 0, 0, 0.18);
      }
      .stripPanel.active {
        outline: 2px solid rgba(255, 255, 255, 0.8);
        outline-offset: 2px;
      }

      .panelNum {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 28px;
        height: 28px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.48);
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font: 900 14px system-ui;
        z-index: 20;
        pointer-events: none;
      }

      /* panel layers */
      .panelBase {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .panelOverlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }
      .panelOverlay .ov {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        pointer-events: auto;
        touch-action: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }
      .panelOverlay .ov.selected {
        outline: 2px solid rgba(255, 255, 255, 0.75);
        outline-offset: 4px;
        border-radius: 12px;
      }
      .panelOverlay .ovText {
        padding: 6px 10px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.16);
        backdrop-filter: blur(6px);
        color: #fff;
        font-family: "BeautifulFreak", system-ui;
        font-size: 44px;
        line-height: 1;
        white-space: pre;
      }

      #builderSide {
        border-radius: 18px;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.35);
        display: flex;
        flex-direction: column;
      }

      #builderSideHead {
        padding: 10px;
        background: rgba(0, 0, 0, 0.45);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      #builderSideHead .label {
        color: #fff;
        font: 900 13px system-ui;
      }

      #builderControls {
        padding: 10px;
        display: grid;
        gap: 10px;
      }

      .pillRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
      }
      .pill {
        border: 0;
        border-radius: 999px;
        padding: 9px 12px;
        background: rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.95);
        font: 900 12px system-ui;
        cursor: pointer;
      }
      .pill.active {
        outline: 2px solid rgba(255, 255, 255, 0.75);
        outline-offset: 2px;
      }

      #builderThumbs {
        flex: 1;
        overflow: auto;
        padding: 10px;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }

      .bThumb {
        border-radius: 12px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.08);
        cursor: pointer;
        position: relative;
      }
      .bThumb img {
        width: 100%;
        display: block;
        height: auto;
      }

      #exportStrip {
        width: calc(100% - 20px);
        margin: 0 10px 10px;
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        background: var(--puff-yellow);
        color: var(--dark-blue);
      }

      /* =========================
         Pose hint
      ========================= */
      #poseHint {
        position: fixed;
        left: 50%;
        top: calc(12px + env(safe-area-inset-top));
        transform: translateX(-50%);
        z-index: 40;
        padding: 10px 12px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.52);
        color: rgba(255, 255, 255, 0.92);
        font: 900 12px system-ui;
        display: none;
        user-select: none;
        pointer-events: none;
        text-align: center;
        max-width: min(92vw, 420px);
      }
    </style>
  </head>

  <body>
    <!-- =========================
         INTRO
    ========================= -->
    <div id="introOverlay">
      <video
        id="introVideo"
        autoplay
        playsinline
        webkit-playsinline
        muted
        preload="auto"
      >
        <!-- Keep types simple; Safari is picky. If webm missing, you can remove it. -->
        <source id="introMp4" src="" type="video/mp4" />
        <source id="introWebm" src="" type="video/webm" />
      </video>

      <img
        id="introClosePuff"
        src="puff-close.png"
        alt="Close intro"
        role="button"
      />

      <button id="exploreBtn" class="hidden" type="button">Explore</button>
    </div>

    <!-- =========================
         MAIN APP
    ========================= -->
    <div id="app" class="hidden">
      <div id="desktopHint">
        Desktop: drag=move • wheel=zoom • Alt/Shift/right-drag=rotate • click=select
      </div>

      <div id="poseHint"></div>

      <video id="camera" autoplay playsinline muted></video>
      <canvas id="cameraFx"></canvas>

      <video
        id="puff"
        autoplay
        playsinline
        webkit-playsinline
        muted
        loop
        preload="auto"
        crossorigin="anonymous"
      ></video>

      <div id="stickerLayer"></div>
      <div id="textLayer"></div>

      <!-- Photobooth capture sidebar -->
      <div id="boothSidebar">
        <div id="boothSidebarCard">
          <div id="boothSidebarHead">
            <div class="label">Captured</div>
            <button id="clearShots" class="secondary" type="button">Clear</button>
          </div>

          <div id="galleryGrid"></div>

          <button id="visualsCue" type="button">Visuals, cue!</button>
        </div>
      </div>

      <div id="ui">
        <div class="ui-row">
          <button id="start">Start AR</button>
          <button id="flip" class="secondary" disabled>Flip Camera</button>
          <button id="mirror" class="secondary" disabled>Mirror: Auto</button>
        </div>

        <div class="ui-row">
          <button id="filterBtn" class="secondary" disabled>Filter</button>
          <button id="boothBtn" class="secondary" disabled>Photobooth: Off</button>

          <button id="stickers" class="secondary" disabled>Sticker</button>
          <button id="textBtn" class="secondary" disabled>Text</button>

          <button id="capture" disabled>Puff It</button>
        </div>
      </div>

      <!-- Sticker panel -->
      <div id="stickerPanel" aria-hidden="true">
        <div class="panelHeader">
          <div class="panelTitle">Choose a sticker</div>
          <button id="stickerClose" class="secondary">Close</button>
        </div>

        <div class="panelBody">
          <div id="stickerGrid"></div>

          <div style="margin-top: 10px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
            <button id="stickerRemove" class="secondary" disabled type="button">Remove selected</button>
            <button id="stickerClear" class="secondary" disabled type="button">Clear all</button>
          </div>
        </div>
      </div>

      <!-- Text panel -->
      <div id="textPanel" aria-hidden="true">
        <div class="panelHeader">
          <div class="panelTitle">Texts (Beautiful Freak)</div>
          <button id="textClose" class="secondary">Close</button>
        </div>

        <div class="panelBody">
          <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
            <button id="addText" class="secondary" type="button">Add Text</button>
            <button id="removeText" class="secondary" type="button" disabled>
              Remove selected
            </button>
            <button id="clearText" class="secondary" type="button" disabled>
              Clear all
            </button>
          </div>

          <div style="margin-top:10px;">
            <div class="fieldLabel">Selected text content</div>
            <input id="textContent" type="text" placeholder="Type your text…" />
          </div>

          <div style="margin-top:10px;">
            <div class="fieldLabel">Text color</div>
            <select id="textColor"></select>
          </div>

          <div style="margin-top:10px;">
            <div class="fieldLabel">Text size</div>
            <input id="textSize" type="range" min="18" max="140" value="44" />
          </div>

          <div style="margin-top:12px;">
            <div
              style="color:rgba(255,255,255,0.82);font:700 12px system-ui;line-height:1.35;text-align:center;"
            >
              Tip: Drag/Pinch/Rotate texts.
            </div>
          </div>
        </div>
      </div>

      <!-- Filter panel -->
      <div id="filterPanel" aria-hidden="true">
        <div class="panelHeader">
          <div class="panelTitle">Choose a filter</div>
          <button id="filterClose" class="secondary">Close</button>
        </div>

        <div class="panelBody">
          <div id="filterList"></div>
        </div>
      </div>

      <!-- (unused) builderPanel bottom sheet placeholder, kept for future -->
      <div id="builderPanel" aria-hidden="true"></div>

      <!-- Strip Builder Modal -->
      <div id="builderModal" aria-hidden="true">
        <div id="builderWrap">
          <div id="builderMain">
            <div id="builderTopbar">
              <div class="title">Strip Builder</div>
              <div class="right">
                <button id="builderSticker" class="secondary" type="button">Sticker</button>
                <button id="builderText" class="secondary" type="button">Text</button>
                <button id="builderDone" class="secondary" type="button">Done</button>
              </div>
            </div>

            <div id="stripStage">
              <div id="stripPreview" aria-label="strip preview">
                <div class="stripBandTop"><img id="stripLogo" alt="logo" /></div>
                <div class="stripBandBottom"></div>
                <div class="stripInner" id="stripInner"></div>
              </div>
            </div>
          </div>

          <div id="builderSide">
            <div id="builderSideHead">
              <div class="label">Frames</div>
              <button id="builderClose" class="secondary" type="button">Close</button>
            </div>

            <div id="builderControls">
              <div class="fieldLabel">Layout</div>
              <div class="pillRow" id="layoutRow"></div>

              <div class="fieldLabel">Frame color</div>
              <div class="pillRow" id="colorRow"></div>

              <div
                style="color:rgba(255,255,255,0.8);font:700 11px system-ui;line-height:1.35;text-align:center;"
              >
                Tap a panel to select it, then tap an image to assign. Use Sticker/Text to edit that panel only.
              </div>
            </div>

            <div id="builderThumbs"></div>

            <button id="exportStrip" type="button">Export strip PNG</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      /* =========================
         CACHE BUSTING
      ========================= */
      const ASSET_VERSION = "29";

      /* =========================
         COLORS / LOGOS
      ========================= */
      const BOOTH_COLORS = [
        { id: "imperialRed", name: "Imperial Red", hex: "#fa213f" },
        { id: "darkBlue", name: "Dark Blue", hex: "#060d3d" },
        { id: "brightGrey", name: "Bright Grey", hex: "#e8eef1" },
        { id: "white", name: "White", hex: "#ffffff" },
      ];

      const TEXT_COLORS = [
        { name: "Imperial Red", hex: "#fa213f" },
        { name: "Dark Blue", hex: "#060d3d" },
        { name: "Bright Grey", hex: "#e8eef1" },
        { name: "Pure White", hex: "#ffffff" },
        { name: "Fluorescent Yellow", hex: "#fff100" },
        { name: "Safety Orange", hex: "#ff7800" },
        { name: "Azure Blue", hex: "#01b7ff" },
        { name: "Vivid Red", hex: "#ff1212" },
      ];

      function logoForBg(bgHex) {
        const c = (bgHex || "").toLowerCase();
        if (c === "#fa213f") return "puff-logo-2.png";
        if (c === "#060d3d") return "puff-logo-3.png";
        return "puff-logo-1.png";
      }

      /* =========================
         FONT LOADING (Canvas)
      ========================= */
      let BEAUTIFUL_FREAK_READY = false;
      (async () => {
        try {
          const ff = new FontFace("BeautifulFreak", "url(BeautifulFreak.otf)");
          await ff.load();
          document.fonts.add(ff);
          await document.fonts.ready;
          BEAUTIFUL_FREAK_READY = true;
        } catch (_) {
          BEAUTIFUL_FREAK_READY = false;
        }
      })();

      /* =========================
         ELEMENTS
      ========================= */
      const cameraEl = document.getElementById("camera");
      const cameraFx = document.getElementById("cameraFx");
      const puffEl = document.getElementById("puff");
      const stickerLayer = document.getElementById("stickerLayer");
      const textLayer = document.getElementById("textLayer");

      const startBtn = document.getElementById("start");
      const flipBtn = document.getElementById("flip");
      const mirrorBtn = document.getElementById("mirror");
      const filterBtn = document.getElementById("filterBtn");
      const boothBtn = document.getElementById("boothBtn");
      const stickersBtn = document.getElementById("stickers");
      const textBtn = document.getElementById("textBtn");
      const captureBtn = document.getElementById("capture");

      const filterPanel = document.getElementById("filterPanel");
      const filterClose = document.getElementById("filterClose");
      const filterListEl = document.getElementById("filterList");

      const stickerPanel = document.getElementById("stickerPanel");
      const stickerGrid = document.getElementById("stickerGrid");
      const stickerClose = document.getElementById("stickerClose");
      const stickerRemove = document.getElementById("stickerRemove");
      const stickerClear = document.getElementById("stickerClear");

      const textPanel = document.getElementById("textPanel");
      const textClose = document.getElementById("textClose");
      const addTextBtn = document.getElementById("addText");
      const removeTextBtn = document.getElementById("removeText");
      const clearTextBtn = document.getElementById("clearText");
      const textContentInput = document.getElementById("textContent");
      const textColorSelect = document.getElementById("textColor");
      const textSizeRange = document.getElementById("textSize");

      const poseHint = document.getElementById("poseHint");

      /* booth sidebar */
      const boothSidebar = document.getElementById("boothSidebar");
      const galleryGrid = document.getElementById("galleryGrid");
      const visualsCueBtn = document.getElementById("visualsCue");
      const clearShotsBtn = document.getElementById("clearShots");

      /* builder modal */
      const builderModal = document.getElementById("builderModal");
      const builderClose = document.getElementById("builderClose");
      const builderDone = document.getElementById("builderDone");
      const builderSticker = document.getElementById("builderSticker");
      const builderText = document.getElementById("builderText");
      const exportStripBtn = document.getElementById("exportStrip");

      const layoutRow = document.getElementById("layoutRow");
      const colorRow = document.getElementById("colorRow");
      const builderThumbs = document.getElementById("builderThumbs");
      const stripPreview = document.getElementById("stripPreview");
      const stripInner = document.getElementById("stripInner");
      const stripLogo = document.getElementById("stripLogo");

      /* =========================
         INTRO LOGIC
      ========================= */
      const introOverlay = document.getElementById("introOverlay");
      const introVideo = document.getElementById("introVideo");
      const exploreBtn = document.getElementById("exploreBtn");
      const closePuff = document.getElementById("introClosePuff");
      const app = document.getElementById("app");
      const introMp4 = document.getElementById("introMp4");
      const introWebm = document.getElementById("introWebm");

      introMp4.src = `intro.mp4?v=${encodeURIComponent(ASSET_VERSION)}`;
      introWebm.src = `intro.webm?v=${encodeURIComponent(ASSET_VERSION)}`;
      introVideo.load();

      let introLoopStarted = false;
      introVideo.addEventListener("ended", async () => {
        if (!introLoopStarted) {
          introLoopStarted = true;
          exploreBtn.classList.remove("hidden");
          introVideo.loop = true;
          try {
            introVideo.currentTime = 0;
            await introVideo.play();
          } catch (_) {}
        }
      });

      const tryPlayIntro = async () => {
        try {
          await introVideo.play();
        } catch (_) {}
        window.removeEventListener("pointerdown", tryPlayIntro, true);
      };
      window.addEventListener("pointerdown", tryPlayIntro, true);

      async function closeIntro() {
        introOverlay.classList.add("hidden");
        app.classList.remove("hidden");
        try {
          await puffEl.play();
        } catch (_) {}
      }
      closePuff.addEventListener("click", closeIntro);
      exploreBtn.addEventListener("click", closeIntro);

      /* =========================
         FILTER PIPELINE (final)
      ========================= */
      const clamp01 = (v) => Math.max(0, Math.min(1, v));
      const clamp255 = (v) => Math.max(0, Math.min(255, v));
      function srgbToLin(c) {
        c /= 255;
        return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      }
      function linToSrgb(c) {
        c = clamp01(c);
        const v =
          c <= 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
        return clamp255(v * 255);
      }
      function lumaLin(rLin, gLin, bLin) {
        return 0.2126 * rLin + 0.7152 * gLin + 0.0722 * bLin;
      }
      function applySaturationLin(r, g, b, sat) {
        const y = lumaLin(r, g, b);
        return [y + (r - y) * sat, y + (g - y) * sat, y + (b - y) * sat];
      }
      function adjustShadowsHighlightsLin(y, shadows, highlights) {
        let out = y;
        if (shadows !== 0) {
          const t = clamp01((0.45 - y) / 0.45);
          out += shadows * t * 0.35;
        }
        if (highlights !== 0) {
          const t = clamp01((y - 0.55) / 0.45);
          out += highlights * t * 0.35;
        }
        return clamp01(out);
      }
      function applyBrillianceLin(y, brilliance) {
        if (brilliance === 0) return y;
        const k = brilliance * 0.55;
        const s = y * y * (3 - 2 * y);
        return clamp01(y + (s - y) * k);
      }
      function applyFadeLin(y, fade) {
        if (!fade) return y;
        const lift = fade * 0.10;
        return clamp01(y * (1 - fade * 0.15) + lift);
      }
      function applyWarmthLin(r, g, b, warmth) {
        if (!warmth) return [r, g, b];
        const w = warmth * 0.10;
        return [r * (1 + w), g, b * (1 - w)];
      }
      function unsharpMask(imageData, amount = 0.35, radius = 1) {
        const { width: w, height: h, data } = imageData;
        const src = new Uint8ClampedArray(data);
        const idx = (x, y) => (y * w + x) * 4;

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let r = 0, g = 0, b = 0, n = 0;
            for (let dy = -radius; dy <= radius; dy++) {
              const yy = y + dy;
              if (yy < 0 || yy >= h) continue;
              for (let dx = -radius; dx <= radius; dx++) {
                const xx = x + dx;
                if (xx < 0 || xx >= w) continue;
                const p = idx(xx, yy);
                r += src[p];
                g += src[p + 1];
                b += src[p + 2];
                n++;
              }
            }
            const p = idx(x, y);
            const br = r / n, bg = g / n, bb = b / n;

            data[p] = clamp255(src[p] + amount * (src[p] - br));
            data[p + 1] = clamp255(src[p + 1] + amount * (src[p + 1] - bg));
            data[p + 2] = clamp255(src[p + 2] + amount * (src[p + 2] - bb));
          }
        }
        return imageData;
      }
      function noiseReduceLight(imageData, strength = 0.15) {
        if (!strength) return imageData;
        const { width: w, height: h, data } = imageData;
        const src = new Uint8ClampedArray(data);
        const idx = (x, y) => (y * w + x) * 4;

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let r = 0, g = 0, b = 0, n = 0;
            for (let dy = -1; dy <= 1; dy++) {
              const yy = y + dy;
              if (yy < 0 || yy >= h) continue;
              for (let dx = -1; dx <= 1; dx++) {
                const xx = x + dx;
                if (xx < 0 || xx >= w) continue;
                const p = idx(xx, yy);
                r += src[p];
                g += src[p + 1];
                b += src[p + 2];
                n++;
              }
            }
            const p = idx(x, y);
            const br = r / n, bg = g / n, bb = b / n;

            data[p] = clamp255(src[p] * (1 - strength) + br * strength);
            data[p + 1] = clamp255(src[p + 1] * (1 - strength) + bg * strength);
            data[p + 2] = clamp255(src[p + 2] * (1 - strength) + bb * strength);
          }
        }
        return imageData;
      }

      function recipe(params) {
        return {
          exposure: (params.exposure || 0) / 100,
          brilliance: (params.brilliance || 0) / 100,
          highlights: (params.highlights || 0) / 100,
          shadows: (params.shadows || 0) / 100,
          brightness: (params.brightness || 0) / 100,
          contrast: (params.contrast || 0) / 100,
          saturation: (params.saturation || 0) / 100,
          warmth: (params.warmth || 0) / 100,
          fade: (params.fade || 0) / 100,
          sharpness: (params.sharpness || 0) / 100,
          noiseReduce: (params.noiseReduce || 0) / 100,
        };
      }

      const FILTERS = [
        { id: "none", name: "None", recipe: recipe({}) },
        {
          id: "35mm04",
          name: "35mm 04",
          recipe: recipe({
            exposure: -5, brilliance: -10, highlights: -30, shadows: +18,
            brightness: -10, contrast: -8, saturation: -6, warmth: -6,
            fade: +12, sharpness: -5, noiseReduce: +8,
          }),
        },
        {
          id: "vi4",
          name: "VI4",
          recipe: recipe({
            exposure: +10, brilliance: +18, highlights: -35, shadows: +14,
            brightness: +6, contrast: -6, saturation: +10, warmth: +10,
            fade: +10, sharpness: +6, noiseReduce: +10,
          }),
        },
        {
          id: "cm1",
          name: "CM1",
          recipe: recipe({
            exposure: +8, brilliance: +22, highlights: -25, shadows: +12,
            brightness: +4, contrast: -4, saturation: +12, warmth: +6,
            fade: +6, sharpness: +10, noiseReduce: +8,
          }),
        },
        {
          id: "sapa",
          name: "Sapa",
          recipe: recipe({
            exposure: +12, brilliance: +10, highlights: -22, shadows: +18,
            brightness: +8, contrast: -10, saturation: +6, warmth: -10,
            fade: +16, sharpness: +6, noiseReduce: +10,
          }),
        },
        {
          id: "salt",
          name: "Salt",
          recipe: recipe({
            exposure: +18, brilliance: +18, highlights: -40, shadows: +10,
            brightness: +10, contrast: -8, saturation: +14, warmth: +14,
            fade: +8, sharpness: +8, noiseReduce: +8,
          }),
        },
        {
          id: "in2",
          name: "IN2",
          recipe: recipe({
            exposure: +10, brilliance: +8, highlights: -30, shadows: +16,
            brightness: +4, contrast: -12, saturation: -4, warmth: -8,
            fade: +18, sharpness: +6, noiseReduce: +12,
          }),
        },
        {
          id: "fl2",
          name: "FL2",
          recipe: recipe({
            exposure: +14, brilliance: +14, highlights: -28, shadows: +10,
            brightness: +8, contrast: -6, saturation: +10, warmth: +8,
            fade: +10, sharpness: +8, noiseReduce: +10,
          }),
        },
        {
          id: "bwfilm",
          name: "B&W Film",
          recipe: recipe({
            exposure: +6, brilliance: +10, highlights: -20, shadows: +10,
            brightness: +4, contrast: +10, saturation: -100, fade: +8,
            sharpness: +10, noiseReduce: +10,
          }),
        },
      ];

      let currentFilterId = "none";
      let currentRecipe = FILTERS[0].recipe;

      function applyRecipeToImageData(imageData, r) {
        const d = imageData.data;
        const sat = 1 + r.saturation * 0.9;
        const exposureGain = Math.pow(2, r.exposure);
        const brightnessGain = 1 + r.brightness * 0.35;
        const contrastGain = 1 + r.contrast * 0.6;

        for (let i = 0; i < d.length; i += 4) {
          let rLin = srgbToLin(d[i]);
          let gLin = srgbToLin(d[i + 1]);
          let bLin = srgbToLin(d[i + 2]);

          [rLin, gLin, bLin] = applyWarmthLin(rLin, gLin, bLin, r.warmth);

          rLin *= exposureGain * brightnessGain;
          gLin *= exposureGain * brightnessGain;
          bLin *= exposureGain * brightnessGain;

          let y = lumaLin(rLin, gLin, bLin);
          y = applyBrillianceLin(y, r.brilliance);
          y = adjustShadowsHighlightsLin(y, r.shadows, r.highlights);

          const y0 = Math.max(1e-6, lumaLin(rLin, gLin, bLin));
          const sc = y / y0;
          rLin *= sc;
          gLin *= sc;
          bLin *= sc;

          [rLin, gLin, bLin] = applySaturationLin(rLin, gLin, bLin, sat);

          const pivot = 0.18;
          rLin = (rLin - pivot) * contrastGain + pivot;
          gLin = (gLin - pivot) * contrastGain + pivot;
          bLin = (bLin - pivot) * contrastGain + pivot;

          const yFade = applyFadeLin(lumaLin(rLin, gLin, bLin), r.fade);
          const yNow = Math.max(1e-6, lumaLin(rLin, gLin, bLin));
          const s2 = yFade / yNow;
          rLin *= s2;
          gLin *= s2;
          bLin *= s2;

          d[i] = linToSrgb(rLin);
          d[i + 1] = linToSrgb(gLin);
          d[i + 2] = linToSrgb(bLin);
        }

        if (r.noiseReduce > 0.01)
          noiseReduceLight(imageData, clamp01(r.noiseReduce * 0.35));
        if (r.sharpness > 0.01)
          unsharpMask(imageData, clamp01(r.sharpness * 0.55), 1);

        return imageData;
      }

      /* =========================
         Filter preview (canvas, throttled)
      ========================= */
      let fxRunning = false;
      let fxRaf = null;
      let fxLast = 0;

      function stopFx() {
        fxRunning = false;
        if (fxRaf) cancelAnimationFrame(fxRaf);
        fxRaf = null;
        cameraFx.style.display = "none";
        cameraEl.style.visibility = "visible";
      }

      function startFx() {
        if (fxRunning) return;
        fxRunning = true;
        cameraFx.style.display = "block";
        cameraEl.style.visibility = "hidden";

        const ctx = cameraFx.getContext("2d", { willReadFrequently: true });

        const tick = (t) => {
          if (!fxRunning) return;

          if (t - fxLast < 66) {
            fxRaf = requestAnimationFrame(tick);
            return;
          }
          fxLast = t;

          if (!cameraEl.videoWidth || !cameraEl.videoHeight) {
            fxRaf = requestAnimationFrame(tick);
            return;
          }

          const maxW = 900; // perf
          const vw = cameraEl.videoWidth;
          const vh = cameraEl.videoHeight;
          const s = Math.min(1, maxW / vw);
          const rw = Math.max(2, Math.floor(vw * s));
          const rh = Math.max(2, Math.floor(vh * s));

          if (cameraFx.width !== rw || cameraFx.height !== rh) {
            cameraFx.width = rw;
            cameraFx.height = rh;
          }

          ctx.drawImage(cameraEl, 0, 0, rw, rh);
          if (currentFilterId !== "none") {
            const img = ctx.getImageData(0, 0, rw, rh);
            applyRecipeToImageData(img, currentRecipe);
            ctx.putImageData(img, 0, 0);
          }

          fxRaf = requestAnimationFrame(tick);
        };

        fxRaf = requestAnimationFrame(tick);
      }

      function applyCameraFilterPreview() {
        if (currentFilterId === "none") stopFx();
        else startFx();
      }

      function openPanel(el) {
        el.classList.add("open");
        el.setAttribute("aria-hidden", "false");
      }
      function closePanel(el) {
        el.classList.remove("open");
        el.setAttribute("aria-hidden", "true");
      }

      function openFilterPanel() { openPanel(filterPanel); }
      function closeFilterPanel() { closePanel(filterPanel); }

      function renderFilters() {
        filterListEl.innerHTML = "";
        FILTERS.forEach((f) => {
          const b = document.createElement("button");
          b.className = "filterItem" + (f.id === currentFilterId ? " active" : "");
          b.type = "button";
          const r = f.recipe;
          const recLine =
            f.id === "none"
              ? "no recipe"
              : `exp ${Math.round(r.exposure * 100)} • hi ${Math.round(
                  r.highlights * 100
                )} • sh ${Math.round(r.shadows * 100)} • sat ${Math.round(
                  r.saturation * 100
                )}`;
          b.innerHTML = `${f.name}<span class="sub">${recLine}</span>`;
          b.addEventListener("click", () => {
            currentFilterId = f.id;
            currentRecipe = f.recipe;
            applyCameraFilterPreview();
            renderFilters();
            closeFilterPanel();
          });
          filterListEl.appendChild(b);
        });
      }
      renderFilters();

      filterBtn.addEventListener("click", () => {
        if (filterBtn.disabled) return;
        openFilterPanel();
      });
      filterClose.addEventListener("click", closeFilterPanel);

      /* =========================
         PUFF RANDOM (3 videos)
      ========================= */
      const puffBases = ["puff", "puff2", "puff3"];
      const chosenBase = puffBases[Math.floor(Math.random() * puffBases.length)];

      function isAppleSafari() {
        const ua = navigator.userAgent;
        const isIOS =
          /iPad|iPhone|iPod/.test(ua) ||
          (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const isSafari =
          /Safari/.test(ua) && !/Chrome|CriOS|Edg|OPR|Firefox/.test(ua);
        return isIOS || isSafari;
      }

      function setPuffSource(base) {
        const v = `v=${encodeURIComponent(ASSET_VERSION)}`;
        if (isAppleSafari()) {
          puffEl.innerHTML = `
            <source src="${base}.mov?${v}" type='video/quicktime; codecs="hvc1"'>
            <source src="${base}.mp4?${v}" type='video/mp4; codecs="hvc1"'>
          `;
        } else {
          puffEl.innerHTML = `
            <source src="${base}.webm?${v}" type='video/webm; codecs="vp09.00.10.08"'>
            <source src="${base}.webm?${v}" type="video/webm">
          `;
        }
        puffEl.load();
      }

      puffEl.setAttribute("playsinline", "");
      puffEl.setAttribute("webkit-playsinline", "");
      puffEl.muted = true;
      puffEl.crossOrigin = "anonymous";
      setPuffSource(chosenBase);

      /* =========================
         CAMERA + MIRROR
      ========================= */
      let currentFacingMode = "environment";
      let stream = null;
      let mirrorMode = "auto";

      function shouldMirrorPreview() {
        return (
          mirrorMode === "on" ||
          (mirrorMode === "auto" && currentFacingMode === "user")
        );
      }

      function applyMirrorToPreview() {
        cameraEl.classList.toggle("mirror", shouldMirrorPreview());
        cameraFx.classList.toggle("mirror", shouldMirrorPreview());
        mirrorBtn.textContent =
          mirrorMode === "auto"
            ? "Mirror: Auto"
            : mirrorMode === "on"
            ? "Mirror: On"
            : "Mirror: Off";
      }

      function waitLoadedMetadata(videoEl, timeoutMs = 6000) {
        return new Promise((resolve, reject) => {
          if (videoEl.readyState >= 1 && videoEl.videoWidth > 0) return resolve();
          const t = setTimeout(() => {
            cleanup();
            reject(new Error("metadata timeout"));
          }, timeoutMs);
          const onMeta = () => {
            cleanup();
            resolve();
          };
          const cleanup = () => {
            clearTimeout(t);
            videoEl.removeEventListener("loadedmetadata", onMeta);
          };
          videoEl.addEventListener("loadedmetadata", onMeta, { once: true });
        });
      }

      async function startCamera() {
        captureBtn.disabled = true;
        boothBtn.disabled = true;
        mirrorBtn.disabled = true;
        filterBtn.disabled = true;
        stickersBtn.disabled = true;
        textBtn.disabled = true;

        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }

        stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: currentFacingMode },
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        });

        cameraEl.srcObject = stream;

        await waitLoadedMetadata(cameraEl).catch(() => {});
        await cameraEl.play().catch(() => {});

        await waitLoadedMetadata(puffEl).catch(() => {});
        await puffEl.play().catch(() => {});

        flipBtn.disabled = false;
        captureBtn.disabled = false;
        boothBtn.disabled = false;
        mirrorBtn.disabled = false;
        filterBtn.disabled = false;
        stickersBtn.disabled = false; // always usable when running
        textBtn.disabled = false; // always usable when running

        applyMirrorToPreview();
        applyCameraFilterPreview();

        startBtn.textContent = "AR Running";
        startBtn.disabled = true;
      }

      startBtn.addEventListener("click", async () => {
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
          alert("Could not access camera. Please allow permission and use HTTPS.");
        }
      });

      flipBtn.addEventListener("click", async () => {
        currentFacingMode =
          currentFacingMode === "environment" ? "user" : "environment";
        startBtn.disabled = false;
        startBtn.textContent = "Restart AR";
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
        }
      });

      mirrorBtn.addEventListener("click", () => {
        mirrorMode =
          mirrorMode === "auto" ? "on" : mirrorMode === "on" ? "off" : "auto";
        applyMirrorToPreview();
      });

      /* =========================
         TRANSFORM HELPERS (NO INERTIA)
      ========================= */
      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }
      function dist(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }
      function angleDeg(a, b) {
        return (Math.atan2(b.y - a.y, b.x - a.x) * 180) / Math.PI;
      }

      function applyTransform(el, state) {
        el.style.left = state.x + "%";
        el.style.top = state.y + "%";
        el.style.transform = `translate(-50%, -50%) scale(${state.scale}) rotate(${state.rotation}deg)`;
      }

      /**
       * Make element transformable within a bounds provider (live screen or a panel)
       * - boundsProvider returns { w, h } in px for pointer delta normalization
       */
      function makeTransformable(el, state, onUpdate, boundsProvider) {
        const pointers = new Map();
        let gestureStart = null;
        let dragStart = null;

        el.addEventListener("contextmenu", (e) => e.preventDefault());

        el.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          el.setPointerCapture?.(e.pointerId);
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          const isRightButtonRotate =
            e.pointerType === "mouse" && (e.buttons === 2 || e.button === 2);

          if (pointers.size === 1) {
            const { w, h } = boundsProvider ? boundsProvider() : { w: innerWidth, h: innerHeight };
            dragStart = {
              x: e.clientX,
              y: e.clientY,
              baseX: state.x,
              baseY: state.y,
              w,
              h,
              rotating: !!e.altKey || !!e.shiftKey || isRightButtonRotate,
              baseRotation: state.rotation,
            };
            gestureStart = null;
          } else if (pointers.size === 2) {
            const pts = Array.from(pointers.values());
            const a = pts[0], b = pts[1];
            const ang = angleDeg(a, b);
            gestureStart = {
              distance: dist(a, b),
              angle: ang,
              scale: state.scale,
              rotation: state.rotation,
            };
            dragStart = null;
          }
        });

        el.addEventListener("pointermove", (e) => {
          if (!pointers.has(e.pointerId)) return;
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          if (pointers.size === 1 && dragStart) {
            const dx = ((e.clientX - dragStart.x) / dragStart.w) * 100;
            const dy = ((e.clientY - dragStart.y) / dragStart.h) * 100;

            if (dragStart.rotating) {
              state.rotation = dragStart.baseRotation + dx * 2.2;
            } else {
              state.x = clamp(dragStart.baseX + dx, 0, 100);
              state.y = clamp(dragStart.baseY + dy, 0, 100);
            }
            onUpdate();
          }

          if (pointers.size === 2 && gestureStart) {
            const pts = Array.from(pointers.values());
            const a = pts[0], b = pts[1];
            const newDistance = dist(a, b);
            const newAngle = angleDeg(a, b);

            state.scale = clamp(
              gestureStart.scale * (newDistance / gestureStart.distance),
              0.2,
              6
            );
            state.rotation =
              gestureStart.rotation + (newAngle - gestureStart.angle);

            onUpdate();
          }
        });

        el.addEventListener("pointerup", () => {
          pointers.clear();
          dragStart = null;
          gestureStart = null;
        });

        el.addEventListener("pointercancel", () => {
          pointers.clear();
          dragStart = null;
          gestureStart = null;
        });

        el.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.92 : 1.08;
            state.scale = clamp(state.scale * factor, 0.2, 6);
            onUpdate();
          },
          { passive: false }
        );
      }

      /* =========================
         LIVE PUFF transform
      ========================= */
      const puffState = { x: 50, y: 72, scale: 1.55, rotation: 0 };
      function updatePuff() { applyTransform(puffEl, puffState); }
      updatePuff();
      makeTransformable(puffEl, puffState, updatePuff, () => ({ w: innerWidth, h: innerHeight }));

      /* =========================
         LIVE STICKERS
      ========================= */
      let stickersLoaded = false;
      const liveStickerStates = new Map(); // el -> state
      let selectedStickerEl = null;

      function setSelectedSticker(el) {
        if (selectedStickerEl && selectedStickerEl !== el) {
          selectedStickerEl.classList.remove("selected");
        }
        selectedStickerEl = el;
        if (selectedStickerEl) selectedStickerEl.classList.add("selected");

        stickerRemove.disabled = !selectedStickerEl;
        stickerClear.disabled = liveStickerStates.size === 0;
      }

      function createLiveSticker(src) {
        const el = document.createElement("img");
        el.className = "sticker";
        el.alt = "sticker";
        el.crossOrigin = "anonymous";
        el.src = src;
        el.style.pointerEvents = "auto";
        stickerLayer.appendChild(el);

        const state = { x: 50, y: 40, scale: 1.0, rotation: 0 };
        liveStickerStates.set(el, state);

        function update() { applyTransform(el, state); }
        update();

        el.addEventListener("pointerdown", () => setSelectedSticker(el), true);
        el.addEventListener("click", () => setSelectedSticker(el));

        makeTransformable(el, state, update, () => ({ w: innerWidth, h: innerHeight }));

        setSelectedSticker(el);
        stickerClear.disabled = liveStickerStates.size === 0;
      }

      function openStickerPanel() {
        openPanel(stickerPanel);
        if (!stickersLoaded) loadStickers();
      }
      function closeStickerPanel() { closePanel(stickerPanel); }

      stickersBtn.addEventListener("click", () => {
        if (stickersBtn.disabled) return;
        openStickerPanel();
      });
      stickerClose.addEventListener("click", closeStickerPanel);

      stickerRemove.addEventListener("click", () => {
        // remove selected in current edit context (live or panel)
        if (editContext.mode === "panel") {
          removeSelectedPanelOverlay();
          return;
        }
        if (!selectedStickerEl) return;
        liveStickerStates.delete(selectedStickerEl);
        selectedStickerEl.remove();
        selectedStickerEl = null;

        const last = Array.from(liveStickerStates.keys()).pop() || null;
        setSelectedSticker(last);

        stickerClear.disabled = liveStickerStates.size === 0;
      });

      stickerClear.addEventListener("click", () => {
        if (editContext.mode === "panel") {
          clearPanelStickers();
          return;
        }
        for (const el of liveStickerStates.keys()) el.remove();
        liveStickerStates.clear();
        setSelectedSticker(null);
        stickerClear.disabled = true;
      });

      async function loadStickers() {
        try {
          const res = await fetch(`./stickers.json?v=${encodeURIComponent(ASSET_VERSION)}`);
          const list = await res.json();
          stickersLoaded = true;

          stickerGrid.innerHTML = "";
          list.forEach((item) => {
            const cell = document.createElement("button");
            cell.className = "stickerItem";
            cell.type = "button";

            const img = document.createElement("img");
            img.loading = "lazy";
            img.alt = item.name || item.id || "sticker";
            const encodedSrc = encodeURI(item.src);
            img.src = `${encodedSrc}?v=${encodeURIComponent(ASSET_VERSION)}`;
            img.crossOrigin = "anonymous";

            cell.appendChild(img);

            cell.addEventListener("click", () => {
              // add sticker to live OR selected panel
              if (editContext.mode === "panel") {
                addStickerToPanel(editContext.panelId, img.src);
              } else {
                createLiveSticker(img.src);
              }
              closeStickerPanel();
            });

            stickerGrid.appendChild(cell);
          });
        } catch (e) {
          console.error(e);
          stickerGrid.innerHTML =
            `<div style="color:#fff;font:700 12px system-ui;opacity:.9">
              Could not load stickers.json. Check ./stickers.json is deployed.
            </div>`;
        }
      }

      document.addEventListener("pointerdown", (e) => {
        const isSticker =
          e.target &&
          e.target.classList &&
          e.target.classList.contains("sticker");
        const clickedPanel = stickerPanel.contains(e.target);
        const clickedFilter = filterPanel.contains(e.target);
        const clickedUI = document.getElementById("ui").contains(e.target);
        const clickedPuff = e.target === puffEl;
        const clickedText =
          e.target && e.target.classList && e.target.classList.contains("textItem");

        if (!isSticker && !clickedPanel && !clickedFilter && !clickedUI && !clickedPuff && !clickedText) {
          if (selectedStickerEl) selectedStickerEl.classList.remove("selected");
          selectedStickerEl = null;
          stickerRemove.disabled = true;
          stickerClear.disabled = liveStickerStates.size === 0;

          if (selectedTextEl) selectedTextEl.classList.remove("selected");
          selectedTextEl = null;
          removeTextBtn.disabled = true;
          clearTextBtn.disabled = liveTextStates.size === 0;
        }
      });

      /* =========================
         LIVE TEXTS
      ========================= */
      // fill color select
      TEXT_COLORS.forEach((c) => {
        const opt = document.createElement("option");
        opt.value = c.hex;
        opt.textContent = c.name;
        textColorSelect.appendChild(opt);
      });

      const liveTextStates = new Map(); // el -> {x,y,scale,rotation,color,size,content}
      let selectedTextEl = null;

      function setSelectedText(el) {
        if (selectedTextEl && selectedTextEl !== el) selectedTextEl.classList.remove("selected");
        selectedTextEl = el;
        if (selectedTextEl) selectedTextEl.classList.add("selected");

        removeTextBtn.disabled = !selectedTextEl;
        clearTextBtn.disabled = liveTextStates.size === 0;

        if (selectedTextEl) {
          const st = liveTextStates.get(selectedTextEl);
          textContentInput.value = st.content || "";
          textColorSelect.value = st.color || "#ffffff";
          textSizeRange.value = String(st.size || 44);
        }
      }

      function createLiveText(initial = "Hello") {
        const el = document.createElement("div");
        el.className = "textItem";
        el.textContent = initial;
        textLayer.appendChild(el);

        const st = {
          x: 50,
          y: 30,
          scale: 1,
          rotation: 0,
          color: "#ffffff",
          size: 44,
          content: initial,
        };
        liveTextStates.set(el, st);

        function update() {
          el.style.color = st.color;
          el.style.fontSize = st.size + "px";
          applyTransform(el, st);
        }
        update();

        el.addEventListener("pointerdown", () => setSelectedText(el), true);
        el.addEventListener("click", () => setSelectedText(el));

        makeTransformable(el, st, update, () => ({ w: innerWidth, h: innerHeight }));

        setSelectedText(el);
        clearTextBtn.disabled = liveTextStates.size === 0;
      }

      function openTextPanel() { openPanel(textPanel); }
      function closeTextPanel() { closePanel(textPanel); }

      textBtn.addEventListener("click", () => {
        if (textBtn.disabled) return;
        openTextPanel();
      });
      textClose.addEventListener("click", closeTextPanel);

      addTextBtn.addEventListener("click", () => {
        if (editContext.mode === "panel") {
          addTextToPanel(editContext.panelId, "Hello");
          return;
        }
        createLiveText("Hello");
      });

      removeTextBtn.addEventListener("click", () => {
        if (editContext.mode === "panel") {
          removeSelectedPanelOverlay();
          return;
        }
        if (!selectedTextEl) return;
        liveTextStates.delete(selectedTextEl);
        selectedTextEl.remove();
        selectedTextEl = null;
        removeTextBtn.disabled = true;
        clearTextBtn.disabled = liveTextStates.size === 0;
      });

      clearTextBtn.addEventListener("click", () => {
        if (editContext.mode === "panel") {
          clearPanelTexts();
          return;
        }
        for (const el of liveTextStates.keys()) el.remove();
        liveTextStates.clear();
        selectedTextEl = null;
        removeTextBtn.disabled = true;
        clearTextBtn.disabled = true;
      });

      textContentInput.addEventListener("input", () => {
        if (editContext.mode === "panel") {
          updateSelectedPanelTextContent(textContentInput.value);
          return;
        }
        if (!selectedTextEl) return;
        const st = liveTextStates.get(selectedTextEl);
        st.content = textContentInput.value;
        selectedTextEl.textContent = st.content;
      });

      textColorSelect.addEventListener("change", () => {
        if (editContext.mode === "panel") {
          updateSelectedPanelTextColor(textColorSelect.value);
          return;
        }
        if (!selectedTextEl) return;
        const st = liveTextStates.get(selectedTextEl);
        st.color = textColorSelect.value;
        selectedTextEl.style.color = st.color;
      });

      textSizeRange.addEventListener("input", () => {
        const v = parseInt(textSizeRange.value, 10) || 44;
        if (editContext.mode === "panel") {
          updateSelectedPanelTextSize(v);
          return;
        }
        if (!selectedTextEl) return;
        const st = liveTextStates.get(selectedTextEl);
        st.size = v;
        selectedTextEl.style.fontSize = st.size + "px";
      });

      /* =========================
         PHOTOBOOTH MODE (capture list) - Option B
         We capture a STILL composite (camera + puff frame + stickers + texts),
         and store overlay state too (per your Option B).
         BUT: in builder, Puff is always an IMAGE (captured frame) -> NO duplicate video.
      ========================= */
      let photoboothOn = false;

      /**
       * Each shot:
       * {
       *   id, createdAt,
       *   baseDataUrl: camera frame (full output size),
       *   puffFrameUrl: a still image of puff at capture time,
       *   puffState: {x,y,scale,rotation},
       *   stickers: [{src, state:{x,y,scale,rotation}}],
       *   texts: [{content,color,size, state:{x,y,scale,rotation}}],
       *   compositeThumbUrl: small preview (optional)
       * }
       */
      const shots = [];

      function setPhotobooth(on) {
        photoboothOn = !!on;
        boothBtn.textContent = photoboothOn ? "Photobooth: On" : "Photobooth: Off";
        boothSidebar.classList.toggle("open", photoboothOn);
      }

      boothBtn.addEventListener("click", () => {
        if (boothBtn.disabled) return;
        setPhotobooth(!photoboothOn);
      });

      clearShotsBtn.addEventListener("click", () => {
        shots.length = 0;
        renderGallery();
      });

      function renderGallery() {
        galleryGrid.innerHTML = "";
        shots.forEach((s, idx) => {
          const cell = document.createElement("div");
          cell.className = "shotThumb";
          cell.dataset.id = s.id;

          const img = document.createElement("img");
          img.src = s.compositeThumbUrl || s.baseDataUrl;
          img.alt = "shot";
          cell.appendChild(img);

          const n = document.createElement("div");
          n.className = "n";
          n.textContent = String(idx + 1);
          cell.appendChild(n);

          galleryGrid.appendChild(cell);
        });
      }

      /* =========================
         CAPTURE HELPERS
      ========================= */
      function nextCaptureFilename(prefix = "Puff Dragon_HPNY2026") {
        const key = "puff_capture_counter";
        const current = parseInt(localStorage.getItem(key) || "0", 10) + 1;
        localStorage.setItem(key, String(current));
        const num = String(current).padStart(3, "0");
        return `${prefix}_${num}.png`;
      }

      function getCoverTransform(srcW, srcH, dstW, dstH) {
        const scale = Math.max(dstW / srcW, dstH / srcH);
        const drawW = srcW * scale;
        const drawH = srcH * scale;
        const offsetX = (dstW - drawW) / 2;
        const offsetY = (dstH - drawH) / 2;
        return { scale, drawW, drawH, offsetX, offsetY };
      }

      function computeDrawRect(domRect, camRect, cover, aspectW, aspectH) {
        const centerX_screen = domRect.left + domRect.width / 2 - camRect.left;
        const centerY_screen = domRect.top + domRect.height / 2 - camRect.top;

        const centerX_cam = (centerX_screen - cover.offsetX) / cover.scale;
        const centerY_cam = (centerY_screen - cover.offsetY) / cover.scale;

        const w_cam = domRect.width / cover.scale;
        const h_cam = domRect.height / cover.scale;

        const ar = aspectW && aspectH ? aspectW / aspectH : domRect.width / domRect.height;

        let drawW = w_cam;
        let drawH = drawW / ar;
        if (drawH > h_cam) {
          drawH = h_cam;
          drawW = drawH * ar;
        }
        return { centerX_cam, centerY_cam, drawW, drawH };
      }

      function mirrorX(xCam, outW, mirrorOutput) {
        return mirrorOutput ? outW - xCam : xCam;
      }

      function captureLiveToCanvas(outW, outH) {
        const out = document.createElement("canvas");
        out.width = outW;
        out.height = outH;
        const ctx = out.getContext("2d", { willReadFrequently: true });

        const camRect = cameraEl.getBoundingClientRect();
        const cover = getCoverTransform(outW, outH, camRect.width, camRect.height);

        const mirrorOutput = shouldMirrorPreview();

        // camera
        ctx.save();
        if (mirrorOutput) {
          ctx.translate(outW, 0);
          ctx.scale(-1, 1);
        }
        ctx.drawImage(cameraEl, 0, 0, outW, outH);
        ctx.restore();

        // final filter (apply to full output)
        if (currentFilterId !== "none") {
          const imgData = ctx.getImageData(0, 0, outW, outH);
          applyRecipeToImageData(imgData, currentRecipe);
          ctx.putImageData(imgData, 0, 0);
        }

        // puff
        const puffRect = puffEl.getBoundingClientRect();
        const puffDraw = computeDrawRect(puffRect, camRect, cover, puffEl.videoWidth, puffEl.videoHeight);

        ctx.save();
        ctx.translate(mirrorX(puffDraw.centerX_cam, outW, mirrorOutput), puffDraw.centerY_cam);
        const puffRotation = mirrorOutput ? -puffState.rotation : puffState.rotation;
        ctx.rotate((puffRotation * Math.PI) / 180);
        ctx.drawImage(
          puffEl,
          -puffDraw.drawW / 2,
          -puffDraw.drawH / 2,
          puffDraw.drawW,
          puffDraw.drawH
        );
        ctx.restore();

        // stickers
        for (const [el, st] of liveStickerStates.entries()) {
          if (!el.complete || !el.naturalWidth) continue;
          const r = el.getBoundingClientRect();
          const d = computeDrawRect(r, camRect, cover, el.naturalWidth, el.naturalHeight);

          ctx.save();
          ctx.translate(mirrorX(d.centerX_cam, outW, mirrorOutput), d.centerY_cam);
          const stickerRotation = mirrorOutput ? -st.rotation : st.rotation;
          ctx.rotate((stickerRotation * Math.PI) / 180);
          ctx.drawImage(el, -d.drawW / 2, -d.drawH / 2, d.drawW, d.drawH);
          ctx.restore();
        }

        // texts
        // We draw text onto canvas (BeautifulFreak if loaded; else fallback)
        ctx.save();
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        for (const [el, st] of liveTextStates.entries()) {
          const r = el.getBoundingClientRect();
          const d = computeDrawRect(r, camRect, cover, 1, 1);

          const fontFamily = BEAUTIFUL_FREAK_READY ? "BeautifulFreak" : "system-ui";
          const fontPx = (st.size || 44) * (r.width / el.offsetWidth || 1);
          ctx.font = `${Math.round(fontPx)}px ${fontFamily}`;
          ctx.fillStyle = st.color || "#ffffff";

          ctx.save();
          ctx.translate(mirrorX(d.centerX_cam, outW, mirrorOutput), d.centerY_cam);
          const rot = mirrorOutput ? -st.rotation : st.rotation;
          ctx.rotate((rot * Math.PI) / 180);
          ctx.scale(st.scale || 1, st.scale || 1);
          // split lines
          const lines = String(st.content || "").split("\n");
          const lh = fontPx * 1.05;
          const totalH = lh * lines.length;
          lines.forEach((line, i) => {
            const yy = (i * lh) - totalH / 2 + lh / 2;
            ctx.fillText(line, 0, yy);
          });
          ctx.restore();
        }
        ctx.restore();

        return out;
      }

      function capturePuffFrameDataUrl() {
        // capture a still image of puff video at current frame (no extra video playback later)
        try {
          const w = Math.max(2, puffEl.videoWidth || 512);
          const h = Math.max(2, puffEl.videoHeight || 512);
          const c = document.createElement("canvas");
          c.width = w;
          c.height = h;
          const ctx = c.getContext("2d");
          ctx.drawImage(puffEl, 0, 0, w, h);
          return c.toDataURL("image/png");
        } catch (_) {
          return null;
        }
      }

      function snapshotLiveOverlayState() {
        // copy states (numbers only)
        const stickers = [];
        for (const [el, st] of liveStickerStates.entries()) {
          stickers.push({
            src: el.src,
            state: { x: st.x, y: st.y, scale: st.scale, rotation: st.rotation },
          });
        }

        const texts = [];
        for (const [el, st] of liveTextStates.entries()) {
          texts.push({
            content: st.content || "",
            color: st.color || "#ffffff",
            size: st.size || 44,
            state: { x: st.x, y: st.y, scale: st.scale, rotation: st.rotation },
          });
        }

        return {
          puffState: { x: puffState.x, y: puffState.y, scale: puffState.scale, rotation: puffState.rotation },
          stickers,
          texts,
        };
      }

      captureBtn.addEventListener("click", async () => {
        try {
          if (!stream || !cameraEl.videoWidth || !cameraEl.videoHeight) {
            alert("Start AR first.");
            return;
          }

          // Output size: use camera native for best quality
          const outW = cameraEl.videoWidth;
          const outH = cameraEl.videoHeight;

          const outCanvas = captureLiveToCanvas(outW, outH);
          const baseDataUrl = outCanvas.toDataURL("image/png");

          // thumb for UI
          const thumbW = 520;
          const s = Math.min(1, thumbW / outW);
          const tc = document.createElement("canvas");
          tc.width = Math.max(2, Math.floor(outW * s));
          tc.height = Math.max(2, Math.floor(outH * s));
          tc.getContext("2d").drawImage(outCanvas, 0, 0, tc.width, tc.height);
          const thumbUrl = tc.toDataURL("image/png");

          const puffFrameUrl = capturePuffFrameDataUrl();
          const overlayState = snapshotLiveOverlayState();

          if (photoboothOn) {
            const shot = {
              id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + Math.random(),
              createdAt: Date.now(),
              baseDataUrl,
              compositeThumbUrl: thumbUrl,
              puffFrameUrl,
              puffState: overlayState.puffState,
              stickers: overlayState.stickers,
              texts: overlayState.texts,
            };
            shots.push(shot);
            renderGallery();
            // small hint
            poseHint.textContent = `Captured (${shots.length})`;
            poseHint.style.display = "block";
            clearTimeout(poseHint._t);
            poseHint._t = setTimeout(() => (poseHint.style.display = "none"), 800);
            return;
          }

          // Normal mode: open in new tab with download
          const win = window.open("about:blank", "_blank");
          if (!win) {
            alert("Popup blocked. Please allow popups for this site.");
            return;
          }
          const filename = nextCaptureFilename();
          win.document.write(`
            <title>${filename}</title>
            <div style="margin:0;background:#000;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:18px;">
              <img src="${baseDataUrl}" style="max-width:100%;height:auto;display:block;" />
              <a
                href="${baseDataUrl}"
                download="${filename}"
                style="display:inline-block;padding:10px 14px;border-radius:12px;background:#fff100;color:#060d3d;font:900 14px system-ui;text-decoration:none"
              >
                Download (${filename})
              </a>
            </div>
          `);
          win.document.close();
        } catch (err) {
          console.error(err);
          alert("Capture failed. Try again.");
        }
      });

      /* =========================
         Photobooth: "Visuals, cue!" => open builder
      ========================= */
      visualsCueBtn.addEventListener("click", () => {
        if (!shots.length) {
          alert("No captured images yet. Take some photos first.");
          return;
        }
        openBuilder();
      });

      /* =========================
         STRIP BUILDER (Option B editing per panel)
      ========================= */
      // layouts: define panel count + grid and aspect ratio for the whole strip
      const LAYOUTS = [
        { id: "one", name: "1 Photo", panels: 1, aspect: 2 / 3, grid: { cols: 1, rows: 1 } },
        { id: "3v", name: "3 Vertical", panels: 3, aspect: 2 / 3, grid: { cols: 1, rows: 3 } },
        { id: "3h", name: "3 Horizontal", panels: 3, aspect: 3 / 2, grid: { cols: 3, rows: 1 } },
        { id: "4g", name: "4 Grid", panels: 4, aspect: 2 / 3, grid: { cols: 2, rows: 2 } },
      ];

      let builderState = {
        layoutId: "3v",
        frameColor: "#060d3d",
        // per panel assignment + overlay
        panels: [], // filled on layout init
      };

      function newPanelState(index) {
        return {
          index,
          shotId: null, // which captured shot assigned
          // editable overlays (start from shot's saved state when assigned)
          puffFrameUrl: null,
          puff: { x: 50, y: 50, scale: 1, rotation: 0 },
          stickers: [], // {id, src, state}
          texts: [], // {id, content, color, size, state}
        };
      }

      function initPanelsForLayout(layoutId) {
        const layout = LAYOUTS.find((l) => l.id === layoutId) || LAYOUTS[1];
        const panels = [];
        for (let i = 0; i < layout.panels; i++) panels.push(newPanelState(i));
        builderState.panels = panels;
      }

      // selection
      let activePanelIndex = 0;

      function openBuilder() {
        builderModal.classList.add("open");
        builderModal.setAttribute("aria-hidden", "false");

        // default init once
        if (!builderState.panels.length) initPanelsForLayout(builderState.layoutId);

        // render controls
        renderLayoutPills();
        renderColorPills();
        renderBuilderThumbs();

        // render strip
        renderStripPreview();
        setActivePanel(0);

        // editing context switches to panel
        editContext.mode = "panel";
        editContext.panelId = 0;
      }

      function closeBuilder() {
        builderModal.classList.remove("open");
        builderModal.setAttribute("aria-hidden", "true");
        // back to live context
        editContext.mode = "live";
        editContext.panelId = null;
        clearPanelSelectionOverlays();
      }

      builderClose.addEventListener("click", closeBuilder);
      builderDone.addEventListener("click", closeBuilder);

      builderSticker.addEventListener("click", () => openStickerPanel());
      builderText.addEventListener("click", () => openTextPanel());

      function renderLayoutPills() {
        layoutRow.innerHTML = "";
        LAYOUTS.forEach((l) => {
          const b = document.createElement("button");
          b.className = "pill" + (l.id === builderState.layoutId ? " active" : "");
          b.type = "button";
          b.textContent = l.name;
          b.addEventListener("click", () => {
            builderState.layoutId = l.id;
            initPanelsForLayout(l.id);
            activePanelIndex = 0;
            renderLayoutPills();
            renderStripPreview();
            setActivePanel(0);
          });
          layoutRow.appendChild(b);
        });
      }

      function renderColorPills() {
        colorRow.innerHTML = "";
        BOOTH_COLORS.forEach((c) => {
          const b = document.createElement("button");
          b.className = "pill" + (c.hex === builderState.frameColor ? " active" : "");
          b.type = "button";
          b.textContent = c.name;
          b.style.background = "rgba(255,255,255,0.12)";
          b.style.border = "1px solid rgba(255,255,255,0.14)";
          b.addEventListener("click", () => {
            builderState.frameColor = c.hex;
            renderColorPills();
            renderStripPreview();
          });
          colorRow.appendChild(b);
        });
      }

      function renderBuilderThumbs() {
        builderThumbs.innerHTML = "";
        shots.forEach((s, idx) => {
          const cell = document.createElement("div");
          cell.className = "bThumb";
          const img = document.createElement("img");
          img.src = s.compositeThumbUrl || s.baseDataUrl;
          img.alt = "shot";
          cell.appendChild(img);

          cell.addEventListener("click", () => {
            assignShotToPanel(activePanelIndex, s.id);
          });

          builderThumbs.appendChild(cell);
        });
      }

      function setStripLogo() {
        const src = logoForBg(builderState.frameColor);
        stripLogo.src = `${src}?v=${encodeURIComponent(ASSET_VERSION)}`;
      }

      function renderStripPreview() {
        const layout = LAYOUTS.find((l) => l.id === builderState.layoutId) || LAYOUTS[1];

        stripPreview.style.background = builderState.frameColor;
        stripPreview.style.aspectRatio = String(layout.aspect);

        setStripLogo();

        // configure grid
        stripInner.style.gridTemplateColumns = `repeat(${layout.grid.cols}, minmax(0, 1fr))`;
        stripInner.style.gridTemplateRows = `repeat(${layout.grid.rows}, minmax(0, 1fr))`;

        stripInner.innerHTML = "";

        builderState.panels.forEach((p) => {
          const panel = document.createElement("div");
          panel.className = "stripPanel";
          panel.dataset.panelIndex = String(p.index);

          const num = document.createElement("div");
          num.className = "panelNum";
          num.textContent = String(p.index + 1);
          panel.appendChild(num);

          // base photo
          const base = document.createElement("img");
          base.className = "panelBase";
          base.alt = "base";
          base.src = p.shotId ? (shots.find((s) => s.id === p.shotId)?.baseDataUrl || "") : "";
          base.style.opacity = p.shotId ? "1" : "0";
          panel.appendChild(base);

          const overlay = document.createElement("div");
          overlay.className = "panelOverlay";
          overlay.dataset.panelIndex = String(p.index);
          panel.appendChild(overlay);

          panel.addEventListener("click", (e) => {
            e.stopPropagation();
            setActivePanel(p.index);
          });

          stripInner.appendChild(panel);

          // draw overlays in DOM (no video, no duplication)
          hydratePanelOverlay(p.index);
        });

        // background bands pick up frame color automatically
        document.querySelector(".stripBandTop").style.background = builderState.frameColor;
        document.querySelector(".stripBandBottom").style.background = builderState.frameColor;
      }

      function setActivePanel(i) {
        activePanelIndex = i;
        editContext.mode = "panel";
        editContext.panelId = i;

        // highlight
        [...stripInner.querySelectorAll(".stripPanel")].forEach((el) => {
          el.classList.toggle("active", Number(el.dataset.panelIndex) === i);
        });

        // reset selection to avoid confusion
        clearPanelSelectionOverlays();
        updatePanelButtonsForSelection();
      }

      function assignShotToPanel(panelIndex, shotId) {
        const shot = shots.find((s) => s.id === shotId);
        if (!shot) return;

        const p = builderState.panels[panelIndex];
        p.shotId = shotId;

        // seed overlays from captured state (Option B)
        p.puffFrameUrl = shot.puffFrameUrl;
        p.puff = { ...shot.puffState };

        p.stickers = (shot.stickers || []).map((st, idx) => ({
          id: `st_${Date.now()}_${idx}_${Math.random()}`,
          src: st.src,
          state: { ...st.state },
        }));

        p.texts = (shot.texts || []).map((t, idx) => ({
          id: `tx_${Date.now()}_${idx}_${Math.random()}`,
          content: t.content,
          color: t.color,
          size: t.size,
          state: { ...t.state },
        }));

        // rerender only this panel
        const panelEl = stripInner.querySelector(`.stripPanel[data-panel-index="${panelIndex}"]`);
        if (panelEl) {
          const baseImg = panelEl.querySelector(".panelBase");
          baseImg.src = shot.baseDataUrl;
          baseImg.style.opacity = "1";
        }
        hydratePanelOverlay(panelIndex);
      }

      /* =========================
         Panel overlay DOM + per-panel transformables
      ========================= */
      const panelOverlayDom = new Map(); // panelIndex -> { overlayEl, selectedEl, selectedType, selectedId }

      function getPanelRect(panelIndex) {
        const panelEl = stripInner.querySelector(`.stripPanel[data-panel-index="${panelIndex}"]`);
        if (!panelEl) return { w: 1, h: 1 };
        const r = panelEl.getBoundingClientRect();
        return { w: r.width, h: r.height };
      }

      function clearPanelSelectionOverlays() {
        for (const v of panelOverlayDom.values()) {
          if (v.selectedEl) v.selectedEl.classList.remove("selected");
          v.selectedEl = null;
          v.selectedType = null;
          v.selectedId = null;
        }
      }

      function selectPanelOverlay(panelIndex, el, type, id) {
        const ctx = panelOverlayDom.get(panelIndex);
        if (!ctx) return;
        if (ctx.selectedEl && ctx.selectedEl !== el) ctx.selectedEl.classList.remove("selected");
        ctx.selectedEl = el;
        ctx.selectedType = type;
        ctx.selectedId = id;
        if (ctx.selectedEl) ctx.selectedEl.classList.add("selected");

        // sync text controls if selected text
        if (type === "text") {
          const p = builderState.panels[panelIndex];
          const t = p.texts.find((x) => x.id === id);
          if (t) {
            textContentInput.value = t.content || "";
            textColorSelect.value = t.color || "#ffffff";
            textSizeRange.value = String(t.size || 44);
          }
        }

        updatePanelButtonsForSelection();
      }

      function updatePanelButtonsForSelection() {
        const ctx = panelOverlayDom.get(activePanelIndex);
        const hasSel = !!(ctx && ctx.selectedEl);
        stickerRemove.disabled = !hasSel;
        removeTextBtn.disabled = !(ctx && ctx.selectedType === "text");
      }

      function hydratePanelOverlay(panelIndex) {
        const panelEl = stripInner.querySelector(`.stripPanel[data-panel-index="${panelIndex}"]`);
        if (!panelEl) return;
        const overlay = panelEl.querySelector(".panelOverlay");
        overlay.innerHTML = "";
        overlay.style.pointerEvents = "none";

        const p = builderState.panels[panelIndex];

        const ctxState = panelOverlayDom.get(panelIndex) || {
          overlayEl: overlay,
          selectedEl: null,
          selectedType: null,
          selectedId: null,
        };
        ctxState.overlayEl = overlay;
        panelOverlayDom.set(panelIndex, ctxState);

        // Puff (as STILL image, not video => no duplication)
        if (p.puffFrameUrl) {
          const puffImg = document.createElement("img");
          puffImg.src = p.puffFrameUrl;
          puffImg.alt = "puff";
          puffImg.className = "ov";
          puffImg.style.width = "62%";
          puffImg.style.height = "auto";
          puffImg.style.pointerEvents = "auto";
          puffImg.dataset.type = "puff";
          puffImg.dataset.id = "puff";
          overlay.appendChild(puffImg);

          function update() {
            puffImg.style.left = p.puff.x + "%";
            puffImg.style.top = p.puff.y + "%";
            puffImg.style.transform = `translate(-50%, -50%) scale(${p.puff.scale}) rotate(${p.puff.rotation}deg)`;
          }
          update();

          puffImg.addEventListener("pointerdown", (e) => {
            e.stopPropagation();
            selectPanelOverlay(panelIndex, puffImg, "puff", "puff");
          });

          makeTransformable(
            puffImg,
            p.puff,
            update,
            () => getPanelRect(panelIndex)
          );
        }

        // Stickers
        p.stickers.forEach((st) => {
          const img = document.createElement("img");
          img.src = st.src;
          img.alt = "sticker";
          img.className = "ov";
          img.style.width = "40%";
          img.style.height = "auto";
          img.dataset.type = "sticker";
          img.dataset.id = st.id;
          overlay.appendChild(img);

          function update() {
            img.style.left = st.state.x + "%";
            img.style.top = st.state.y + "%";
            img.style.transform = `translate(-50%, -50%) scale(${st.state.scale}) rotate(${st.state.rotation}deg)`;
          }
          update();

          img.addEventListener("pointerdown", (e) => {
            e.stopPropagation();
            selectPanelOverlay(panelIndex, img, "sticker", st.id);
          });

          makeTransformable(
            img,
            st.state,
            update,
            () => getPanelRect(panelIndex)
          );
        });

        // Texts
        p.texts.forEach((t) => {
          const div = document.createElement("div");
          div.className = "ov ovText";
          div.textContent = t.content || "";
          div.style.color = t.color || "#fff";
          div.style.fontSize = (t.size || 44) + "px";
          div.dataset.type = "text";
          div.dataset.id = t.id;
          overlay.appendChild(div);

          function update() {
            div.style.left = t.state.x + "%";
            div.style.top = t.state.y + "%";
            div.style.transform = `translate(-50%, -50%) scale(${t.state.scale}) rotate(${t.state.rotation}deg)`;
          }
          update();

          div.addEventListener("pointerdown", (e) => {
            e.stopPropagation();
            selectPanelOverlay(panelIndex, div, "text", t.id);
          });

          makeTransformable(
            div,
            t.state,
            update,
            () => getPanelRect(panelIndex)
          );
        });

        // allow deselect by clicking empty area in panel
        panelEl.addEventListener("pointerdown", () => {
          const ctx = panelOverlayDom.get(panelIndex);
          if (!ctx) return;
          if (ctx.selectedEl) ctx.selectedEl.classList.remove("selected");
          ctx.selectedEl = null;
          ctx.selectedType = null;
          ctx.selectedId = null;
          updatePanelButtonsForSelection();
        });

        // overlays should be interactive
        overlay.style.pointerEvents = "auto";
      }

      // Panel editing hooks for Sticker/Text panels
      const editContext = { mode: "live", panelId: null };

      function addStickerToPanel(panelIndex, src) {
        const p = builderState.panels[panelIndex];
        p.stickers.push({
          id: `st_${Date.now()}_${Math.random()}`,
          src,
          state: { x: 50, y: 50, scale: 1, rotation: 0 },
        });
        hydratePanelOverlay(panelIndex);
      }

      function addTextToPanel(panelIndex, content) {
        const p = builderState.panels[panelIndex];
        p.texts.push({
          id: `tx_${Date.now()}_${Math.random()}`,
          content: content || "Hello",
          color: "#ffffff",
          size: 44,
          state: { x: 50, y: 50, scale: 1, rotation: 0 },
        });
        hydratePanelOverlay(panelIndex);
      }

      function removeSelectedPanelOverlay() {
        const ctx = panelOverlayDom.get(activePanelIndex);
        if (!ctx || !ctx.selectedId || !ctx.selectedType) return;

        const p = builderState.panels[activePanelIndex];

        if (ctx.selectedType === "sticker") {
          p.stickers = p.stickers.filter((x) => x.id !== ctx.selectedId);
        } else if (ctx.selectedType === "text") {
          p.texts = p.texts.filter((x) => x.id !== ctx.selectedId);
        } else if (ctx.selectedType === "puff") {
          // don't remove puff; just ignore
        }

        ctx.selectedEl = null;
        ctx.selectedId = null;
        ctx.selectedType = null;

        hydratePanelOverlay(activePanelIndex);
        updatePanelButtonsForSelection();
      }

      function clearPanelStickers() {
        const p = builderState.panels[activePanelIndex];
        p.stickers = [];
        hydratePanelOverlay(activePanelIndex);
        updatePanelButtonsForSelection();
      }
      function clearPanelTexts() {
        const p = builderState.panels[activePanelIndex];
        p.texts = [];
        hydratePanelOverlay(activePanelIndex);
        updatePanelButtonsForSelection();
      }

      function updateSelectedPanelTextContent(val) {
        const ctx = panelOverlayDom.get(activePanelIndex);
        if (!ctx || ctx.selectedType !== "text") return;
        const p = builderState.panels[activePanelIndex];
        const t = p.texts.find((x) => x.id === ctx.selectedId);
        if (!t) return;
        t.content = val;
        hydratePanelOverlay(activePanelIndex);
      }

      function updateSelectedPanelTextColor(val) {
        const ctx = panelOverlayDom.get(activePanelIndex);
        if (!ctx || ctx.selectedType !== "text") return;
        const p = builderState.panels[activePanelIndex];
        const t = p.texts.find((x) => x.id === ctx.selectedId);
        if (!t) return;
        t.color = val;
        hydratePanelOverlay(activePanelIndex);
      }

      function updateSelectedPanelTextSize(val) {
        const ctx = panelOverlayDom.get(activePanelIndex);
        if (!ctx || ctx.selectedType !== "text") return;
        const p = builderState.panels[activePanelIndex];
        const t = p.texts.find((x) => x.id === ctx.selectedId);
        if (!t) return;
        t.size = val;
        hydratePanelOverlay(activePanelIndex);
      }

      /* =========================
         EXPORT STRIP PNG (canvas)
      ========================= */
      function loadImage(src) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => resolve(img);
          img.onerror = reject;
          img.src = src;
        });
      }

      function wrapLines(ctx, text, maxWidth) {
        const words = String(text || "").split(/\s+/);
        const lines = [];
        let line = "";
        for (const w of words) {
          const test = line ? line + " " + w : w;
          if (ctx.measureText(test).width <= maxWidth) {
            line = test;
          } else {
            if (line) lines.push(line);
            line = w;
          }
        }
        if (line) lines.push(line);
        return lines;
      }

      exportStripBtn.addEventListener("click", async () => {
        try {
          const layout = LAYOUTS.find((l) => l.id === builderState.layoutId) || LAYOUTS[1];

          // output sizes (tuned for social)
          // You can change these once you decide final print spec.
          const outW = layout.id === "3h" ? 1800 : 1200;
          const outH = Math.round(outW / layout.aspect);

          const topBandH = Math.round(outH * 0.14);
          const bottomBandH = Math.round(outH * 0.12);
          const innerX = Math.round(outW * 0.058);
          const innerY = topBandH + Math.round(outH * 0.058);
          const innerW = outW - innerX * 2;
          const innerH = outH - topBandH - bottomBandH - Math.round(outH * 0.058) * 2;

          const c = document.createElement("canvas");
          c.width = outW;
          c.height = outH;
          const ctx = c.getContext("2d");

          // frame color
          ctx.fillStyle = builderState.frameColor;
          ctx.fillRect(0, 0, outW, outH);

          // logo
          const logoSrc = `${logoForBg(builderState.frameColor)}?v=${encodeURIComponent(ASSET_VERSION)}`;
          let logoImg = null;
          try { logoImg = await loadImage(logoSrc); } catch (_) {}
          if (logoImg) {
            const targetH = Math.round(topBandH * 0.42);
            const scale = targetH / logoImg.height;
            const lw = Math.round(logoImg.width * scale);
            const lh = Math.round(logoImg.height * scale);
            ctx.globalAlpha = 0.95;
            ctx.drawImage(logoImg, Math.round((outW - lw) / 2), Math.round((topBandH - lh) / 2), lw, lh);
            ctx.globalAlpha = 1;
          }

          // panel grid geometry
          const cols = layout.grid.cols;
          const rows = layout.grid.rows;

          const gap = Math.round(Math.min(innerW, innerH) * 0.054);
          const cellW = Math.floor((innerW - gap * (cols - 1)) / cols);
          const cellH = Math.floor((innerH - gap * (rows - 1)) / rows);

          // render panels
          for (let i = 0; i < builderState.panels.length; i++) {
            const p = builderState.panels[i];

            const col = i % cols;
            const row = Math.floor(i / cols);

            const x = innerX + col * (cellW + gap);
            const y = innerY + row * (cellH + gap);

            // panel background
            ctx.save();
            // rounded rect clip
            const r = 24;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + cellW, y, x + cellW, y + cellH, r);
            ctx.arcTo(x + cellW, y + cellH, x, y + cellH, r);
            ctx.arcTo(x, y + cellH, x, y, r);
            ctx.arcTo(x, y, x + cellW, y, r);
            ctx.closePath();
            ctx.clip();

            // subtle inset shadow
            ctx.fillStyle = "rgba(255,255,255,0.06)";
            ctx.fillRect(x, y, cellW, cellH);
            // inset shading
            ctx.fillStyle = "rgba(0,0,0,0.20)";
            ctx.fillRect(x, y, cellW, Math.round(cellH * 0.06));
            ctx.fillRect(x, y, Math.round(cellW * 0.06), cellH);

            // base photo
            if (p.shotId) {
              const shot = shots.find((s) => s.id === p.shotId);
              if (shot) {
                const baseImg = await loadImage(shot.baseDataUrl);
                // cover into panel
                const scale = Math.max(cellW / baseImg.width, cellH / baseImg.height);
                const dw = baseImg.width * scale;
                const dh = baseImg.height * scale;
                const ox = x + (cellW - dw) / 2;
                const oy = y + (cellH - dh) / 2;
                ctx.drawImage(baseImg, ox, oy, dw, dh);
              }
            }

            // overlays: puff frame image + stickers + texts
            // helper: convert percent position to px in panel
            const toPx = (s) => ({
              cx: x + (s.x / 100) * cellW,
              cy: y + (s.y / 100) * cellH,
            });

            // puff
            if (p.puffFrameUrl) {
              try {
                const puffImg = await loadImage(p.puffFrameUrl);
                const { cx, cy } = toPx(p.puff);
                const baseW = cellW * 0.62; // match DOM preview
                const ar = puffImg.width / puffImg.height;
                const w = baseW * (p.puff.scale || 1);
                const h = (w / ar);
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(((p.puff.rotation || 0) * Math.PI) / 180);
                ctx.drawImage(puffImg, -w / 2, -h / 2, w, h);
                ctx.restore();
              } catch (_) {}
            }

            // stickers
            for (const st of p.stickers) {
              try {
                const img = await loadImage(st.src);
                const { cx, cy } = toPx(st.state);
                const baseW = cellW * 0.40;
                const ar = img.width / img.height;
                const w = baseW * (st.state.scale || 1);
                const h = (w / ar);
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(((st.state.rotation || 0) * Math.PI) / 180);
                ctx.drawImage(img, -w / 2, -h / 2, w, h);
                ctx.restore();
              } catch (_) {}
            }

            // texts
            const fontFamily = BEAUTIFUL_FREAK_READY ? "BeautifulFreak" : "system-ui";
            for (const t of p.texts) {
              const { cx, cy } = toPx(t.state);
              const size = (t.size || 44) * (t.state.scale || 1);
              ctx.save();
              ctx.translate(cx, cy);
              ctx.rotate(((t.state.rotation || 0) * Math.PI) / 180);
              ctx.fillStyle = t.color || "#ffffff";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.font = `${Math.round(size)}px ${fontFamily}`;

              // wrap a bit for safety
              const maxW = cellW * 0.86;
              const lines = wrapLines(ctx, t.content || "", maxW);
              const lh = size * 1.05;
              const total = lines.length * lh;
              lines.forEach((line, i) => {
                const yy = (i * lh) - total / 2 + lh / 2;
                ctx.fillText(line, 0, yy);
              });
              ctx.restore();
            }

            ctx.restore();

            // panel border
            ctx.strokeStyle = "rgba(255,255,255,0.18)";
            ctx.lineWidth = 4;
            ctx.beginPath();
            const rr = 24;
            ctx.moveTo(x + rr, y);
            ctx.arcTo(x + cellW, y, x + cellW, y + cellH, rr);
            ctx.arcTo(x + cellW, y + cellH, x, y + cellH, rr);
            ctx.arcTo(x, y + cellH, x, y, rr);
            ctx.arcTo(x, y, x + cellW, y, rr);
            ctx.closePath();
            ctx.stroke();

            // numbering bubble
            ctx.fillStyle = "rgba(0,0,0,0.48)";
            ctx.beginPath();
            ctx.arc(x + 26, y + 26, 18, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#fff";
            ctx.font = `900 18px system-ui`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(String(i + 1), x + 26, y + 27);
          }

          const dataUrl = c.toDataURL("image/png");
          const win = window.open("about:blank", "_blank");
          if (!win) {
            alert("Popup blocked. Please allow popups.");
            return;
          }
          const filename = nextCaptureFilename("Puff Dragon_PhotoStrip");
          win.document.write(`
            <title>${filename}</title>
            <div style="margin:0;background:#000;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:18px;">
              <img src="${dataUrl}" style="max-width:100%;height:auto;display:block;border-radius:18px;" />
              <a
                href="${dataUrl}"
                download="${filename}"
                style="display:inline-block;padding:10px 14px;border-radius:12px;background:#fff100;color:#060d3d;font:900 14px system-ui;text-decoration:none"
              >
                Download (${filename})
              </a>
            </div>
          `);
          win.document.close();
        } catch (e) {
          console.error(e);
          alert("Export failed. Try again.");
        }
      });

      /* =========================
         Misc UI
      ========================= */
      setPhotobooth(false);

      /* =========================
         Enable builder only when in photobooth
      ========================= */
      // (already via Visuals, cue!)

      /* =========================
         IMPORTANT: apply initial preview filter
      ========================= */
      applyCameraFilterPreview();

      /* =========================
         Text/Sticker selection sync when in panel mode
      ========================= */
      // Override Sticker/Text buttons in builder:
      // they already open same panels; we route actions via editContext.mode.

      /* =========================
         Filter panel close on outside click in builder
      ========================= */
      builderModal.addEventListener("click", (e) => {
        // clicking dark background does nothing (avoid accidental close)
      });

      /* =========================
         When builder is open, stop selecting live overlays
      ========================= */
      function blockLiveSelectionWhileBuilderOpen() {
        return builderModal.classList.contains("open");
      }

      // If builder open, don't let live sticker/text selection confuse UI
      // (Not strictly needed, but helps.)
      document.addEventListener("pointerdown", (e) => {
        if (!blockLiveSelectionWhileBuilderOpen()) return;
        // prevent live-layer selections
        if (e.target === puffEl || e.target.classList?.contains("sticker") || e.target.classList?.contains("textItem")) {
          e.stopPropagation();
        }
      }, true);

      /* =========================
         Photobooth toggle enables sidebar; normal mode still keeps Sticker/Text enabled
      ========================= */

      /* =========================
         Builder open/close wiring
      ========================= */
      function openBuilderIfShots() {
        if (!shots.length) {
          alert("No captured images yet.");
          return;
        }
        openBuilder();
      }
      // expose on cue
      // visualsCueBtn already wired above

    </script>
  </body>
</html>
