<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
<title>Puff Dragon AR Viewer</title>

<style>
html,body{
  margin:0;
  padding:0;
  background:#000;
  overflow:hidden;
  height:100%;
  touch-action:none;
  font-family:system-ui;
}

.hidden{display:none!important;}

#introOverlay{
  position:fixed;
  inset:0;
  background:#fff;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:9999;
}

#exploreBtn{
  position:absolute;
  bottom:15%;
  padding:16px 30px;
  font-weight:900;
  background:#fa213f;
  border-radius:14px;
  border:0;
  color:#fff;
  font-size:20px;
}

#camera{
  position:fixed;
  inset:0;
  width:100vw;
  height:100vh;
  object-fit:cover;
  z-index:1;
}

#camera.mirror{transform:scaleX(-1);}

#puff{
  position:fixed;
  left:50%;
  top:70%;
  width:min(90vw,450px);
  height:auto;
  object-fit:contain;
  transform:translate(-50%,-50%);
  transform-origin:center;
  z-index:3;
  touch-action:none;
  user-select:none;
  pointer-events:auto;
}

#ui{
  position:fixed;
  bottom:0;
  left:0;
  right:0;
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:8px;
  background:linear-gradient(to top,rgba(0,0,0,.7),transparent);
  z-index:10;
}

.ui-row{
  display:flex;
  justify-content:center;
  gap:8px;
  flex-wrap:wrap;
}

button{
  border:0;
  border-radius:10px;
  padding:8px 12px;
  font-weight:800;
}

#capture{background:#fff100;color:#000;}
#photoboothToggle.on{background:#01b7ff;color:#000;}

#countdown{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:120px;
  font-weight:900;
  color:#fff;
  z-index:9998;
  pointer-events:none;
  background:rgba(0,0,0,.3);
}
</style>
</head>
<body>

<div id="introOverlay">
  <button id="exploreBtn">Explore</button>
</div>

<video id="camera" autoplay playsinline muted></video>
<video id="puff" autoplay playsinline muted loop></video>

<div id="countdown" class="hidden"></div>

<div id="ui">
  <div class="ui-row">
    <button id="start">Start AR</button>
    <button id="flip" disabled>Flip</button>
    <button id="mirror" disabled>Mirror: Auto</button>
  </div>
  <div class="ui-row">
    <button id="photoboothToggle" disabled>Photobooth: OFF</button>
    <button id="timerBtn" disabled>Timer: 0</button>
    <button id="capture" disabled>Puff It!</button>
  </div>
</div>

<script>
/* ==============================
   INTRO
============================== */
const introOverlay=document.getElementById("introOverlay");
document.getElementById("exploreBtn").onclick=()=>{
  introOverlay.classList.add("hidden");
};

/* ==============================
   CAMERA
============================== */
const cameraEl=document.getElementById("camera");
const puffEl=document.getElementById("puff");

let stream=null;
let currentFacingMode="environment";
let mirrorMode="auto";

function shouldMirror(){
  return mirrorMode==="on"||(mirrorMode==="auto"&&currentFacingMode==="user");
}

function applyMirror(){
  cameraEl.classList.toggle("mirror",shouldMirror());
  document.getElementById("mirror").textContent=
    mirrorMode==="auto"?"Mirror: Auto":
    mirrorMode==="on"?"Mirror: On":"Mirror: Off";
}

async function startCamera(){
  if(stream) stream.getTracks().forEach(t=>t.stop());
  stream=await navigator.mediaDevices.getUserMedia({
    video:{facingMode:{ideal:currentFacingMode}}
  });
  cameraEl.srcObject=stream;
  await cameraEl.play();
  document.getElementById("flip").disabled=false;
  document.getElementById("mirror").disabled=false;
  document.getElementById("capture").disabled=false;
  document.getElementById("photoboothToggle").disabled=false;
  document.getElementById("timerBtn").disabled=false;
  applyMirror();
}

document.getElementById("start").onclick=startCamera;

document.getElementById("flip").onclick=async()=>{
  currentFacingMode=currentFacingMode==="environment"?"user":"environment";
  await startCamera();
};

document.getElementById("mirror").onclick=()=>{
  mirrorMode=mirrorMode==="auto"?"on":mirrorMode==="on"?"off":"auto";
  applyMirror();
};

/* ==============================
   PUFF VIDEO
============================== */
puffEl.src="puff.mov"; // keep your original file
puffEl.addEventListener("loadedmetadata",()=>{
  puffEl.style.aspectRatio=puffEl.videoWidth+" / "+puffEl.videoHeight;
});

/* ==============================
   PUFF TRANSFORM
============================== */
const puffState={x:50,y:70,scale:1.4,rotation:0};

function updatePuff(){
  puffEl.style.left=puffState.x+"%";
  puffEl.style.top=puffState.y+"%";
  puffEl.style.transform=
    `translate(-50%,-50%) scale(${puffState.scale}) rotate(${puffState.rotation}deg)`;
}

updatePuff();

/* TOUCH */
let touchStart=null;
puffEl.addEventListener("touchstart",e=>{
  if(e.touches.length===1){
    const t=e.touches[0];
    touchStart={x:t.clientX,y:t.clientY,bx:puffState.x,by:puffState.y};
  }
  if(e.touches.length===2){
    const a=e.touches[0],b=e.touches[1];
    touchStart={
      d:Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY),
      r:puffState.rotation,
      s:puffState.scale
    };
  }
},{passive:false});

puffEl.addEventListener("touchmove",e=>{
  e.preventDefault();
  if(e.touches.length===1&&touchStart){
    const t=e.touches[0];
    puffState.x=touchStart.bx+(t.clientX-touchStart.x)/window.innerWidth*100;
    puffState.y=touchStart.by+(t.clientY-touchStart.y)/window.innerHeight*100;
  }
  if(e.touches.length===2&&touchStart.d){
    const a=e.touches[0],b=e.touches[1];
    const nd=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
    puffState.scale=touchStart.s*(nd/touchStart.d);
    const angle=Math.atan2(b.clientY-a.clientY,b.clientX-a.clientX)*180/Math.PI;
    puffState.rotation=touchStart.r+(angle);
  }
  updatePuff();
},{passive:false});

/* DESKTOP */
let rKey=false;
document.addEventListener("keydown",e=>{
  if(e.key.toLowerCase()==="r") rKey=true;
});
document.addEventListener("keyup",e=>{
  if(e.key.toLowerCase()==="r") rKey=false;
});

let mouseStart=null;
puffEl.addEventListener("mousedown",e=>{
  mouseStart={x:e.clientX,y:e.clientY,bx:puffState.x,by:puffState.y,br:puffState.rotation};
  window.onmousemove=(ev)=>{
    if(rKey){
      puffState.rotation=mouseStart.br+(ev.clientX-mouseStart.x);
    }else{
      puffState.x=mouseStart.bx+(ev.clientX-mouseStart.x)/window.innerWidth*100;
      puffState.y=mouseStart.by+(ev.clientY-mouseStart.y)/window.innerHeight*100;
    }
    updatePuff();
  };
  window.onmouseup=()=>window.onmousemove=null;
});

/* ==============================
   TIMER
============================== */
let timerValue=0;
const countdown=document.getElementById("countdown");

document.getElementById("timerBtn").onclick=()=>{
  timerValue=timerValue===0?1:timerValue===1?3:0;
  document.getElementById("timerBtn").textContent="Timer: "+timerValue;
};

async function runCountdown(){
  if(timerValue===0) return;
  countdown.classList.remove("hidden");
  for(let i=timerValue;i>0;i--){
    countdown.textContent=i;
    await new Promise(r=>setTimeout(r,1000));
  }
  countdown.classList.add("hidden");
}

/* ==============================
   CAPTURE (pixel perfect)
============================== */
function capture(){
  const dpr=window.devicePixelRatio||1;
  const W=Math.round(window.innerWidth*dpr);
  const H=Math.round(window.innerHeight*dpr);

  const canvas=document.createElement("canvas");
  canvas.width=W;
  canvas.height=H;
  const ctx=canvas.getContext("2d");

  const camW=cameraEl.videoWidth;
  const camH=cameraEl.videoHeight;
  const scale=Math.max(W/camW,H/camH);
  const sw=W/scale;
  const sh=H/scale;
  const sx=(camW-sw)/2;
  const sy=(camH-sh)/2;

  ctx.save();
  if(shouldMirror()){
    ctx.translate(W,0);
    ctx.scale(-1,1);
  }
  ctx.drawImage(cameraEl,sx,sy,sw,sh,0,0,W,H);
  ctx.restore();

  const px=puffState.x/100*W;
  const py=puffState.y/100*H;
  const puffW=puffEl.offsetWidth*dpr;
  const puffH=puffEl.offsetHeight*dpr;

  ctx.save();
  ctx.translate(px,py);
  ctx.rotate(puffState.rotation*Math.PI/180);
  ctx.drawImage(puffEl,-puffW/2,-puffH/2,puffW,puffH);
  ctx.restore();

  canvas.toBlob(blob=>{
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url;
    a.download="puff.png";
    a.click();
  });
}


/* ==============================
   PHOTOBOOTH TOGGLE BASE
============================== */
let photoboothOn=false;
document.getElementById("photoboothToggle").onclick=()=>{
  photoboothOn=!photoboothOn;
  document.getElementById("photoboothToggle").classList.toggle("on",photoboothOn);
  document.getElementById("photoboothToggle").textContent=
    photoboothOn?"Photobooth: ON":"Photobooth: OFF";
};

/* ==== PHOTObooth + BUILDER WILL BE INSERTED BELOW ==== */
/* ==============================
   PHOTOBOOTH (Captured Panel + Builder)
   - Keeps existing layouts
   - Manual mode: pan/zoom is CLIPPED to slot rect (panel size never changes)
   - Capture flow:
       Photobooth OFF -> download immediately
       Photobooth ON  -> push into captured list (same capture output)
============================== */

// ---------- UI: captured panel ----------
const capturedPanel = document.createElement("div");
capturedPanel.id = "capturedPanel";
capturedPanel.className = "hidden";
capturedPanel.style.cssText = `
  position:fixed; right:14px; top:14px;
  width:min(42vw,240px); height:min(48vh,360px);
  z-index:50; border-radius:14px;
  background:rgba(10,10,10,.65); backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.12);
  overflow:hidden; display:flex; flex-direction:column;
`;

capturedPanel.innerHTML = `
  <div id="capturedHeader" style="
    padding:10px; display:flex; align-items:center; justify-content:space-between;
    background:rgba(0,0,0,.35); cursor:grab; user-select:none;">
    <div style="color:#fff;font-weight:900;font-size:12px;">Captured</div>
    <button id="clearCapturedBtn" style="border:0;border-radius:10px;padding:6px 10px;background:rgba(255,255,255,.14);color:#fff;font-weight:800;">Clear</button>
  </div>
  <div id="capturedList" style="
    flex:1; overflow:auto; padding:10px;
    display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:8px;">
  </div>
  <div style="padding:10px;background:rgba(0,0,0,.35);display:flex;justify-content:center;gap:8px;">
    <button id="cueBtn" disabled style="width:100%;border:0;border-radius:12px;padding:10px 12px;background:#fff100;color:#060d3d;font-weight:1000;">
      Visuals, cue!
    </button>
  </div>
`;
document.body.appendChild(capturedPanel);

const capturedHeader = document.getElementById("capturedHeader");
const capturedList = document.getElementById("capturedList");
const clearCapturedBtn = document.getElementById("clearCapturedBtn");
const cueBtn = document.getElementById("cueBtn");

// store captures
const capturedItems = []; // { blob, url }

// Update captured UI
function updateCapturedUI(){
  capturedList.innerHTML = "";
  capturedItems.forEach(it=>{
    const cell=document.createElement("div");
    cell.style.cssText = `
      border-radius:10px; overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      aspect-ratio:4/3;
    `;
    const img=document.createElement("img");
    img.src=it.url;
    img.alt="capture";
    img.style.cssText="width:100%;height:100%;object-fit:contain;display:block;background:rgba(0,0,0,.55);";
    cell.appendChild(img);
    capturedList.appendChild(cell);
  });
  cueBtn.disabled = capturedItems.length === 0;
}

// Clear captures
clearCapturedBtn.addEventListener("click", ()=>{
  capturedItems.forEach(it=>URL.revokeObjectURL(it.url));
  capturedItems.length = 0;
  updateCapturedUI();
});

// draggable captured panel
(function enableDragCaptured(){
  let dragging=false;
  let start=null;
  capturedHeader.addEventListener("pointerdown",(e)=>{
    e.preventDefault();
    dragging=true;
    capturedHeader.setPointerCapture?.(e.pointerId);
    const r=capturedPanel.getBoundingClientRect();
    start={x:e.clientX,y:e.clientY,left:r.left,top:r.top};
    capturedHeader.style.cursor="grabbing";
  });
  window.addEventListener("pointermove",(e)=>{
    if(!dragging||!start) return;
    e.preventDefault();
    const dx=e.clientX-start.x;
    const dy=e.clientY-start.y;
    const newLeft=Math.max(6,Math.min(window.innerWidth-capturedPanel.offsetWidth-6,start.left+dx));
    const newTop=Math.max(6,Math.min(window.innerHeight-capturedPanel.offsetHeight-6,start.top+dy));
    capturedPanel.style.left=newLeft+"px";
    capturedPanel.style.top=newTop+"px";
    capturedPanel.style.right="auto";
  },{passive:false});
  window.addEventListener("pointerup",()=>{
    dragging=false; start=null;
    capturedHeader.style.cursor="grab";
  });
})();

// Photobooth toggle affects where capture goes
function setPhotoboothMode(on){
  photoboothOn = on;
  document.getElementById("photoboothToggle").classList.toggle("on", on);
  document.getElementById("photoboothToggle").textContent = on ? "Photobooth: ON" : "Photobooth: OFF";
  capturedPanel.classList.toggle("hidden", !on);
  updateCapturedUI();
}
setPhotoboothMode(false);

// ---------- Patch capture button behavior to support photobooth ----------
const captureBtn = document.getElementById("capture");
captureBtn.onclick = async ()=>{
  await runCountdown();

  // Use the SAME capture output as before, but route it.
  const dpr=window.devicePixelRatio||1;
  const W=Math.round(window.innerWidth*dpr);
  const H=Math.round(window.innerHeight*dpr);

  const canvas=document.createElement("canvas");
  canvas.width=W; canvas.height=H;
  const ctx=canvas.getContext("2d");

  // camera cover crop
  const camW=cameraEl.videoWidth;
  const camH=cameraEl.videoHeight;
  const scale=Math.max(W/camW,H/camH);
  const sw=W/scale;
  const sh=H/scale;
  const sx=(camW-sw)/2;
  const sy=(camH-sh)/2;

  ctx.save();
  if(shouldMirror()){
    ctx.translate(W,0);
    ctx.scale(-1,1);
  }
  ctx.drawImage(cameraEl,sx,sy,sw,sh,0,0,W,H);
  ctx.restore();

  // puff overlay (same math as preview) — no stretching
  const px=puffState.x/100*W;
  const py=puffState.y/100*H;
  const puffRect = puffEl.getBoundingClientRect();
  const puffW = puffRect.width * dpr;
  const puffH = puffRect.height * dpr;


  ctx.save();
  ctx.translate(px,py);
  ctx.rotate(puffState.rotation*Math.PI/180);
  ctx.drawImage(puffEl,-puffW/2,-puffH/2,puffW,puffH);
  ctx.restore();

  canvas.toBlob((blob)=>{
    if(!blob){ alert("Capture failed."); return; }

    if(!photoboothOn){
      const url=URL.createObjectURL(blob);
      const a=document.createElement("a");
      a.href=url;
      a.download="puff.png";
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url),15000);
      return;
    }

    const url=URL.createObjectURL(blob);
    capturedItems.push({blob,url});
    updateCapturedUI();
  },"image/png");
};

// ---------- BUILDER OVERLAY ----------
const builderOverlay = document.createElement("div");
builderOverlay.id="builderOverlay";
builderOverlay.className="hidden";
builderOverlay.style.cssText=`
  position:fixed; inset:0; z-index:200;
  background:rgba(0,0,0,.72);
  backdrop-filter:blur(14px);
  display:flex; align-items:center; justify-content:center;
  padding:14px;
`;

builderOverlay.innerHTML=`
  <div id="builderShell" style="
    width:min(980px,100%); height:min(720px,100%);
    display:grid; grid-template-columns:1.2fr .8fr; gap:12px;">
    <div id="builderStageWrap" style="
      border-radius:16px; overflow:auto;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.25);
      display:flex; align-items:flex-start; justify-content:center;
      padding:12px; position:relative;">
      <canvas id="stripCanvas" width="400" height="1200"
        style="max-width:100%; height:auto; border-radius:0; background:transparent; touch-action:none;"></canvas>
    </div>

    <div id="builderControls" style="
      border-radius:16px; overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.35);
      display:flex; flex-direction:column; min-height:0;">
      <div style="padding:10px; display:flex; justify-content:space-between; align-items:center; background:rgba(0,0,0,.35);">
        <div style="color:#fff;font-weight:900;font-size:12px;">Photoshoot Customize</div>
        <button id="builderCloseBtn" style="border:0;border-radius:10px;padding:6px 10px;background:rgba(255,255,255,.14);color:#fff;font-weight:800;">Close</button>
      </div>

      <div id="builderBody" style="padding:10px; overflow:auto; display:flex; flex-direction:column; gap:12px; min-height:0;">
        <div style="border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:10px; background:rgba(255,255,255,.06);">
          <div style="color:#fff;font-weight:900;font-size:12px; margin-bottom:8px;">Frame color</div>
          <div id="frameColorRow" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
        </div>

        <div style="border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:10px; background:rgba(255,255,255,.06);">
          <div style="color:#fff;font-weight:900;font-size:12px; margin-bottom:8px;">Image fit</div>
          <div id="fitModeRow" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
          <div style="color:rgba(255,255,255,.75); font-size:11px; font-weight:700; margin-top:8px; line-height:1.2;">
            Manual = pan/zoom inside slot (always clipped). Panel size never changes.
          </div>
        </div>

        <div style="border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:10px; background:rgba(255,255,255,.06);">
          <div style="color:#fff;font-weight:900;font-size:12px; margin-bottom:8px;">Layout</div>
          <div id="layoutRow" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
        </div>

        <div style="border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:10px; background:rgba(255,255,255,.06);">
          <div style="color:#fff;font-weight:900;font-size:12px; margin-bottom:8px;">Select photos</div>
          <div id="slotRow" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
          <div style="height:10px"></div>
          <div id="photoPickGrid" style="display:grid; grid-template-columns:repeat(4,minmax(0,1fr)); gap:8px;"></div>
        </div>

        <button id="exportStripBtn" style="width:100%;border:0;border-radius:12px;padding:10px 12px;background:#fff100;color:#060d3d;font-weight:1000;">
          Export strip PNG
        </button>
      </div>
    </div>
  </div>
`;
document.body.appendChild(builderOverlay);

const stripCanvas = document.getElementById("stripCanvas");
const stripCtx = stripCanvas.getContext("2d");
const builderCloseBtn = document.getElementById("builderCloseBtn");
const frameColorRow = document.getElementById("frameColorRow");
const layoutRow = document.getElementById("layoutRow");
const fitModeRow = document.getElementById("fitModeRow");
const slotRow = document.getElementById("slotRow");
const photoPickGrid = document.getElementById("photoPickGrid");
const exportStripBtn = document.getElementById("exportStripBtn");

// close builder
builderCloseBtn.addEventListener("click", ()=>closeBuilder());
builderOverlay.addEventListener("pointerdown",(e)=>{
  if(e.target===builderOverlay) closeBuilder();
});

// open builder from cue button
cueBtn.addEventListener("click", ()=>openBuilder());

// -------- Builder state (keep layouts) --------
const FRAME_COLORS = [
  { id:"red", name:"Imperial Red", value:"#fa213f", logo:"puff-logo-2.png" },
  { id:"blue", name:"Dark Blue", value:"#060d3d", logo:"puff-logo-3.png" },
  { id:"grey", name:"Bright Grey", value:"#e8eef1", logo:"puff-logo-1.png" },
  { id:"white", name:"White", value:"#ffffff", logo:"puff-logo-1.png" },
  { id:"black", name:"Pure Black", value:"#000000", logo:"puff-logo-3.png" },
];

const LAYOUTS = [
  { id:"L1", name:"Layout 1 (3 horizontal strip)" },
  { id:"L2", name:"Layout 2 (3 vertical strip)" },
  { id:"L3", name:"Layout 3 (4 grid 2x2)" },
  { id:"L4", name:"Layout 4 (2 horizontal, left bar)" },
  { id:"L5", name:"Layout 5 (2 horizontal, center bar)" },
  { id:"L6", name:"Layout 6 (2 stacked left)" },
  { id:"L7", name:"Layout 7 (1 photo)" },
];

let builderState = {
  frameColorId:"blue",
  layoutId:"L2",
  fitMode:"smart",         // contain | smart | cover | manual
  slotToCapture:[],
  slotTransforms:[],       // { scaleMul, offsetX, offsetY }
};

let activeSlot=0;

function getFrameColor(){
  const c = FRAME_COLORS.find(x=>x.id===builderState.frameColorId) || FRAME_COLORS[1];
  return c.value;
}

const logoCache = new Map();
async function loadImageSafe(src){
  return new Promise((resolve)=>{
    if(!src) return resolve(null);
    if(logoCache.has(src)) return resolve(logoCache.get(src));
    const img=new Image();
    img.crossOrigin="anonymous";
    img.onload=()=>{ logoCache.set(src,img); resolve(img); };
    img.onerror=()=>resolve(null);
    img.src=src;
  });
}

async function getLogo(){
  const c = FRAME_COLORS.find(x=>x.id===builderState.frameColorId) || FRAME_COLORS[1];
  return await loadImageSafe(c.logo);
}

function syncCanvasToLayout(){
  if(builderState.layoutId==="L1"){ stripCanvas.width=1200; stripCanvas.height=400; return; }
  if(builderState.layoutId==="L2"){ stripCanvas.width=400; stripCanvas.height=1200; return; }
  if(builderState.layoutId==="L3"){ stripCanvas.width=900; stripCanvas.height=1350; return; }
  if(builderState.layoutId==="L4"||builderState.layoutId==="L5"){ stripCanvas.width=1200; stripCanvas.height=400; return; }
  if(builderState.layoutId==="L6"||builderState.layoutId==="L7"){ stripCanvas.width=1350; stripCanvas.height=900; return; }
}

function slotsNeeded(){
  if(builderState.layoutId==="L3") return 4;
  if(builderState.layoutId==="L4"||builderState.layoutId==="L5") return 2;
  if(builderState.layoutId==="L6") return 2;
  if(builderState.layoutId==="L7") return 1;
  return 3;
}

function ensureSlotMapping(){
  const n=slotsNeeded();

  const arr=builderState.slotToCapture||[];
  const next=new Array(n).fill(-1);
  for(let i=0;i<n;i++) next[i]=arr[i] ?? (i < capturedItems.length ? i : -1);
  for(let i=0;i<n;i++){
    if(next[i] >= capturedItems.length) next[i] = -1;
  }
  builderState.slotToCapture = next;

  const tArr=builderState.slotTransforms||[];
  builderState.slotTransforms = new Array(n).fill(null).map((_,i)=>{
    const prev=tArr[i];
    return { scaleMul: prev?.scaleMul ?? 1, offsetX: prev?.offsetX ?? 0, offsetY: prev?.offsetY ?? 0 };
  });

  activeSlot=Math.max(0,Math.min(n-1,activeSlot));
}

function pill(label, active){
  const d=document.createElement("div");
  d.textContent=label;
  d.style.cssText=`
    border:1px solid rgba(255,255,255,.16);
    background:${active ? "rgba(255,255,255,.18)" : "rgba(255,255,255,.08)"};
    color:rgba(255,255,255,.92);
    padding:7px 10px; border-radius:999px;
    font-weight:900; font-size:11px;
    cursor:pointer; user-select:none;
  `;
  if(active){
    d.style.outline="2px solid rgba(255,255,255,.65)";
    d.style.outlineOffset="1px";
  }
  return d;
}

function renderBuilderUI(){
  // frame color
  frameColorRow.innerHTML="";
  FRAME_COLORS.forEach(c=>{
    const p=pill(c.name, builderState.frameColorId===c.id);
    p.onclick=async()=>{
      builderState.frameColorId=c.id;
      renderBuilderUI();
      await drawStrip(false);
    };
    frameColorRow.appendChild(p);
  });

  // fit modes
  fitModeRow.innerHTML="";
  [
    {id:"contain", label:"Contain"},
    {id:"smart", label:"Smart"},
    {id:"cover", label:"Cover"},
    {id:"manual", label:"Manual"},
  ].forEach(m=>{
    const p=pill(m.label, builderState.fitMode===m.id);
    p.onclick=async()=>{
      builderState.fitMode=m.id;
      renderBuilderUI();
      await drawStrip(false);
    };
    fitModeRow.appendChild(p);
  });

  // layouts
  layoutRow.innerHTML="";
  LAYOUTS.forEach(l=>{
    const p=pill(l.name, builderState.layoutId===l.id);
    p.onclick=async()=>{
      builderState.layoutId=l.id;
      syncCanvasToLayout();
      ensureSlotMapping();
      renderBuilderUI();
      await drawStrip(false);
    };
    layoutRow.appendChild(p);
  });

  // slots
  slotRow.innerHTML="";
  const n=slotsNeeded();
  for(let i=0;i<n;i++){
    const p=pill(`Slot ${i+1}`, activeSlot===i);
    p.onclick=async()=>{
      activeSlot=i;
      renderBuilderUI();
      await drawStrip(false);
    };
    slotRow.appendChild(p);
  }

  // photo pick grid
  photoPickGrid.innerHTML="";
  capturedItems.forEach((it,idx)=>{
    const b=document.createElement("button");
    b.type="button";
    b.style.cssText=`
      border:0; padding:0; cursor:pointer;
      border-radius:12px; overflow:hidden;
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.14);
      aspect-ratio:4/3;
    `;
    const img=document.createElement("img");
    img.src=it.url;
    img.style.cssText="width:100%;height:100%;object-fit:cover;display:block;";
    b.appendChild(img);

    b.onclick=async()=>{
      builderState.slotToCapture[activeSlot]=idx;
      activeSlot=(activeSlot+1)%n;
      renderBuilderUI();
      await drawStrip(false);
    };

    photoPickGrid.appendChild(b);
  });
}

function openBuilder(){
  if(capturedItems.length===0) return;
  builderOverlay.classList.remove("hidden");
  syncCanvasToLayout();
  ensureSlotMapping();
  renderBuilderUI();
  drawStrip(false);
}

function closeBuilder(){
  builderOverlay.classList.add("hidden");
}

// ---- drawing helpers (panel fixed size) ----
function drawContain(ctx,img,rx,ry,rw,rh){
  const iw=img.naturalWidth||img.width;
  const ih=img.naturalHeight||img.height;
  if(!iw||!ih) return;
  const s=Math.min(rw/iw,rh/ih);
  const dw=iw*s, dh=ih*s;
  const dx=rx+(rw-dw)/2, dy=ry+(rh-dh)/2;
  ctx.drawImage(img,dx,dy,dw,dh);
}

function drawCover(ctx,img,rx,ry,rw,rh){
  const iw=img.naturalWidth||img.width;
  const ih=img.naturalHeight||img.height;
  if(!iw||!ih) return;
  const s=Math.max(rw/iw,rh/ih);
  const dw=iw*s, dh=ih*s;
  const dx=rx+(rw-dw)/2, dy=ry+(rh-dh)/2;
  ctx.drawImage(img,dx,dy,dw,dh);
}

function drawSmart(ctx,img,rx,ry,rw,rh){
  const iw=img.naturalWidth||img.width;
  const ih=img.naturalHeight||img.height;
  if(!iw||!ih) return;
  const imgAR=iw/ih;
  const slotAR=rw/rh;
  const ratio=imgAR/slotAR;
  const closeEnough=ratio>0.82 && ratio<1.22;
  if(closeEnough) drawCover(ctx,img,rx,ry,rw,rh);
  else drawContain(ctx,img,rx,ry,rw,rh);
}

// MANUAL: clipped inside slot ALWAYS (panel size never changes)
function drawManual(ctx,img,rx,ry,rw,rh,tr){
  const iw=img.naturalWidth||img.width;
  const ih=img.naturalHeight||img.height;
  if(!iw||!ih) return;

  const coverS=Math.max(rw/iw,rh/ih);
  const containS=Math.min(rw/iw,rh/ih);
  const minMul=containS/coverS;   // allow zoom out to contain
  const maxMul=3.0;
  tr.scaleMul=Math.max(minMul,Math.min(maxMul,tr.scaleMul||1));

  const s=coverS*tr.scaleMul;
  const dw=iw*s, dh=ih*s;

  // base centered
  let dx=rx+(rw-dw)/2;
  let dy=ry+(rh-dh)/2;

  // clamp pan to bounds
  let offX=tr.offsetX||0;
  let offY=tr.offsetY||0;

  if(dw>rw){
    const maxPanX=(dw-rw)/2;
    offX=Math.max(-maxPanX,Math.min(maxPanX,offX));
  }else offX=0;

  if(dh>rh){
    const maxPanY=(dh-rh)/2;
    offY=Math.max(-maxPanY,Math.min(maxPanY,offY));
  }else offY=0;

  tr.offsetX=offX; tr.offsetY=offY;

  dx+=offX; dy+=offY;

  ctx.save();
  ctx.beginPath();
  ctx.rect(rx,ry,rw,rh);
  ctx.clip();
  ctx.drawImage(img,dx,dy,dw,dh);
  ctx.restore();
}

function getLayoutSlots(){
  const W=stripCanvas.width, H=stripCanvas.height;
  const minSide=Math.min(W,H);
  const outer=Math.round(minSide*0.06);
  const topBar=Math.round(minSide*0.16);
  const bottomBar=Math.round(minSide*0.10);
  const gap=Math.max(6,Math.round(minSide*0.012));

  const contentX=outer;
  const contentY=outer+topBar;
  const contentW=W-outer*2;
  const contentH=H-outer-bottomBar-contentY;

  const topBarRect={x:outer,y:outer,w:contentW,h:topBar};

  if(builderState.layoutId==="L1"){
    const slotW=Math.floor((contentW-gap*2)/3);
    const slotH=contentH;
    return { topBar:topBarRect, slots:[
      {x:contentX,y:contentY,w:slotW,h:slotH},
      {x:contentX+slotW+gap,y:contentY,w:slotW,h:slotH},
      {x:contentX+(slotW+gap)*2,y:contentY,w:slotW,h:slotH},
    ]};
  }

  if(builderState.layoutId==="L2"){
    const slotH=Math.floor((contentH-gap*2)/3);
    const slotW=contentW;
    return { topBar:topBarRect, slots:[
      {x:contentX,y:contentY,w:slotW,h:slotH},
      {x:contentX,y:contentY+slotH+gap,w:slotW,h:slotH},
      {x:contentX,y:contentY+(slotH+gap)*2,w:slotW,h:slotH},
    ]};
  }

  if(builderState.layoutId==="L3"){
    const slotW=Math.floor((contentW-gap)/2);
    const slotH=Math.floor((contentH-gap)/2);
    return { topBar:topBarRect, slots:[
      {x:contentX,y:contentY,w:slotW,h:slotH},
      {x:contentX+slotW+gap,y:contentY,w:slotW,h:slotH},
      {x:contentX,y:contentY+slotH+gap,w:slotW,h:slotH},
      {x:contentX+slotW+gap,y:contentY+slotH+gap,w:slotW,h:slotH},
    ]};
  }

  if(builderState.layoutId==="L4"){
    const barW=Math.floor(contentW*0.22);
    const photosW=contentW-barW-gap;
    const slotW=Math.floor((photosW-gap)/2);
    const slotH=contentH;
    return { topBar:topBarRect, slots:[
      {x:contentX+barW+gap,y:contentY,w:slotW,h:slotH},
      {x:contentX+barW+gap+slotW+gap,y:contentY,w:slotW,h:slotH},
    ]};
  }

  if(builderState.layoutId==="L5"){
    const barW=Math.floor(contentW*0.24);
    const slotW=Math.floor((contentW-barW-gap*2)/2);
    const slotH=contentH;
    return { topBar:topBarRect, slots:[
      {x:contentX,y:contentY,w:slotW,h:slotH},
      {x:contentX+slotW+gap+barW+gap,y:contentY,w:slotW,h:slotH},
    ]};
  }

  if(builderState.layoutId==="L6"){
    const rightW=Math.floor(contentW*0.4);
    const leftW=contentW-rightW-gap;
    const slotH=Math.floor((contentH-gap)/2);
    return { topBar:topBarRect, slots:[
      {x:contentX,y:contentY,w:leftW,h:slotH},
      {x:contentX,y:contentY+slotH+gap,w:leftW,h:slotH},
    ]};
  }

  if(builderState.layoutId==="L7"){
    const inset=Math.round(minSide*0.04);
    const slotX=contentX+inset;
    const slotY=contentY+inset;
    const slotW=contentW-inset*2;
    const slotH=contentH-inset*2;
    return { topBar:topBarRect, slots:[{x:slotX,y:slotY,w:slotW,h:slotH}] };
  }

  return { topBar:topBarRect, slots:[] };
}

async function drawStrip(forExport){
  ensureSlotMapping();

  const frameColor=getFrameColor();
  const layout=getLayoutSlots();

  // load slot images
  const imgs = await Promise.all(builderState.slotToCapture.map(async (ci)=>{
    if(ci<0) return null;
    const url = capturedItems[ci]?.url;
    if(!url) return null;
    return await loadImageSafe(url);
  }));

  stripCtx.clearRect(0,0,stripCanvas.width,stripCanvas.height);
  stripCtx.fillStyle=frameColor;
  stripCtx.fillRect(0,0,stripCanvas.width,stripCanvas.height);

  // draw slots
  for(let i=0;i<layout.slots.length;i++){
    const s=layout.slots[i];
    const img=imgs[i];
    stripCtx.fillStyle=frameColor;
    stripCtx.fillRect(s.x,s.y,s.w,s.h);

    if(img){
      const mode=builderState.fitMode||"smart";
      if(mode==="contain") drawContain(stripCtx,img,s.x,s.y,s.w,s.h);
      else if(mode==="cover") drawCover(stripCtx,img,s.x,s.y,s.w,s.h);
      else if(mode==="manual") drawManual(stripCtx,img,s.x,s.y,s.w,s.h,builderState.slotTransforms[i]);
      else drawSmart(stripCtx,img,s.x,s.y,s.w,s.h);
    }
  }

  // highlight active slot (preview only)
  if(!forExport){
    const a=layout.slots[activeSlot];
    if(a){
      stripCtx.save();
      stripCtx.strokeStyle="rgba(255,255,255,.85)";
      stripCtx.lineWidth=Math.max(6,Math.round(Math.min(stripCanvas.width,stripCanvas.height)*0.006));
      stripCtx.strokeRect(a.x,a.y,a.w,a.h);
      stripCtx.restore();
    }
  }

  // logo at top bar center
  const logo = await getLogo();
  if(logo){
    const top=layout.topBar;
    const maxW=top.w*0.4;
    const maxH=top.h*0.8;
    const iw=logo.naturalWidth||logo.width;
    const ih=logo.naturalHeight||logo.height;
    if(iw&&ih){
      const sc=Math.min(maxW/iw,maxH/ih);
      const w=iw*sc, h=ih*sc;
      const x=top.x+(top.w-w)/2;
      const y=top.y+(top.h-h)/2;
      stripCtx.drawImage(logo,x,y,w,h);
    }
  }
}

// manual interactions on canvas (pan/zoom) — clipped always
let manualPointer={active:false, id:null, sx:0, sy:0, bx:0, by:0};

function canvasPointToSlotIndex(cx,cy){
  const r=stripCanvas.getBoundingClientRect();
  const x=(cx-r.left)/r.width*stripCanvas.width;
  const y=(cy-r.top)/r.height*stripCanvas.height;
  const layout=getLayoutSlots();
  for(let i=0;i<layout.slots.length;i++){
    const s=layout.slots[i];
    if(x>=s.x && x<=s.x+s.w && y>=s.y && y<=s.y+s.h) return i;
  }
  return -1;
}

stripCanvas.addEventListener("pointerdown",(e)=>{
  if(builderOverlay.classList.contains("hidden")) return;
  const idx=canvasPointToSlotIndex(e.clientX,e.clientY);
  if(idx<0) return;
  activeSlot=idx;
  renderBuilderUI();
  drawStrip(false);

  if(builderState.fitMode!=="manual") return;
  e.preventDefault();
  manualPointer.active=true;
  manualPointer.id=e.pointerId;
  manualPointer.sx=e.clientX;
  manualPointer.sy=e.clientY;
  const tr=builderState.slotTransforms[activeSlot];
  manualPointer.bx=tr.offsetX||0;
  manualPointer.by=tr.offsetY||0;
  stripCanvas.setPointerCapture?.(e.pointerId);
},{passive:false});

stripCanvas.addEventListener("pointermove",(e)=>{
  if(!manualPointer.active) return;
  if(builderState.fitMode!=="manual") return;
  if(e.pointerId!==manualPointer.id) return;
  e.preventDefault();
  const dx=e.clientX-manualPointer.sx;
  const dy=e.clientY-manualPointer.sy;
  const tr=builderState.slotTransforms[activeSlot];
  tr.offsetX=manualPointer.bx+dx;
  tr.offsetY=manualPointer.by+dy;
  drawStrip(false);
},{passive:false});

stripCanvas.addEventListener("pointerup",(e)=>{
  if(e.pointerId===manualPointer.id){
    manualPointer.active=false; manualPointer.id=null;
  }
});
stripCanvas.addEventListener("pointercancel",()=>{
  manualPointer.active=false; manualPointer.id=null;
});

// wheel zoom manual
stripCanvas.addEventListener("wheel",(e)=>{
  if(builderOverlay.classList.contains("hidden")) return;
  if(builderState.fitMode!=="manual") return;
  const idx=canvasPointToSlotIndex(e.clientX,e.clientY);
  if(idx>=0){ activeSlot=idx; renderBuilderUI(); }
  e.preventDefault();
  const tr=builderState.slotTransforms[activeSlot];
  tr.scaleMul=(tr.scaleMul||1)*(e.deltaY>0?0.92:1.08);
  drawStrip(false);
},{passive:false});

// Export
exportStripBtn.addEventListener("click", async ()=>{
  await drawStrip(true);
  stripCanvas.toBlob((blob)=>{
    if(!blob){ alert("Export failed."); return; }
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url;
    a.download=`Puff_Dragon_Photobooth_${Date.now()}.png`;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(url),15000);
  },"image/png");
});

</script>
</body>
</html>
