<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>Puff Dragon AR Viewer</title>

    <style>
      html, body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        height: 100%;
        touch-action: none;
      }

      .hidden { display: none !important; }

      /* =========================
         INTRO OVERLAY (fixed: truly non-interactive when hidden)
      ========================= */
      #introOverlay {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }
      #introOverlay.hidden {
        display: none !important;
        pointer-events: none !important;
      }

      #introVideo {
        width: 100vw;
        height: auto;
        max-height: 100vh;
        object-fit: contain;
        background: #fff;
        display: block;
        pointer-events: none;
      }

      #introClosePuff {
        position: absolute;
        top: calc(14px + env(safe-area-inset-top));
        left: 50%;
        transform: translateX(-50%);
        width: min(22vw, 96px);
        height: auto;
        z-index: 3;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      #exploreBtn {
        position: absolute;
        left: 50%;
        top: 55%;
        transform: translate(-50%, -50%);
        border: 0;
        border-radius: 16px;
        padding: 18px 34px;
        font-size: clamp(20px, 4.2vw, 30px);
        font-weight: 900;
        color: #fff;
        background: #fa213f;
        cursor: pointer;
        z-index: 2;
        box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      }

      /* =========================
         MAIN APP
      ========================= */
      #app {
        position: fixed;
        inset: 0;
        z-index: 1;
      }

      #camera {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: 1;
        transform-origin: center;
      }
      #camera.mirror { transform: scaleX(-1); }

      #puff {
        position: fixed;
        left: 50%;
        top: 72%;
        width: min(90vw, 500px);
        height: auto;
        object-fit: contain;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1.55) rotate(0deg);
        transform-origin: center;
        will-change: transform;
        z-index: 2;
        user-select: none;
        -webkit-user-drag: none;
      }

      #stickerLayer {
        position: fixed;
        inset: 0;
        z-index: 3;
        pointer-events: none;
      }
      .sticker {
        position: fixed;
        left: 50%;
        top: 40%;
        width: min(45vw, 260px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        transform-origin: center;
        will-change: transform;
        user-select: none;
      }
      .sticker.selected {
        outline: 2px solid rgba(255,255,255,0.6);
        outline-offset: 6px;
        border-radius: 14px;
      }

      /* rotate handle overlay */
      #handleLayer {
        position: fixed;
        inset: 0;
        z-index: 12;
        pointer-events: none;
      }
      .bbox {
        position: fixed;
        border: 2px solid rgba(255,255,255,0.65);
        border-radius: 12px;
        pointer-events: none;
        box-sizing: border-box;
      }
      .rotateHandle {
        position: fixed;
        width: 20px;
        height: 20px;
        border-radius: 999px;
        background: rgba(255,241,0,0.95);
        box-shadow: 0 6px 16px rgba(0,0,0,0.35);
        pointer-events: auto;
        touch-action: none;
        cursor: grab;
      }

      /* UI */
      #ui {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 12px;
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
        display: flex;
        flex-direction: column;
        gap: 7px;
        background: linear-gradient(to top, rgba(0,0,0,0.65), rgba(0,0,0,0));
        z-index: 10;
      }

      .ui-row {
        display: flex;
        gap: 7px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      button {
        border: 0;
        border-radius: 9px;
        padding: 6px 10px;
        font-size: 12px;
        font-weight: 800;
        color: #fff;
        background: #e11d2e;
        min-width: 92px;
      }

      #start { background: #fa213f; }
      button.secondary { background: rgba(255,255,255,0.15); }
      button:disabled { opacity: 0.5; }

      #capture {
        background: #fff100;
        color: #060d3d;
        font-weight: 900;
        min-width: 110px;
      }

      #photoboothToggle.on {
        background: #01b7ff;
        color: #00131c;
        font-weight: 900;
      }

      #timingBtn.on {
        background: #fff100;
        color: #060d3d;
        font-weight: 1000;
      }

      /* Countdown */
      #countdownOverlay {
        position: fixed;
        inset: 0;
        z-index: 999;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.35);
        backdrop-filter: blur(8px);
      }
      #countdownOverlay.show { display: flex; }
      #countdownNumber {
        font: 900 clamp(74px, 18vw, 160px) system-ui;
        color: #fff100;
        text-shadow: 0 18px 40px rgba(0,0,0,0.5);
      }
    </style>
  </head>

  <body>
    <!-- INTRO -->
    <div id="introOverlay">
      <video id="introVideo" autoplay playsinline webkit-playsinline muted preload="auto">
        <source src="intro.mp4?v=28" type="video/mp4" />
        <source src="intro.webm?v=28" type="video/webm" />
      </video>

      <img id="introClosePuff" src="puff-close.png" alt="Close intro" role="button" />
      <button id="exploreBtn" class="hidden" type="button">Explore</button>
    </div>

    <!-- APP -->
    <div id="app" class="hidden">
      <video id="camera" autoplay playsinline muted></video>

      <video
        id="puff"
        autoplay
        playsinline
        webkit-playsinline
        muted
        loop
        preload="metadata"
        crossorigin="anonymous"
      ></video>

      <div id="stickerLayer"></div>
      <div id="handleLayer"></div>

      <div id="countdownOverlay" aria-hidden="true">
        <div id="countdownNumber">3</div>
      </div>

      <div id="ui">
        <div class="ui-row">
          <button id="start">Start AR</button>
          <button id="flip" class="secondary" disabled>Flip Camera</button>
          <button id="mirror" class="secondary" disabled>Mirror: Auto</button>
        </div>

        <div class="ui-row">
          <button id="photoboothToggle" class="secondary" disabled>Photobooth: OFF</button>
          <button id="timingBtn" class="secondary" disabled>Timing: OFF</button>
          <button id="capture" disabled>Puff It!</button>
        </div>
      </div>
    </div>

    <script>
      /* ==========
         BASIC HELPERS
      ========== */
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

      function isAppleSafari() {
        const ua = navigator.userAgent;
        const isIOS =
          /iPad|iPhone|iPod/.test(ua) ||
          (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const isSafari = /Safari/.test(ua) && !/Chrome|CriOS|Edg|OPR|Firefox/.test(ua);
        return isIOS || isSafari;
      }

      /* ==========
         ELEMENTS
      ========== */
      const introOverlay = document.getElementById("introOverlay");
      const introVideo = document.getElementById("introVideo");
      const exploreBtn = document.getElementById("exploreBtn");
      const introClosePuff = document.getElementById("introClosePuff");

      const app = document.getElementById("app");
      const cameraEl = document.getElementById("camera");
      const puffEl = document.getElementById("puff");

      const startBtn = document.getElementById("start");
      const flipBtn = document.getElementById("flip");
      const mirrorBtn = document.getElementById("mirror");
      const captureBtn = document.getElementById("capture");
      const photoboothBtn = document.getElementById("photoboothToggle");
      const timingBtn = document.getElementById("timingBtn");

      const countdownOverlay = document.getElementById("countdownOverlay");
      const countdownNumber = document.getElementById("countdownNumber");

      /* ==========
         INTRO: show Explore after first play ends
      ========== */
      let introLoopStarted = false;
      introVideo.addEventListener("ended", async () => {
        if (!introLoopStarted) {
          introLoopStarted = true;
          exploreBtn.classList.remove("hidden");
          introVideo.loop = true;
          try {
            introVideo.currentTime = 0;
            await introVideo.play();
          } catch (_) {}
        }
      });

      // ensure intro can autoplay on iOS: first tap starts video
      const tryPlayIntro = async () => {
        try { await introVideo.play(); } catch (_) {}
        window.removeEventListener("pointerdown", tryPlayIntro, true);
      };
      window.addEventListener("pointerdown", tryPlayIntro, true);

      /* ==========
         PUFF SOURCE (Safari HEVC vs WebM)
      ========== */
      const ASSET_VERSION = "28";
      const puffBasesWeighted = ["puff","puff","puff","puff","puff","puff","puff2","puff3"];
      const chosenBase = puffBasesWeighted[Math.floor(Math.random() * puffBasesWeighted.length)];

      function setPuffSource(base) {
        const v = `v=${encodeURIComponent(ASSET_VERSION)}`;
        if (isAppleSafari()) {
          puffEl.innerHTML = `
            <source src="${base}.mov?${v}" type='video/quicktime; codecs="hvc1"'>
            <source src="${base}.mp4?${v}" type='video/mp4; codecs="hvc1"'>
          `;
        } else {
          puffEl.innerHTML = `
            <source src="${base}.webm?${v}" type="video/webm">
          `;
        }
        puffEl.load();
      }
      setPuffSource(chosenBase);

      function lockPuffAspect() {
        const vw = puffEl.videoWidth;
        const vh = puffEl.videoHeight;
        if (vw > 0 && vh > 0) {
          puffEl.style.aspectRatio = `${vw} / ${vh}`;
          puffEl.style.height = "auto";
        }
      }
      puffEl.addEventListener("loadedmetadata", lockPuffAspect);
      puffEl.addEventListener("loadeddata", lockPuffAspect);

      /* ==========
         CAMERA + STATE
      ========== */
      let stream = null;
      let currentFacingMode = "environment";
      let mirrorMode = "auto";

      function shouldMirrorPreview() {
        return mirrorMode === "on" || (mirrorMode === "auto" && currentFacingMode === "user");
      }
      function applyMirrorToPreview() {
        cameraEl.classList.toggle("mirror", shouldMirrorPreview());
        mirrorBtn.textContent =
          mirrorMode === "auto" ? "Mirror: Auto" : mirrorMode === "on" ? "Mirror: On" : "Mirror: Off";
      }

      function enableControls(isOn) {
        flipBtn.disabled = !isOn;
        mirrorBtn.disabled = !isOn;
        captureBtn.disabled = !isOn;
        photoboothBtn.disabled = !isOn;
        timingBtn.disabled = !isOn;
      }

      async function startCamera() {
        enableControls(false);
        startBtn.disabled = true;
        startBtn.textContent = "Starting...";

        try {
          if (stream) {
            stream.getTracks().forEach((t) => t.stop());
            stream = null;
          }

          stream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: {
              facingMode: { ideal: currentFacingMode },
              width: { ideal: 1280 },
              height: { ideal: 720 },
            },
          });

          cameraEl.srcObject = stream;
          await cameraEl.play().catch(() => {});
          await puffEl.play().catch(() => {});

          lockPuffAspect();
          applyMirrorToPreview();

          enableControls(true);
          startBtn.textContent = "AR Running";
          startBtn.disabled = true;
        } catch (err) {
          console.error(err);
          alert("Camera start failed. Please allow permission and use HTTPS.");
          startBtn.textContent = "Start AR";
          startBtn.disabled = false;
          enableControls(false);
        }
      }

      /* ==========
         INTRO CLOSE (FIX: auto-start AR)
      ========== */
      async function closeIntroAndStart() {
        // kill intro clicks fully
        introOverlay.classList.add("hidden");
        app.classList.remove("hidden");

        // IMPORTANT: start camera automatically so UI is alive
        await startCamera();
      }

      introClosePuff.addEventListener("click", closeIntroAndStart);
      exploreBtn.addEventListener("click", closeIntroAndStart);

      startBtn.addEventListener("click", startCamera);

      flipBtn.addEventListener("click", async () => {
        currentFacingMode = currentFacingMode === "environment" ? "user" : "environment";
        startBtn.disabled = false;
        startBtn.textContent = "Restart AR";
        await startCamera();
      });

      mirrorBtn.addEventListener("click", () => {
        mirrorMode = mirrorMode === "auto" ? "on" : mirrorMode === "on" ? "off" : "auto";
        applyMirrorToPreview();
      });

      /* ==========
         PUFF DRAG / PINCH / ROTATE (as before)
      ========== */
      const puffState = { x: 50, y: 72, scale: 1.55, rotation: 0 };

      function applyTransform(el, st) {
        el.style.left = st.x + "%";
        el.style.top = st.y + "%";
        el.style.transform = `translate(-50%, -50%) scale(${st.scale}) rotate(${st.rotation}deg)`;
      }

      function enableTouchDragPinch(el, state, onUpdate) {
        let mode = null;
        let start = null;

        const getTouch = (t) => ({ x: t.clientX, y: t.clientY });
        const dist2 = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
        const ang2 = (a, b) => (Math.atan2(b.y - a.y, b.x - a.x) * 180) / Math.PI;

        function toPct(dxPx, dyPx) {
          return { dx: (dxPx / innerWidth) * 100, dy: (dyPx / innerHeight) * 100 };
        }

        function onTouchStart(e) {
          e.preventDefault();
          if (e.touches.length === 1) {
            mode = "drag";
            const t = getTouch(e.touches[0]);
            start = { x: t.x, y: t.y, baseX: state.x, baseY: state.y };
          } else if (e.touches.length === 2) {
            mode = "pinch";
            const a = getTouch(e.touches[0]);
            const b = getTouch(e.touches[1]);
            start = { d: dist2(a, b), ang: ang2(a, b), baseScale: state.scale, baseRot: state.rotation };
          }
        }

        function onTouchMove(e) {
          if (!mode || !start) return;
          e.preventDefault();

          if (mode === "drag" && e.touches.length === 1) {
            const t = getTouch(e.touches[0]);
            const { dx, dy } = toPct(t.x - start.x, t.y - start.y);
            state.x = clamp(start.baseX + dx, 0, 100);
            state.y = clamp(start.baseY + dy, 0, 100);
            onUpdate();
          }

          if (mode === "pinch" && e.touches.length === 2) {
            const a = getTouch(e.touches[0]);
            const b = getTouch(e.touches[1]);
            const newD = dist2(a, b);
            const newAng = ang2(a, b);
            const s = newD / Math.max(10, start.d);
            state.scale = clamp(start.baseScale * s, 0.2, 6);
            state.rotation = start.baseRot + (newAng - start.ang);
            onUpdate();
          }
        }

        function onTouchEnd(e) {
          if (e.touches.length === 0) { mode = null; start = null; }
          else if (e.touches.length === 1) {
            mode = "drag";
            const t = getTouch(e.touches[0]);
            start = { x: t.x, y: t.y, baseX: state.x, baseY: state.y };
          }
        }

        // Mouse drag + wheel zoom
        let mouseDown = false;
        let mouseStart = null;

        function onMouseDown(e) {
          e.preventDefault();
          mouseDown = true;
          mouseStart = { x: e.clientX, y: e.clientY, baseX: state.x, baseY: state.y };
          window.addEventListener("mousemove", onMouseMove, { passive: false });
          window.addEventListener("mouseup", onMouseUp, { passive: false });
        }
        function onMouseMove(e) {
          if (!mouseDown || !mouseStart) return;
          e.preventDefault();
          const { dx, dy } = toPct(e.clientX - mouseStart.x, e.clientY - mouseStart.y);
          state.x = clamp(mouseStart.baseX + dx, 0, 100);
          state.y = clamp(mouseStart.baseY + dy, 0, 100);
          onUpdate();
        }
        function onMouseUp() {
          mouseDown = false;
          mouseStart = null;
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
        }

        function onWheel(e) {
          e.preventDefault();
          const delta = -Math.sign(e.deltaY) * 0.08;
          state.scale = clamp(state.scale * (1 + delta), 0.2, 6);
          onUpdate();
        }

        el.addEventListener("touchstart", onTouchStart, { passive: false });
        el.addEventListener("touchmove", onTouchMove, { passive: false });
        el.addEventListener("touchend", onTouchEnd, { passive: false });
        el.addEventListener("touchcancel", onTouchEnd, { passive: false });
        el.addEventListener("mousedown", onMouseDown, { passive: false });
        el.addEventListener("wheel", onWheel, { passive: false });
      }

      function updatePuff() { applyTransform(puffEl, puffState); }
      updatePuff();
      enableTouchDragPinch(puffEl, puffState, updatePuff);

      /* ==========
         TIMING + PHOTOBOOTH (UI now alive)
      ========== */
      let timingOn = false;
      timingBtn.addEventListener("click", () => {
        timingOn = !timingOn;
        timingBtn.classList.toggle("on", timingOn);
        timingBtn.textContent = timingOn ? "Timing: ON" : "Timing: OFF";
      });

      async function doCountdown3() {
        countdownOverlay.classList.add("show");
        for (let n = 3; n >= 0; n--) {
          countdownNumber.textContent = String(n);
          await sleep(n === 0 ? 160 : 700);
        }
        countdownOverlay.classList.remove("show");
      }

      let photoboothOn = false;
      photoboothBtn.addEventListener("click", () => {
        photoboothOn = !photoboothOn;
        photoboothBtn.classList.toggle("on", photoboothOn);
        photoboothBtn.textContent = photoboothOn ? "Photobooth: ON" : "Photobooth: OFF";
      });

      /* ==========
         CAPTURE (simple + stable)
         - This version proves clicks + timing work again.
         - Weâ€™ll re-merge your advanced builder + Insta-X after you confirm UI is alive.
      ========== */
      function nextCaptureFilename() {
        const key = "puff_capture_counter";
        const current = parseInt(localStorage.getItem(key) || "0", 10) + 1;
        localStorage.setItem(key, String(current));
        const num = String(current).padStart(3, "0");
        return `Puff Dragon_HPNY2026_${num}.png`;
      }

      function captureFrame() {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const W = Math.round(window.innerWidth * dpr);
        const H = Math.round(window.innerHeight * dpr);

        const c = document.createElement("canvas");
        c.width = W; c.height = H;
        const ctx = c.getContext("2d");

        // camera cover
        const vw = cameraEl.videoWidth || 1280;
        const vh = cameraEl.videoHeight || 720;
        const scale = Math.max(W / vw, H / vh);
        const sw = W / scale;
        const sh = H / scale;
        const sx = (vw - sw) / 2;
        const sy = (vh - sh) / 2;

        const mirrorCam = shouldMirrorPreview();
        ctx.save();
        if (mirrorCam) { ctx.translate(W, 0); ctx.scale(-1, 1); }
        ctx.drawImage(cameraEl, sx, sy, sw, sh, 0, 0, W, H);
        ctx.restore();

        // puff (simple draw using DOM rect)
        // ==== Puff (ratio locked, no stretch ever) ====
        const r = puffEl.getBoundingClientRect();
        const centerX = (r.left + r.width / 2) * dpr;
        const centerY = (r.top + r.height / 2) * dpr;
        
        // compute width based on DOM width
        const domWidth = r.width * dpr;
        
        // lock height based on intrinsic video ratio
        const intrinsicRatio = puffEl.videoHeight > 0
          ? puffEl.videoWidth / puffEl.videoHeight
          : r.width / r.height;
        
        const lockedHeight = domWidth / intrinsicRatio;
        
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate((puffState.rotation * Math.PI) / 180);
        ctx.drawImage(
          puffEl,
          -domWidth / 2,
          -lockedHeight / 2,
          domWidth,
          lockedHeight
        );
        ctx.restore();


        return new Promise((resolve) => c.toBlob(resolve, "image/png"));
      }

      async function doCaptureFlow() {
        if (!stream) { alert("Camera not running."); return; }
        if (timingOn) await doCountdown3();

        const blob = await captureFrame();
        if (!blob) { alert("Capture failed."); return; }

        const url = URL.createObjectURL(blob);
        const filename = nextCaptureFilename();

        const win = window.open("about:blank", "_blank");
        if (!win) { alert("Popup blocked."); return; }

        win.document.write(`
          <title>${filename}</title>
          <div style="margin:0;background:#000;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:18px;">
            <img src="${url}" style="max-width:100%;height:auto;display:block;" />
            <a href="${url}" download="${filename}"
              style="display:inline-block;padding:10px 14px;border-radius:12px;background:#fff100;color:#060d3d;font:900 14px system-ui;text-decoration:none">
              Download (${filename})
            </a>
          </div>
        `);
        win.document.close();
        setTimeout(() => URL.revokeObjectURL(url), 15000);
      }

      captureBtn.addEventListener("click", doCaptureFlow);
    </script>
  </body>
</html>
