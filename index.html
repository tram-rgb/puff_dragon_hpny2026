<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Puff Dragon AR Viewer</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        height: 100%;
        touch-action: none;
      }

      #camera {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: 1;
        transform-origin: center;
      }

      /* Mirror ONLY the live preview if needed */
      #camera.mirror {
        transform: scaleX(-1);
      }

      #puff {
        position: fixed;
        left: 50%;
        top: 72%;
        width: min(90vw, 500px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1.55);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        z-index: 2;
        user-select: none;
      }

      /* Stickers layer above puff */
      #stickerLayer {
        position: fixed;
        inset: 0;
        z-index: 3;
        pointer-events: none;
      }

      .sticker {
        position: fixed;
        left: 50%;
        top: 40%;
        width: min(45vw, 260px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        user-select: none;
      }

      .sticker.selected {
        outline: 2px solid rgba(255, 255, 255, 0.6);
        outline-offset: 6px;
        border-radius: 14px;
      }

      /* =========================
         UI: two rows + smaller buttons
      ========================= */
      #ui {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding-bottom: calc(14px + env(safe-area-inset-bottom));
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.65),
          rgba(0, 0, 0, 0)
        );
        z-index: 10;
      }

      .ui-row {
        display: flex;
        gap: 8px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      button {
        border: 0;
        border-radius: 10px;
        padding: 8px 14px; /* smaller */
        font-size: 14px; /* smaller */
        font-weight: 700;
        color: #fff;
        background: #e11d2e;
        min-width: 92px;
      }

      /* Start AR color */
      #start {
        background: #fa213f;
        color: #fff;
      }

      button.secondary {
        background: rgba(255, 255, 255, 0.15);
      }

      button:disabled {
        opacity: 0.5;
      }

      /* Puff It! button color */
      #capture {
        background: #fff100;
        color: #060d3d;
        font-weight: 800;
        min-width: 110px;
      }

      /* Sticker + Filter panels */
      #stickerPanel,
      #filterPanel {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        transform: translateY(110%);
        transition: transform 0.22s ease;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        padding: 14px 14px calc(14px + env(safe-area-inset-bottom));
        z-index: 20;
        border-top-left-radius: 18px;
        border-top-right-radius: 18px;
      }

      #stickerPanel.open,
      #filterPanel.open {
        transform: translateY(0);
      }

      #stickerPanelHeader,
      #filterPanelHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        margin-bottom: 10px;
      }

      #stickerGrid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 10px;
      }

      .stickerItem {
        background: rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1 / 1;
      }

      .stickerItem img {
        max-width: 100%;
        max-height: 100%;
        display: block;
      }

      #filterList {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }

      .filterItem {
        border: 0;
        border-radius: 14px;
        padding: 12px 12px;
        background: rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.95);
        font: 700 14px system-ui;
        text-align: left;
      }

      .filterItem.active {
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 2px;
      }

      /* Desktop hint */
      #desktopHint {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 11;
        padding: 8px 10px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.45);
        color: rgba(255, 255, 255, 0.85);
        font: 600 12px system-ui;
        display: none;
        user-select: none;
      }

      @media (hover: hover) and (pointer: fine) {
        #desktopHint {
          display: block;
        }
      }
    </style>
  </head>

  <body>
    <div id="desktopHint">
      Desktop: drag=move • wheel=zoom • Alt/Shift/right-drag=rotate • click=select
    </div>

    <video id="camera" autoplay playsinline muted></video>

    <video
      id="puff"
      autoplay
      playsinline
      webkit-playsinline
      muted
      loop
      preload="auto"
      crossorigin="anonymous"
    ></video>

    <div id="stickerLayer"></div>

    <!-- UI: two rows -->
    <div id="ui">
      <div class="ui-row">
        <button id="start">Start AR</button>
        <button id="flip" class="secondary" disabled>Flip Camera</button>
        <button id="mirror" class="secondary" disabled>Mirror: Auto</button>
      </div>

      <div class="ui-row">
        <button id="stickers" class="secondary" disabled>Sticker</button>
        <button id="filterBtn" class="secondary" disabled>Filter</button>
        <button id="capture" disabled>Puff It!</button>
      </div>
    </div>

    <!-- Sticker panel -->
    <div id="stickerPanel" aria-hidden="true">
      <div id="stickerPanelHeader">
        <div style="color:#fff;font:600 16px system-ui">Choose a sticker</div>
        <button id="stickerClose" class="secondary">Close</button>
      </div>

      <div id="stickerGrid"></div>

      <div
        style="
          display: flex;
          gap: 10px;
          margin-top: 12px;
          justify-content: center;
          flex-wrap: wrap;
        "
      >
        <button id="stickerRemove" class="secondary" disabled>
          Remove selected sticker
        </button>
        <button id="stickerClear" class="secondary" disabled>
          Clear all stickers
        </button>
      </div>
    </div>

    <!-- Filter panel -->
    <div id="filterPanel" aria-hidden="true">
      <div id="filterPanelHeader">
        <div style="color:#fff;font:600 16px system-ui">Choose a filter</div>
        <button id="filterClose" class="secondary">Close</button>
      </div>

      <div id="filterList"></div>
    </div>

    <script>
      const cameraEl = document.getElementById("camera");
      const puffEl = document.getElementById("puff");
      const stickerLayer = document.getElementById("stickerLayer");

      const startBtn = document.getElementById("start");
      const flipBtn = document.getElementById("flip");
      const mirrorBtn = document.getElementById("mirror");
      const stickersBtn = document.getElementById("stickers");
      const captureBtn = document.getElementById("capture");

      const filterBtn = document.getElementById("filterBtn");
      const filterPanel = document.getElementById("filterPanel");
      const filterClose = document.getElementById("filterClose");
      const filterListEl = document.getElementById("filterList");

      const stickerPanel = document.getElementById("stickerPanel");
      const stickerGrid = document.getElementById("stickerGrid");
      const stickerClose = document.getElementById("stickerClose");
      const stickerRemove = document.getElementById("stickerRemove");
      const stickerClear = document.getElementById("stickerClear");

      /* =========================
         CACHE BUSTING
      ========================= */
      const ASSET_VERSION = "22";

      /* =========================
         FILTERS (camera background)
      ========================= */
      const FILTERS = [
        { id: "none", name: "None", css: "none" },
        {
          id: "warm",
          name: "Warm",
          css: "contrast(1.05) saturate(1.25) sepia(0.18)",
        },
        {
          id: "cool",
          name: "Cool",
          css: "contrast(1.08) saturate(1.15) hue-rotate(185deg)",
        },
        { id: "bw", name: "B&W", css: "grayscale(1) contrast(1.1)" },
        {
          id: "vintage",
          name: "Vintage",
          css: "sepia(0.45) contrast(1.05) saturate(1.1)",
        },
        {
          id: "pink",
          name: "Pink Pop",
          css: "saturate(1.35) hue-rotate(330deg) contrast(1.05)",
        },
        {
          id: "cyber",
          name: "Cyber Blue",
          css: "hue-rotate(210deg) saturate(1.4) contrast(1.08)",
        },
      ];

      let currentFilterId = "none";
      let currentFilterCss = "none";

      function applyCameraFilter() {
        cameraEl.style.filter = currentFilterCss;
      }

      function openFilterPanel() {
        filterPanel.classList.add("open");
        filterPanel.setAttribute("aria-hidden", "false");
      }
      function closeFilterPanel() {
        filterPanel.classList.remove("open");
        filterPanel.setAttribute("aria-hidden", "true");
      }

      function renderFilters() {
        filterListEl.innerHTML = "";
        FILTERS.forEach((f) => {
          const b = document.createElement("button");
          b.className =
            "filterItem" + (f.id === currentFilterId ? " active" : "");
          b.type = "button";
          b.textContent = f.name;
          b.addEventListener("click", () => {
            currentFilterId = f.id;
            currentFilterCss = f.css;
            applyCameraFilter();
            renderFilters();
            closeFilterPanel();
          });
          filterListEl.appendChild(b);
        });
      }
      renderFilters();

      filterBtn.addEventListener("click", () => {
        if (filterBtn.disabled) return;
        openFilterPanel();
      });
      filterClose.addEventListener("click", closeFilterPanel);

      /* =========================
         PUFF RANDOM (3 videos)
      ========================= */
      const puffBases = ["puff", "puff2", "puff3"];
      const chosenBase =
        puffBases[Math.floor(Math.random() * puffBases.length)];

      function isAppleSafari() {
        const ua = navigator.userAgent;
        const isIOS =
          /iPad|iPhone|iPod/.test(ua) ||
          (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const isSafari =
          /Safari/.test(ua) && !/Chrome|CriOS|Edg|OPR|Firefox/.test(ua);
        return isIOS || isSafari;
      }

      function setPuffSource(base) {
        const v = `v=${encodeURIComponent(ASSET_VERSION)}`;
        if (isAppleSafari()) {
          puffEl.innerHTML = `
            <source src="${base}.mov?${v}" type='video/quicktime; codecs="hvc1"'>
            <source src="${base}.mp4?${v}" type='video/mp4; codecs="hvc1"'>
          `;
        } else {
          puffEl.innerHTML = `
            <source src="${base}.webm?${v}" type='video/webm; codecs="vp09.00.10.08"'>
            <source src="${base}.webm?${v}" type="video/webm">
          `;
        }
        puffEl.load();
      }

      puffEl.setAttribute("playsinline", "");
      puffEl.setAttribute("webkit-playsinline", "");
      puffEl.muted = true;
      puffEl.crossOrigin = "anonymous";
      setPuffSource(chosenBase);

      /* =========================
         CAMERA + MIRROR
      ========================= */
      let currentFacingMode = "environment";
      let stream = null;

      // Mirror affects preview + final capture (WYSIWYG)
      let mirrorMode = "auto";

      function shouldMirrorPreview() {
        return (
          mirrorMode === "on" ||
          (mirrorMode === "auto" && currentFacingMode === "user")
        );
      }

      function applyMirrorToPreview() {
        cameraEl.classList.toggle("mirror", shouldMirrorPreview());
        mirrorBtn.textContent =
          mirrorMode === "auto"
            ? "Mirror: Auto"
            : mirrorMode === "on"
            ? "Mirror: On"
            : "Mirror: Off";
      }

      function waitLoadedMetadata(videoEl, timeoutMs = 6000) {
        return new Promise((resolve, reject) => {
          if (videoEl.readyState >= 1 && videoEl.videoWidth > 0) return resolve();
          const t = setTimeout(() => {
            cleanup();
            reject(new Error("metadata timeout"));
          }, timeoutMs);
          const onMeta = () => {
            cleanup();
            resolve();
          };
          const cleanup = () => {
            clearTimeout(t);
            videoEl.removeEventListener("loadedmetadata", onMeta);
          };
          videoEl.addEventListener("loadedmetadata", onMeta, { once: true });
        });
      }

      async function startCamera() {
        captureBtn.disabled = true;
        stickersBtn.disabled = true;
        mirrorBtn.disabled = true;
        filterBtn.disabled = true;

        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }

        stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: currentFacingMode },
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        });

        cameraEl.srcObject = stream;

        await waitLoadedMetadata(cameraEl).catch(() => {});
        await cameraEl.play().catch(() => {});

        await waitLoadedMetadata(puffEl).catch(() => {});
        await puffEl.play().catch(() => {});

        flipBtn.disabled = false;
        captureBtn.disabled = false;
        stickersBtn.disabled = false;
        mirrorBtn.disabled = false;
        filterBtn.disabled = false;

        applyMirrorToPreview();
        applyCameraFilter();

        startBtn.textContent = "AR Running";
        startBtn.disabled = true;
      }

      startBtn.addEventListener("click", async () => {
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
          alert(
            "Could not access camera. Please allow permission and use HTTPS."
          );
        }
      });

      flipBtn.addEventListener("click", async () => {
        currentFacingMode =
          currentFacingMode === "environment" ? "user" : "environment";
        startBtn.disabled = false;
        startBtn.textContent = "Restart AR";
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
        }
      });

      mirrorBtn.addEventListener("click", () => {
        mirrorMode =
          mirrorMode === "auto" ? "on" : mirrorMode === "on" ? "off" : "auto";
        applyMirrorToPreview();
      });

      /* =========================
         TRANSFORM HELPERS
      ========================= */
      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }
      function dist(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }
      function angleDeg(a, b) {
        return (Math.atan2(b.y - a.y, b.x - a.x) * 180) / Math.PI;
      }

      function applyTransform(el, state) {
        el.style.left = state.x + "%";
        el.style.top = state.y + "%";
        el.style.transform = `translate(-50%, -50%) scale(${state.scale}) rotate(${state.rotation}deg)`;
      }

      /**
       * Desktop rotate improvements:
       * - Alt + drag rotate
       * - Shift + drag rotate
       * - Right-click drag rotate
       * Mobile:
       * - two-finger rotate/scale
       */
      function makeTransformable(el, state, onUpdate) {
        const pointers = new Map();
        let gestureStart = null;
        let dragStart = null;

        let inertiaRAF = null;
        let angularVelocity = 0;
        let lastAngle = null;
        let lastTime = null;

        function stopInertia() {
          if (inertiaRAF) cancelAnimationFrame(inertiaRAF);
          inertiaRAF = null;
        }
        function startInertia() {
          stopInertia();
          let prev = performance.now();
          function tick(now) {
            const dt = (now - prev) / 1000;
            prev = now;
            state.rotation += angularVelocity * dt;
            onUpdate();
            angularVelocity *= 0.92;
            if (Math.abs(angularVelocity) < 5) return;
            inertiaRAF = requestAnimationFrame(tick);
          }
          inertiaRAF = requestAnimationFrame(tick);
        }

        el.addEventListener("contextmenu", (e) => e.preventDefault());

        el.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          el.setPointerCapture?.(e.pointerId);
          stopInertia();
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          const isRightButtonRotate =
            e.pointerType === "mouse" && (e.buttons === 2 || e.button === 2);

          if (pointers.size === 1) {
            dragStart = {
              x: e.clientX,
              y: e.clientY,
              baseX: state.x,
              baseY: state.y,
              w: innerWidth,
              h: innerHeight,
              rotating: !!e.altKey || !!e.shiftKey || isRightButtonRotate,
              baseRotation: state.rotation,
            };
            gestureStart = null;
            lastAngle = null;
            lastTime = null;
          } else if (pointers.size === 2) {
            const pts = Array.from(pointers.values());
            const a = pts[0],
              b = pts[1];
            const ang = angleDeg(a, b);
            gestureStart = {
              distance: dist(a, b),
              angle: ang,
              scale: state.scale,
              rotation: state.rotation,
            };
            lastAngle = ang;
            lastTime = performance.now();
            dragStart = null;
          }
        });

        el.addEventListener("pointermove", (e) => {
          if (!pointers.has(e.pointerId)) return;
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          if (pointers.size === 1 && dragStart) {
            const dx = ((e.clientX - dragStart.x) / dragStart.w) * 100;
            const dy = ((e.clientY - dragStart.y) / dragStart.h) * 100;

            if (dragStart.rotating) {
              state.rotation = dragStart.baseRotation + dx * 3.0;
            } else {
              state.x = clamp(dragStart.baseX + dx, 0, 100);
              state.y = clamp(dragStart.baseY + dy, 0, 100);
            }
            onUpdate();
          }

          if (pointers.size === 2 && gestureStart) {
            const pts = Array.from(pointers.values());
            const a = pts[0],
              b = pts[1];

            const newDistance = dist(a, b);
            const newAngle = angleDeg(a, b);

            state.scale = clamp(
              gestureStart.scale * (newDistance / gestureStart.distance),
              0.2,
              6
            );
            state.rotation =
              gestureStart.rotation + (newAngle - gestureStart.angle);

            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            if (dt > 0) angularVelocity = (newAngle - lastAngle) / dt;
            lastAngle = newAngle;
            lastTime = now;

            onUpdate();
          }
        });

        el.addEventListener("pointerup", () => {
          pointers.clear();
          dragStart = null;
          gestureStart = null;
          if (Math.abs(angularVelocity) > 30) startInertia();
        });

        el.addEventListener("pointercancel", () => {
          pointers.clear();
          dragStart = null;
          gestureStart = null;
        });

        // Desktop wheel zoom
        el.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.92 : 1.08;
            state.scale = clamp(state.scale * factor, 0.2, 6);
            onUpdate();
          },
          { passive: false }
        );
      }

      /* =========================
         PUFF transform
      ========================= */
      const puffState = { x: 50, y: 72, scale: 1.55, rotation: 0 };
      function updatePuff() {
        applyTransform(puffEl, puffState);
      }
      updatePuff();
      makeTransformable(puffEl, puffState, updatePuff);

      /* =========================
         MULTI-STICKERS
      ========================= */
      let stickersLoaded = false;
      const stickerStates = new Map();
      let selectedStickerEl = null;

      function setSelectedSticker(el) {
        if (selectedStickerEl && selectedStickerEl !== el) {
          selectedStickerEl.classList.remove("selected");
        }
        selectedStickerEl = el;
        if (selectedStickerEl) selectedStickerEl.classList.add("selected");

        stickerRemove.disabled = !selectedStickerEl;
        stickerClear.disabled = stickerStates.size === 0;
      }

      function createSticker(src) {
        const el = document.createElement("img");
        el.className = "sticker";
        el.alt = "sticker";
        el.crossOrigin = "anonymous";
        el.src = src;
        el.style.pointerEvents = "auto";
        stickerLayer.appendChild(el);

        const state = { x: 50, y: 40, scale: 1.0, rotation: 0 };
        stickerStates.set(el, state);

        function update() {
          applyTransform(el, state);
        }
        update();

        el.addEventListener("pointerdown", () => setSelectedSticker(el), true);
        el.addEventListener("click", () => setSelectedSticker(el));

        makeTransformable(el, state, update);

        setSelectedSticker(el);
        stickerClear.disabled = stickerStates.size === 0;
      }

      function openStickerPanel() {
        stickerPanel.classList.add("open");
        stickerPanel.setAttribute("aria-hidden", "false");
        if (!stickersLoaded) loadStickers();
      }

      function closeStickerPanel() {
        stickerPanel.classList.remove("open");
        stickerPanel.setAttribute("aria-hidden", "true");
      }

      stickersBtn.addEventListener("click", () => {
        if (stickersBtn.disabled) return;
        openStickerPanel();
      });

      stickerClose.addEventListener("click", closeStickerPanel);

      stickerRemove.addEventListener("click", () => {
        if (!selectedStickerEl) return;
        stickerStates.delete(selectedStickerEl);
        selectedStickerEl.remove();
        selectedStickerEl = null;

        const last = Array.from(stickerStates.keys()).pop() || null;
        setSelectedSticker(last);

        stickerClear.disabled = stickerStates.size === 0;
      });

      stickerClear.addEventListener("click", () => {
        for (const el of stickerStates.keys()) el.remove();
        stickerStates.clear();
        setSelectedSticker(null);
        stickerClear.disabled = true;
      });

      async function loadStickers() {
        try {
          const res = await fetch(
            `/stickers.json?v=${encodeURIComponent(ASSET_VERSION)}`
          );
          const list = await res.json();
          stickersLoaded = true;

          stickerGrid.innerHTML = "";
          list.forEach((item) => {
            const cell = document.createElement("button");
            cell.className = "stickerItem";
            cell.type = "button";
            cell.style.border = "0";
            cell.style.cursor = "pointer";

            const img = document.createElement("img");
            img.loading = "lazy";
            img.alt = item.name || item.id || "sticker";
            const encodedSrc = encodeURI(item.src);
            img.src = `${encodedSrc}?v=${encodeURIComponent(ASSET_VERSION)}`;
            img.crossOrigin = "anonymous";

            cell.appendChild(img);

            cell.addEventListener("click", () => {
              createSticker(img.src);
              closeStickerPanel();
            });

            stickerGrid.appendChild(cell);
          });
        } catch (e) {
          console.error(e);
          stickerGrid.innerHTML =
            `<div style="color:#fff;font:500 14px system-ui;opacity:.9">
              Could not load stickers.json. Check /stickers.json at repo root.
            </div>`;
        }
      }

      document.addEventListener("pointerdown", (e) => {
        const isSticker =
          e.target &&
          e.target.classList &&
          e.target.classList.contains("sticker");
        const clickedPanel = stickerPanel.contains(e.target);
        const clickedFilter = filterPanel.contains(e.target);
        const clickedUI = document.getElementById("ui").contains(e.target);
        const clickedPuff = e.target === puffEl;

        if (
          !isSticker &&
          !clickedPanel &&
          !clickedFilter &&
          !clickedUI &&
          !clickedPuff
        ) {
          if (selectedStickerEl) selectedStickerEl.classList.remove("selected");
          selectedStickerEl = null;
          stickerRemove.disabled = true;
          stickerClear.disabled = stickerStates.size === 0;
        }
      });

      /* =========================
         CAPTURE
         - Mirror output follows mirror settings (WYSIWYG)
         - Filter applies to camera background only
      ========================= */
      function nextCaptureFilename() {
        const key = "puff_capture_counter";
        const current = parseInt(localStorage.getItem(key) || "0", 10) + 1;
        localStorage.setItem(key, String(current));
        const num = String(current).padStart(3, "0");
        return `Puff Dragon_HPNY2026_${num}.png`;
      }

      function getCoverTransform(srcW, srcH, dstW, dstH) {
        const scale = Math.max(dstW / srcW, dstH / srcH);
        const drawW = srcW * scale;
        const drawH = srcH * scale;
        const offsetX = (dstW - drawW) / 2;
        const offsetY = (dstH - drawH) / 2;
        return { scale, drawW, drawH, offsetX, offsetY };
      }

      captureBtn.addEventListener("click", () => {
        const win = window.open("about:blank", "_blank");
        if (!win) {
          alert("Popup blocked. Please allow popups for this site.");
          return;
        }

        try {
          if (!stream || !cameraEl.videoWidth || !cameraEl.videoHeight) {
            win.close();
            alert("Start AR first.");
            return;
          }

          const out = document.createElement("canvas");
          out.width = cameraEl.videoWidth;
          out.height = cameraEl.videoHeight;
          const ctx = out.getContext("2d");

          const camRect = cameraEl.getBoundingClientRect();
          const cover = getCoverTransform(
            out.width,
            out.height,
            camRect.width,
            camRect.height
          );

          const mirrorOutput = shouldMirrorPreview();

          // Apply filter to camera only
          ctx.save();
          ctx.filter = currentFilterCss || "none";
          if (mirrorOutput) {
            ctx.translate(out.width, 0);
            ctx.scale(-1, 1);
          }
          ctx.drawImage(cameraEl, 0, 0, out.width, out.height);
          ctx.restore();

          // Reset filter for overlays
          ctx.filter = "none";

          function computeDrawRect(domRect, aspectW, aspectH) {
            const centerX_screen =
              domRect.left + domRect.width / 2 - camRect.left;
            const centerY_screen =
              domRect.top + domRect.height / 2 - camRect.top;

            const centerX_cam = (centerX_screen - cover.offsetX) / cover.scale;
            const centerY_cam = (centerY_screen - cover.offsetY) / cover.scale;

            const w_cam = domRect.width / cover.scale;
            const h_cam = domRect.height / cover.scale;

            const ar =
              aspectW && aspectH
                ? aspectW / aspectH
                : domRect.width / domRect.height;

            let drawW = w_cam;
            let drawH = drawW / ar;
            if (drawH > h_cam) {
              drawH = h_cam;
              drawW = drawH * ar;
            }
            return { centerX_cam, centerY_cam, drawW, drawH };
          }

          function mirrorX(xCam) {
            return mirrorOutput ? out.width - xCam : xCam;
          }

          // Puff
          const puffRect = puffEl.getBoundingClientRect();
          const puffDraw = computeDrawRect(
            puffRect,
            puffEl.videoWidth,
            puffEl.videoHeight
          );

          ctx.save();
          ctx.translate(mirrorX(puffDraw.centerX_cam), puffDraw.centerY_cam);
          const puffRot = mirrorOutput ? -puffState.rotation : puffState.rotation;
          ctx.rotate((puffRot * Math.PI) / 180);
          if (mirrorOutput) ctx.scale(-1, 1);
          ctx.drawImage(
            puffEl,
            -puffDraw.drawW / 2,
            -puffDraw.drawH / 2,
            puffDraw.drawW,
            puffDraw.drawH
          );
          ctx.restore();

          // Stickers
          for (const [el, st] of stickerStates.entries()) {
            if (!el.complete || !el.naturalWidth) continue;

            const r = el.getBoundingClientRect();
            const d = computeDrawRect(r, el.naturalWidth, el.naturalHeight);

            ctx.save();
            ctx.translate(mirrorX(d.centerX_cam), d.centerY_cam);
            const rot = mirrorOutput ? -st.rotation : st.rotation;
            ctx.rotate((rot * Math.PI) / 180);
            if (mirrorOutput) ctx.scale(-1, 1);
            ctx.drawImage(el, -d.drawW / 2, -d.drawH / 2, d.drawW, d.drawH);
            ctx.restore();
          }

          out.toBlob((blob) => {
            if (!blob) {
              win.document.write("<h3>Capture failed</h3>");
              win.document.close();
              return;
            }

            const filename = nextCaptureFilename();
            const url = URL.createObjectURL(blob);

            win.document.write(`
              <title>${filename}</title>
              <div style="margin:0;background:#000;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:18px;">
                <img src="${url}" style="max-width:100%;height:auto;display:block;" />
                <a
                  href="${url}"
                  download="${filename}"
                  style="display:inline-block;padding:12px 16px;border-radius:12px;background:#fff100;color:#060d3d;font:800 16px system-ui;text-decoration:none"
                >
                  Download (${filename})
                </a>
              </div>
            `);

            win.document.close();
            setTimeout(() => URL.revokeObjectURL(url), 15000);
          }, "image/png");
        } catch (err) {
          console.error(err);
          win.document.write(
            `<h3>Capture Error</h3><pre style="white-space:pre-wrap">${String(
              err
            )}</pre>`
          );
          win.document.close();
          alert("Capture failed. Try again.");
        }
      });
    </script>
  </body>
</html>
