<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Puff Dragon AR Viewer</title>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        height: 100%;
        touch-action: none;
      }

      #camera {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: 1;
        transform-origin: center;
      }

      /* Mirror ONLY the live preview if needed */
      #camera.mirror {
        transform: scaleX(-1);
      }

      #puff {
        position: fixed;
        left: 50%;
        top: 72%;
        width: min(90vw, 500px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1.55);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        z-index: 2;
        user-select: none;
      }

      /* Stickers layer above puff */
      #stickerLayer {
        position: fixed;
        inset: 0;
        z-index: 3;
        pointer-events: none;
      }

      .sticker {
        position: fixed;
        left: 50%;
        top: 40%;
        width: min(45vw, 260px);
        height: auto;
        pointer-events: auto;
        touch-action: none;
        transform: translate(-50%, -50%) scale(1) rotate(0deg);
        transform-origin: center;
        background: transparent;
        will-change: transform;
        user-select: none;
      }

      .sticker.selected {
        outline: 2px solid rgba(255, 255, 255, 0.6);
        outline-offset: 6px;
        border-radius: 14px;
      }

      /* =========================
         UI: smaller buttons
      ========================= */
      #ui {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 7px;
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.65),
          rgba(0, 0, 0, 0)
        );
        z-index: 10;
      }

      .ui-row {
        display: flex;
        gap: 7px;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
      }

      button {
        border: 0;
        border-radius: 9px;
        padding: 6px 10px;
        font-size: 12px;
        font-weight: 800;
        letter-spacing: 0.2px;
        color: #fff;
        background: #e11d2e;
        min-width: 76px;
      }

      #start {
        background: #fa213f;
      }

      button.secondary {
        background: rgba(255, 255, 255, 0.15);
      }

      button:disabled {
        opacity: 0.5;
      }

      #capture {
        background: #fff100;
        color: #060d3d;
        font-weight: 900;
        min-width: 92px;
      }

      /* Panels */
      #stickerPanel,
      #filterPanel {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        transform: translateY(110%);
        transition: transform 0.22s ease;
        background: rgba(0, 0, 0, 0.75);
        backdrop-filter: blur(10px);
        padding: 12px 12px calc(12px + env(safe-area-inset-bottom));
        z-index: 20;
        border-top-left-radius: 18px;
        border-top-right-radius: 18px;
      }

      #stickerPanel.open,
      #filterPanel.open {
        transform: translateY(0);
      }

      #stickerPanelHeader,
      #filterPanelHeader {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      #stickerGrid {
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 9px;
      }

      .stickerItem {
        background: rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 9px;
        display: flex;
        align-items: center;
        justify-content: center;
        aspect-ratio: 1 / 1;
      }

      .stickerItem img {
        max-width: 100%;
        max-height: 100%;
        display: block;
      }

      #filterList {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 9px;
      }

      .filterItem {
        border: 0;
        border-radius: 14px;
        padding: 10px 10px;
        background: rgba(255, 255, 255, 0.12);
        color: rgba(255, 255, 255, 0.95);
        font: 800 12px system-ui;
        text-align: left;
      }

      .filterItem .sub {
        display: block;
        margin-top: 4px;
        opacity: 0.78;
        font: 700 10px system-ui;
        line-height: 1.1;
      }

      .filterItem.active {
        outline: 2px solid rgba(255, 255, 255, 0.7);
        outline-offset: 2px;
      }

      /* Desktop hint */
      #desktopHint {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 11;
        padding: 7px 9px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.45);
        color: rgba(255, 255, 255, 0.85);
        font: 700 11px system-ui;
        display: none;
        user-select: none;
      }

      @media (hover: hover) and (pointer: fine) {
        #desktopHint {
          display: block;
        }
      }
    </style>
  </head>

  <body>
    <div id="desktopHint">
      Desktop: drag=move • wheel=zoom • Alt/Shift/right-drag=rotate • click=select
    </div>

    <video id="camera" autoplay playsinline muted></video>

    <video
      id="puff"
      autoplay
      playsinline
      webkit-playsinline
      muted
      loop
      preload="auto"
      crossorigin="anonymous"
    ></video>

    <div id="stickerLayer"></div>

    <div id="ui">
      <div class="ui-row">
        <button id="start">Start AR</button>
        <button id="flip" class="secondary" disabled>Flip Camera</button>
        <button id="mirror" class="secondary" disabled>Mirror: Auto</button>
      </div>

      <div class="ui-row">
        <button id="stickers" class="secondary" disabled>Sticker</button>
        <button id="filterBtn" class="secondary" disabled>Filter</button>
        <button id="capture" disabled>Puff It!</button>
      </div>
    </div>

    <!-- Sticker panel -->
    <div id="stickerPanel" aria-hidden="true">
      <div id="stickerPanelHeader">
        <div style="color:#fff;font:800 14px system-ui">Choose a sticker</div>
        <button id="stickerClose" class="secondary">Close</button>
      </div>

      <div id="stickerGrid"></div>

      <div
        style="
          display: flex;
          gap: 8px;
          margin-top: 10px;
          justify-content: center;
          flex-wrap: wrap;
        "
      >
        <button id="stickerRemove" class="secondary" disabled>
          Remove selected
        </button>
        <button id="stickerClear" class="secondary" disabled>Clear all</button>
      </div>
    </div>

    <!-- Filter panel -->
    <div id="filterPanel" aria-hidden="true">
      <div id="filterPanelHeader">
        <div style="color:#fff;font:800 14px system-ui">Choose a filter</div>
        <button id="filterClose" class="secondary">Close</button>
      </div>

      <div id="filterList"></div>
    </div>

    <script>
      const cameraEl = document.getElementById("camera");
      const puffEl = document.getElementById("puff");
      const stickerLayer = document.getElementById("stickerLayer");

      const startBtn = document.getElementById("start");
      const flipBtn = document.getElementById("flip");
      const mirrorBtn = document.getElementById("mirror");
      const stickersBtn = document.getElementById("stickers");
      const captureBtn = document.getElementById("capture");

      const filterBtn = document.getElementById("filterBtn");
      const filterPanel = document.getElementById("filterPanel");
      const filterClose = document.getElementById("filterClose");
      const filterListEl = document.getElementById("filterList");

      const stickerPanel = document.getElementById("stickerPanel");
      const stickerGrid = document.getElementById("stickerGrid");
      const stickerClose = document.getElementById("stickerClose");
      const stickerRemove = document.getElementById("stickerRemove");
      const stickerClear = document.getElementById("stickerClear");

      /* =========================
         CACHE BUSTING
      ========================= */
      const ASSET_VERSION = "25";

      /* =========================================================
         FOODIE-LIKE FILTER RECIPES
         - These are "recipe params" (like your screenshots).
         - Live preview uses a light CSS approximation (fast).
         - Capture uses real pixel processing for much closer result.
      ========================================================= */

      // clamp helpers
      const clamp01 = (v) => Math.max(0, Math.min(1, v));
      const clamp255 = (v) => Math.max(0, Math.min(255, v));

      function srgbToLin(c) {
        c /= 255;
        return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      }
      function linToSrgb(c) {
        c = clamp01(c);
        const v =
          c <= 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
        return clamp255(v * 255);
      }
      function lumaLin(rLin, gLin, bLin) {
        return 0.2126 * rLin + 0.7152 * gLin + 0.0722 * bLin;
      }

      // apply saturation around luma (linear space)
      function applySaturationLin(r, g, b, sat) {
        const y = lumaLin(r, g, b);
        // sat: 1 = same, >1 more, <1 less
        return [
          y + (r - y) * sat,
          y + (g - y) * sat,
          y + (b - y) * sat,
        ];
      }

      // tone helpers: highlights/shadows control (very lightweight curve)
      function adjustShadowsHighlightsLin(y, shadows, highlights) {
        // shadows/highlights in [-1..+1] range
        // shadows: lift/darken shadows mainly under ~0.4
        // highlights: recover/dim highlights mainly above ~0.6
        let out = y;

        // shadows
        if (shadows !== 0) {
          const t = clamp01((0.45 - y) / 0.45); // 1 in darkest, 0 at 0.45
          out += shadows * t * 0.35; // strength
        }

        // highlights
        if (highlights !== 0) {
          const t = clamp01((y - 0.55) / 0.45); // 0 at 0.55, 1 at 1
          out += highlights * t * 0.35;
        }

        return clamp01(out);
      }

      // brilliance = midtone contrast boost (like local contrast)
      function applyBrillianceLin(y, brilliance) {
        // brilliance in [-1..+1]
        if (brilliance === 0) return y;
        // S-curve around midtones
        const k = brilliance * 0.55;
        // smoothstep-ish
        const s = y * y * (3 - 2 * y);
        return clamp01(y + (s - y) * k);
      }

      // fade = lift blacks slightly
      function applyFadeLin(y, fade) {
        // fade in [0..1]
        if (!fade) return y;
        const lift = fade * 0.10;
        return clamp01(y * (1 - fade * 0.15) + lift);
      }

      // warmth = warm/cool color bias in linear space
      function applyWarmthLin(r, g, b, warmth) {
        // warmth in [-1..+1]
        if (!warmth) return [r, g, b];
        const w = warmth * 0.10;
        // warm: increase red, slightly decrease blue
        return [r * (1 + w), g, b * (1 - w)];
      }

      // simple unsharp mask (for capture only)
      function unsharpMask(imageData, amount = 0.35, radius = 1) {
        // radius=1 small blur (box blur)
        const { width: w, height: h, data } = imageData;
        const src = new Uint8ClampedArray(data); // copy
        const idx = (x, y) => (y * w + x) * 4;

        // box blur 3x3
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let r = 0,
              g = 0,
              b = 0,
              a = 0,
              n = 0;
            for (let dy = -radius; dy <= radius; dy++) {
              const yy = y + dy;
              if (yy < 0 || yy >= h) continue;
              for (let dx = -radius; dx <= radius; dx++) {
                const xx = x + dx;
                if (xx < 0 || xx >= w) continue;
                const p = idx(xx, yy);
                r += src[p];
                g += src[p + 1];
                b += src[p + 2];
                a += src[p + 3];
                n++;
              }
            }
            const p = idx(x, y);
            const br = r / n,
              bg = g / n,
              bb = b / n;

            // original
            const or = src[p],
              og = src[p + 1],
              ob = src[p + 2];

            // sharpened = original + amount*(original - blurred)
            data[p] = clamp255(or + amount * (or - br));
            data[p + 1] = clamp255(og + amount * (og - bg));
            data[p + 2] = clamp255(ob + amount * (ob - bb));
            data[p + 3] = src[p + 3];
          }
        }
        return imageData;
      }

      // tiny noise reduction (capture only): super light blur on chroma
      function noiseReduceLight(imageData, strength = 0.15) {
        if (!strength) return imageData;
        const { width: w, height: h, data } = imageData;
        const src = new Uint8ClampedArray(data);
        const idx = (x, y) => (y * w + x) * 4;

        // 3x3 blur blended by strength
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            let r = 0,
              g = 0,
              b = 0,
              n = 0;
            for (let dy = -1; dy <= 1; dy++) {
              const yy = y + dy;
              if (yy < 0 || yy >= h) continue;
              for (let dx = -1; dx <= 1; dx++) {
                const xx = x + dx;
                if (xx < 0 || xx >= w) continue;
                const p = idx(xx, yy);
                r += src[p];
                g += src[p + 1];
                b += src[p + 2];
                n++;
              }
            }
            const p = idx(x, y);
            const br = r / n,
              bg = g / n,
              bb = b / n;

            data[p] = clamp255(src[p] * (1 - strength) + br * strength);
            data[p + 1] = clamp255(src[p + 1] * (1 - strength) + bg * strength);
            data[p + 2] = clamp255(src[p + 2] * (1 - strength) + bb * strength);
          }
        }
        return imageData;
      }

      // Convert “recipe numbers” (like +22 / -44 etc) to a recipe object.
      // We keep the same style, but normalize internally.
      function recipe(params) {
        return {
          // roughly match app units:
          exposure: (params.exposure || 0) / 100, // -1..+1
          brilliance: (params.brilliance || 0) / 100,
          highlights: (params.highlights || 0) / 100,
          shadows: (params.shadows || 0) / 100,
          brightness: (params.brightness || 0) / 100,
          contrast: (params.contrast || 0) / 100,
          saturation: (params.saturation || 0) / 100,
          warmth: (params.warmth || 0) / 100,
          fade: (params.fade || 0) / 100,
          sharpness: (params.sharpness || 0) / 100,
          noiseReduce: (params.noiseReduce || 0) / 100,
        };
      }

      // Foodie-style filter list (based on your screenshots vibe).
      // NOTE: exact numeric recipes from screenshots vary per template,
      // so these are tuned to *match the same look* (creamy, film, glow).
      const FILTERS = [
        { id: "none", name: "None", recipe: recipe({}) },

        // 35mm / motion blur look: cool + lower contrast + slightly desat
        {
          id: "35mm04",
          name: "35mm 04",
          recipe: recipe({
            exposure: -5,
            brilliance: -10,
            highlights: -30,
            shadows: +18,
            brightness: -10,
            contrast: -8,
            saturation: -6,
            warmth: -6,
            fade: +12,
            sharpness: -5,
            noiseReduce: +8,
          }),
        },

        // VI4: warm + soft + creamy skin
        {
          id: "vi4",
          name: "VI4",
          recipe: recipe({
            exposure: +10,
            brilliance: +18,
            highlights: -35,
            shadows: +14,
            brightness: +6,
            contrast: -6,
            saturation: +10,
            warmth: +10,
            fade: +10,
            sharpness: +6,
            noiseReduce: +10,
          }),
        },

        // CM1: clean warm portrait
        {
          id: "cm1",
          name: "CM1",
          recipe: recipe({
            exposure: +8,
            brilliance: +22,
            highlights: -25,
            shadows: +12,
            brightness: +4,
            contrast: -4,
            saturation: +12,
            warmth: +6,
            fade: +6,
            sharpness: +10,
            noiseReduce: +8,
          }),
        },

        // Sapa: airy + cool + soft fade
        {
          id: "sapa",
          name: "Sapa",
          recipe: recipe({
            exposure: +12,
            brilliance: +10,
            highlights: -22,
            shadows: +18,
            brightness: +8,
            contrast: -10,
            saturation: +6,
            warmth: -10,
            fade: +16,
            sharpness: +6,
            noiseReduce: +10,
          }),
        },

        // Salt: bright sunlight + glow + warm
        {
          id: "salt",
          name: "Salt",
          recipe: recipe({
            exposure: +18,
            brilliance: +18,
            highlights: -40,
            shadows: +10,
            brightness: +10,
            contrast: -8,
            saturation: +14,
            warmth: +14,
            fade: +8,
            sharpness: +8,
            noiseReduce: +8,
          }),
        },

        // IN2: green-ish film / station look
        {
          id: "in2",
          name: "IN2",
          recipe: recipe({
            exposure: +10,
            brilliance: +8,
            highlights: -30,
            shadows: +16,
            brightness: +4,
            contrast: -12,
            saturation: -4,
            warmth: -8,
            fade: +18,
            sharpness: +6,
            noiseReduce: +12,
          }),
        },

        // FL2: bright + clean + soft
        {
          id: "fl2",
          name: "FL2",
          recipe: recipe({
            exposure: +14,
            brilliance: +14,
            highlights: -28,
            shadows: +10,
            brightness: +8,
            contrast: -6,
            saturation: +10,
            warmth: +8,
            fade: +10,
            sharpness: +8,
            noiseReduce: +10,
          }),
        },

        // B&W film
        {
          id: "bwfilm",
          name: "B&W Film",
          recipe: recipe({
            exposure: +6,
            brilliance: +10,
            highlights: -20,
            shadows: +10,
            brightness: +4,
            contrast: +10,
            saturation: -100,
            warmth: 0,
            fade: +8,
            sharpness: +10,
            noiseReduce: +10,
          }),
        },
      ];

      // current filter selection
      let currentFilterId = "none";
      let currentRecipe = FILTERS[0].recipe;

      // fast preview approximation (CSS)
      function recipeToPreviewCss(r) {
        // brightness: combine exposure + brightness
        const bright = 1 + r.exposure * 0.55 + r.brightness * 0.35;
        const cont = 1 + r.contrast * 0.6 + r.brilliance * 0.25;
        const sat = 1 + r.saturation * 0.75;
        const hue = r.warmth * -18; // negative warms (orange-ish)
        const sep = clamp01(r.warmth * 0.35 + 0.05);
        // fade can't be done properly in CSS, but slight contrast reduction helps already
        return `brightness(${bright.toFixed(3)}) contrast(${cont.toFixed(
          3
        )}) saturate(${sat.toFixed(3)}) sepia(${sep.toFixed(
          3
        )}) hue-rotate(${hue.toFixed(1)}deg)`;
      }

      function applyCameraFilterPreview() {
        cameraEl.style.filter = recipeToPreviewCss(currentRecipe);
      }

      function openFilterPanel() {
        filterPanel.classList.add("open");
        filterPanel.setAttribute("aria-hidden", "false");
      }
      function closeFilterPanel() {
        filterPanel.classList.remove("open");
        filterPanel.setAttribute("aria-hidden", "true");
      }

      function renderFilters() {
        filterListEl.innerHTML = "";
        FILTERS.forEach((f) => {
          const b = document.createElement("button");
          b.className =
            "filterItem" + (f.id === currentFilterId ? " active" : "");
          b.type = "button";

          // tiny “recipe line” (like your screenshots)
          const r = f.recipe;
          const recLine =
            f.id === "none"
              ? "no recipe"
              : `exp ${Math.round(r.exposure * 100)} • hi ${Math.round(
                  r.highlights * 100
                )} • sh ${Math.round(r.shadows * 100)} • sat ${Math.round(
                  r.saturation * 100
                )}`;

          b.innerHTML = `${f.name}<span class="sub">${recLine}</span>`;

          b.addEventListener("click", () => {
            currentFilterId = f.id;
            currentRecipe = f.recipe;
            applyCameraFilterPreview();
            renderFilters();
            closeFilterPanel();
          });
          filterListEl.appendChild(b);
        });
      }
      renderFilters();

      filterBtn.addEventListener("click", () => {
        if (filterBtn.disabled) return;
        openFilterPanel();
      });
      filterClose.addEventListener("click", closeFilterPanel);

      /* =========================
         PUFF RANDOM (3 videos)
      ========================= */
      const puffBases = ["puff", "puff2", "puff3"];
      const chosenBase =
        puffBases[Math.floor(Math.random() * puffBases.length)];

      function isAppleSafari() {
        const ua = navigator.userAgent;
        const isIOS =
          /iPad|iPhone|iPod/.test(ua) ||
          (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
        const isSafari =
          /Safari/.test(ua) && !/Chrome|CriOS|Edg|OPR|Firefox/.test(ua);
        return isIOS || isSafari;
      }

      function setPuffSource(base) {
        const v = `v=${encodeURIComponent(ASSET_VERSION)}`;
        if (isAppleSafari()) {
          puffEl.innerHTML = `
            <source src="${base}.mov?${v}" type='video/quicktime; codecs="hvc1"'>
            <source src="${base}.mp4?${v}" type='video/mp4; codecs="hvc1"'>
          `;
        } else {
          puffEl.innerHTML = `
            <source src="${base}.webm?${v}" type='video/webm; codecs="vp09.00.10.08"'>
            <source src="${base}.webm?${v}" type="video/webm">
          `;
        }
        puffEl.load();
      }

      puffEl.setAttribute("playsinline", "");
      puffEl.setAttribute("webkit-playsinline", "");
      puffEl.muted = true;
      puffEl.crossOrigin = "anonymous";
      setPuffSource(chosenBase);

      /* =========================
         CAMERA + MIRROR
      ========================= */
      let currentFacingMode = "environment";
      let stream = null;

      // Mirror affects preview + final capture (WYSIWYG)
      let mirrorMode = "auto";

      function shouldMirrorPreview() {
        return (
          mirrorMode === "on" ||
          (mirrorMode === "auto" && currentFacingMode === "user")
        );
      }

      function applyMirrorToPreview() {
        cameraEl.classList.toggle("mirror", shouldMirrorPreview());
        mirrorBtn.textContent =
          mirrorMode === "auto"
            ? "Mirror: Auto"
            : mirrorMode === "on"
            ? "Mirror: On"
            : "Mirror: Off";
      }

      function waitLoadedMetadata(videoEl, timeoutMs = 6000) {
        return new Promise((resolve, reject) => {
          if (videoEl.readyState >= 1 && videoEl.videoWidth > 0) return resolve();
          const t = setTimeout(() => {
            cleanup();
            reject(new Error("metadata timeout"));
          }, timeoutMs);
          const onMeta = () => {
            cleanup();
            resolve();
          };
          const cleanup = () => {
            clearTimeout(t);
            videoEl.removeEventListener("loadedmetadata", onMeta);
          };
          videoEl.addEventListener("loadedmetadata", onMeta, { once: true });
        });
      }

      async function startCamera() {
        captureBtn.disabled = true;
        stickersBtn.disabled = true;
        mirrorBtn.disabled = true;
        filterBtn.disabled = true;

        if (stream) {
          stream.getTracks().forEach((t) => t.stop());
          stream = null;
        }

        stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            facingMode: { ideal: currentFacingMode },
            width: { ideal: 1280 },
            height: { ideal: 720 },
          },
        });

        cameraEl.srcObject = stream;

        await waitLoadedMetadata(cameraEl).catch(() => {});
        await cameraEl.play().catch(() => {});

        await waitLoadedMetadata(puffEl).catch(() => {});
        await puffEl.play().catch(() => {});

        flipBtn.disabled = false;
        captureBtn.disabled = false;
        stickersBtn.disabled = false;
        mirrorBtn.disabled = false;
        filterBtn.disabled = false;

        applyMirrorToPreview();
        applyCameraFilterPreview();

        startBtn.textContent = "AR Running";
        startBtn.disabled = true;
      }

      startBtn.addEventListener("click", async () => {
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
          alert("Could not access camera. Please allow permission and use HTTPS.");
        }
      });

      flipBtn.addEventListener("click", async () => {
        currentFacingMode =
          currentFacingMode === "environment" ? "user" : "environment";
        startBtn.disabled = false;
        startBtn.textContent = "Restart AR";
        try {
          await startCamera();
        } catch (e) {
          console.error(e);
        }
      });

      mirrorBtn.addEventListener("click", () => {
        mirrorMode =
          mirrorMode === "auto" ? "on" : mirrorMode === "on" ? "off" : "auto";
        applyMirrorToPreview();
      });

      /* =========================
         TRANSFORM HELPERS
      ========================= */
      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }
      function dist(a, b) {
        return Math.hypot(a.x - b.x, a.y - b.y);
      }
      function angleDeg(a, b) {
        return (Math.atan2(b.y - a.y, b.x - a.x) * 180) / Math.PI;
      }

      function applyTransform(el, state) {
        el.style.left = state.x + "%";
        el.style.top = state.y + "%";
        el.style.transform = `translate(-50%, -50%) scale(${state.scale}) rotate(${state.rotation}deg)`;
      }

      function makeTransformable(el, state, onUpdate) {
        const pointers = new Map();
        let gestureStart = null;
        let dragStart = null;

        let inertiaRAF = null;
        let angularVelocity = 0;
        let lastAngle = null;
        let lastTime = null;

        function stopInertia() {
          if (inertiaRAF) cancelAnimationFrame(inertiaRAF);
          inertiaRAF = null;
        }
        function startInertia() {
          stopInertia();
          let prev = performance.now();
          function tick(now) {
            const dt = (now - prev) / 1000;
            prev = now;
            state.rotation += angularVelocity * dt;
            onUpdate();
            angularVelocity *= 0.92;
            if (Math.abs(angularVelocity) < 5) return;
            inertiaRAF = requestAnimationFrame(tick);
          }
          inertiaRAF = requestAnimationFrame(tick);
        }

        el.addEventListener("contextmenu", (e) => e.preventDefault());

        el.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          el.setPointerCapture?.(e.pointerId);
          stopInertia();
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          const isRightButtonRotate =
            e.pointerType === "mouse" && (e.buttons === 2 || e.button === 2);

          if (pointers.size === 1) {
            dragStart = {
              x: e.clientX,
              y: e.clientY,
              baseX: state.x,
              baseY: state.y,
              w: innerWidth,
              h: innerHeight,
              rotating: !!e.altKey || !!e.shiftKey || isRightButtonRotate,
              baseRotation: state.rotation,
            };
            gestureStart = null;
            lastAngle = null;
            lastTime = null;
          } else if (pointers.size === 2) {
            const pts = Array.from(pointers.values());
            const a = pts[0],
              b = pts[1];
            const ang = angleDeg(a, b);
            gestureStart = {
              distance: dist(a, b),
              angle: ang,
              scale: state.scale,
              rotation: state.rotation,
            };
            lastAngle = ang;
            lastTime = performance.now();
            dragStart = null;
          }
        });

        el.addEventListener("pointermove", (e) => {
          if (!pointers.has(e.pointerId)) return;
          pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

          if (pointers.size === 1 && dragStart) {
            const dx = ((e.clientX - dragStart.x) / dragStart.w) * 100;
            const dy = ((e.clientY - dragStart.y) / dragStart.h) * 100;

            if (dragStart.rotating) {
              state.rotation = dragStart.baseRotation + dx * 3.0;
            } else {
              state.x = clamp(dragStart.baseX + dx, 0, 100);
              state.y = clamp(dragStart.baseY + dy, 0, 100);
            }
            onUpdate();
          }

          if (pointers.size === 2 && gestureStart) {
            const pts = Array.from(pointers.values());
            const a = pts[0],
              b = pts[1];

            const newDistance = dist(a, b);
            const newAngle = angleDeg(a, b);

            state.scale = clamp(
              gestureStart.scale * (newDistance / gestureStart.distance),
              0.2,
              6
            );
            state.rotation =
              gestureStart.rotation + (newAngle - gestureStart.angle);

            const now = performance.now();
            const dt = (now - lastTime) / 1000;
            if (dt > 0) angularVelocity = (newAngle - lastAngle) / dt;
            lastAngle = newAngle;
            lastTime = now;

            onUpdate();
          }
        });

        el.addEventListener("pointerup", () => {
          pointers.clear();
          dragStart = null;
          gestureStart = null;
          if (Math.abs(angularVelocity) > 30) startInertia();
        });

        el.addEventListener("pointercancel", () => {
          pointers.clear();
          dragStart = null;
          gestureStart = null;
        });

        el.addEventListener(
          "wheel",
          (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.92 : 1.08;
            state.scale = clamp(state.scale * factor, 0.2, 6);
            onUpdate();
          },
          { passive: false }
        );
      }

      /* =========================
         PUFF transform
      ========================= */
      const puffState = { x: 50, y: 72, scale: 1.55, rotation: 0 };
      function updatePuff() {
        applyTransform(puffEl, puffState);
      }
      updatePuff();
      makeTransformable(puffEl, puffState, updatePuff);

      /* =========================
         MULTI-STICKERS
      ========================= */
      let stickersLoaded = false;
      const stickerStates = new Map();
      let selectedStickerEl = null;

      function setSelectedSticker(el) {
        if (selectedStickerEl && selectedStickerEl !== el) {
          selectedStickerEl.classList.remove("selected");
        }
        selectedStickerEl = el;
        if (selectedStickerEl) selectedStickerEl.classList.add("selected");

        stickerRemove.disabled = !selectedStickerEl;
        stickerClear.disabled = stickerStates.size === 0;
      }

      function createSticker(src) {
        const el = document.createElement("img");
        el.className = "sticker";
        el.alt = "sticker";
        el.crossOrigin = "anonymous";
        el.src = src;
        el.style.pointerEvents = "auto";
        stickerLayer.appendChild(el);

        const state = { x: 50, y: 40, scale: 1.0, rotation: 0 };
        stickerStates.set(el, state);

        function update() {
          applyTransform(el, state);
        }
        update();

        el.addEventListener("pointerdown", () => setSelectedSticker(el), true);
        el.addEventListener("click", () => setSelectedSticker(el));

        makeTransformable(el, state, update);

        setSelectedSticker(el);
        stickerClear.disabled = stickerStates.size === 0;
      }

      function openStickerPanel() {
        stickerPanel.classList.add("open");
        stickerPanel.setAttribute("aria-hidden", "false");
        if (!stickersLoaded) loadStickers();
      }

      function closeStickerPanel() {
        stickerPanel.classList.remove("open");
        stickerPanel.setAttribute("aria-hidden", "true");
      }

      stickersBtn.addEventListener("click", () => {
        if (stickersBtn.disabled) return;
        openStickerPanel();
      });

      stickerClose.addEventListener("click", closeStickerPanel);

      stickerRemove.addEventListener("click", () => {
        if (!selectedStickerEl) return;
        stickerStates.delete(selectedStickerEl);
        selectedStickerEl.remove();
        selectedStickerEl = null;

        const last = Array.from(stickerStates.keys()).pop() || null;
        setSelectedSticker(last);

        stickerClear.disabled = stickerStates.size === 0;
      });

      stickerClear.addEventListener("click", () => {
        for (const el of stickerStates.keys()) el.remove();
        stickerStates.clear();
        setSelectedSticker(null);
        stickerClear.disabled = true;
      });

      async function loadStickers() {
        try {
          const res = await fetch(
            `/stickers.json?v=${encodeURIComponent(ASSET_VERSION)}`
          );
          const list = await res.json();
          stickersLoaded = true;

          stickerGrid.innerHTML = "";
          list.forEach((item) => {
            const cell = document.createElement("button");
            cell.className = "stickerItem";
            cell.type = "button";
            cell.style.border = "0";
            cell.style.cursor = "pointer";

            const img = document.createElement("img");
            img.loading = "lazy";
            img.alt = item.name || item.id || "sticker";
            const encodedSrc = encodeURI(item.src);
            img.src = `${encodedSrc}?v=${encodeURIComponent(ASSET_VERSION)}`;
            img.crossOrigin = "anonymous";

            cell.appendChild(img);

            cell.addEventListener("click", () => {
              createSticker(img.src);
              closeStickerPanel();
            });

            stickerGrid.appendChild(cell);
          });
        } catch (e) {
          console.error(e);
          stickerGrid.innerHTML =
            `<div style="color:#fff;font:700 12px system-ui;opacity:.9">
              Could not load stickers.json. Check /stickers.json at repo root.
            </div>`;
        }
      }

      document.addEventListener("pointerdown", (e) => {
        const isSticker =
          e.target &&
          e.target.classList &&
          e.target.classList.contains("sticker");
        const clickedPanel = stickerPanel.contains(e.target);
        const clickedFilter = filterPanel.contains(e.target);
        const clickedUI = document.getElementById("ui").contains(e.target);
        const clickedPuff = e.target === puffEl;

        if (
          !isSticker &&
          !clickedPanel &&
          !clickedFilter &&
          !clickedUI &&
          !clickedPuff
        ) {
          if (selectedStickerEl) selectedStickerEl.classList.remove("selected");
          selectedStickerEl = null;
          stickerRemove.disabled = true;
          stickerClear.disabled = stickerStates.size === 0;
        }
      });

      /* =========================
         CAPTURE HELPERS
      ========================= */
      function nextCaptureFilename() {
        const key = "puff_capture_counter";
        const current = parseInt(localStorage.getItem(key) || "0", 10) + 1;
        localStorage.setItem(key, String(current));
        const num = String(current).padStart(3, "0");
        return `Puff Dragon_HPNY2026_${num}.png`;
      }

      function getCoverTransform(srcW, srcH, dstW, dstH) {
        const scale = Math.max(dstW / srcW, dstH / srcH);
        const drawW = srcW * scale;
        const drawH = srcH * scale;
        const offsetX = (dstW - drawW) / 2;
        const offsetY = (dstH - drawH) / 2;
        return { scale, drawW, drawH, offsetX, offsetY };
      }

      /* =========================================================
         APPLY RECIPE TO IMAGE DATA (CAPTURE-ONLY, more accurate)
      ========================================================= */
      function applyRecipeToImageData(imageData, r) {
        const d = imageData.data;

        const sat = 1 + r.saturation * 0.9;
        const exposure = r.exposure; // linear gain via pow2-ish
        const exposureGain = Math.pow(2, exposure); // nice exposure behavior
        const brightnessGain = 1 + r.brightness * 0.35;
        const contrastGain = 1 + r.contrast * 0.6;

        for (let i = 0; i < d.length; i += 4) {
          const R = d[i],
            G = d[i + 1],
            B = d[i + 2];

          // to linear
          let rLin = srgbToLin(R);
          let gLin = srgbToLin(G);
          let bLin = srgbToLin(B);

          // warmth
          [rLin, gLin, bLin] = applyWarmthLin(rLin, gLin, bLin, r.warmth);

          // exposure + brightness
          rLin *= exposureGain * brightnessGain;
          gLin *= exposureGain * brightnessGain;
          bLin *= exposureGain * brightnessGain;

          // luma for tone ops
          let y = lumaLin(rLin, gLin, bLin);

          // brilliance
          y = applyBrillianceLin(y, r.brilliance);

          // highlights/shadows
          y = adjustShadowsHighlightsLin(y, r.shadows, r.highlights);

          // reconstruct by scaling towards new luma (preserve chroma)
          const y0 = Math.max(1e-6, lumaLin(rLin, gLin, bLin));
          const scale = y / y0;
          rLin *= scale;
          gLin *= scale;
          bLin *= scale;

          // saturation
          [rLin, gLin, bLin] = applySaturationLin(rLin, gLin, bLin, sat);

          // contrast in linear around 0.5 (approx)
          const pivot = 0.18; // film-ish mid gray in linear
          rLin = (rLin - pivot) * contrastGain + pivot;
          gLin = (gLin - pivot) * contrastGain + pivot;
          bLin = (bLin - pivot) * contrastGain + pivot;

          // fade
          const yFade = applyFadeLin(lumaLin(rLin, gLin, bLin), r.fade);
          const yNow = Math.max(1e-6, lumaLin(rLin, gLin, bLin));
          const s2 = yFade / yNow;
          rLin *= s2;
          gLin *= s2;
          bLin *= s2;

          // back to sRGB
          d[i] = linToSrgb(rLin);
          d[i + 1] = linToSrgb(gLin);
          d[i + 2] = linToSrgb(bLin);
          // alpha stays
        }

        // noise reduce then sharpness (capture only)
        if (r.noiseReduce > 0.01) {
          noiseReduceLight(imageData, clamp01(r.noiseReduce * 0.35));
        }
        if (r.sharpness > 0.01) {
          // sharpness: amount up to ~0.55
          unsharpMask(imageData, clamp01(r.sharpness * 0.55), 1);
        }

        return imageData;
      }

      /* =========================
         CAPTURE
         - Background is mirrored if mirror enabled
         - Filter recipe applied to background only (pixel accurate)
         - Overlays drawn after, not filtered
         - FIX: invert overlay rotation when mirrored (no sticker flip)
      ========================= */
      captureBtn.addEventListener("click", () => {
        const win = window.open("about:blank", "_blank");
        if (!win) {
          alert("Popup blocked. Please allow popups for this site.");
          return;
        }

        try {
          if (!stream || !cameraEl.videoWidth || !cameraEl.videoHeight) {
            win.close();
            alert("Start AR first.");
            return;
          }

          const out = document.createElement("canvas");
          out.width = cameraEl.videoWidth;
          out.height = cameraEl.videoHeight;
          const ctx = out.getContext("2d", { willReadFrequently: true });

          const camRect = cameraEl.getBoundingClientRect();
          const cover = getCoverTransform(
            out.width,
            out.height,
            camRect.width,
            camRect.height
          );

          const mirrorOutput = shouldMirrorPreview();

          // 1) Draw camera (with mirror) WITHOUT css filter (we'll do recipe pixels)
          ctx.save();
          if (mirrorOutput) {
            ctx.translate(out.width, 0);
            ctx.scale(-1, 1);
          }
          ctx.drawImage(cameraEl, 0, 0, out.width, out.height);
          ctx.restore();

          // 2) Apply recipe pixels to background ONLY
          if (currentFilterId !== "none") {
            const imgData = ctx.getImageData(0, 0, out.width, out.height);
            applyRecipeToImageData(imgData, currentRecipe);
            ctx.putImageData(imgData, 0, 0);
          }

          function computeDrawRect(domRect, aspectW, aspectH) {
            const centerX_screen =
              domRect.left + domRect.width / 2 - camRect.left;
            const centerY_screen =
              domRect.top + domRect.height / 2 - camRect.top;

            const centerX_cam = (centerX_screen - cover.offsetX) / cover.scale;
            const centerY_cam = (centerY_screen - cover.offsetY) / cover.scale;

            const w_cam = domRect.width / cover.scale;
            const h_cam = domRect.height / cover.scale;

            const ar =
              aspectW && aspectH
                ? aspectW / aspectH
                : domRect.width / domRect.height;

            let drawW = w_cam;
            let drawH = drawW / ar;
            if (drawH > h_cam) {
              drawH = h_cam;
              drawW = drawH * ar;
            }
            return { centerX_cam, centerY_cam, drawW, drawH };
          }

          function mirrorX(xCam) {
            return mirrorOutput ? out.width - xCam : xCam;
          }

          // 3) Puff overlay (invert rotation when mirrored)
          const puffRect = puffEl.getBoundingClientRect();
          const puffDraw = computeDrawRect(
            puffRect,
            puffEl.videoWidth,
            puffEl.videoHeight
          );

          ctx.save();
          ctx.translate(mirrorX(puffDraw.centerX_cam), puffDraw.centerY_cam);
          const puffRotation = mirrorOutput
            ? -puffState.rotation
            : puffState.rotation;
          ctx.rotate((puffRotation * Math.PI) / 180);
          ctx.drawImage(
            puffEl,
            -puffDraw.drawW / 2,
            -puffDraw.drawH / 2,
            puffDraw.drawW,
            puffDraw.drawH
          );
          ctx.restore();

          // 4) Stickers overlay (invert rotation when mirrored)
          for (const [el, st] of stickerStates.entries()) {
            if (!el.complete || !el.naturalWidth) continue;

            const r = el.getBoundingClientRect();
            const d = computeDrawRect(r, el.naturalWidth, el.naturalHeight);

            ctx.save();
            ctx.translate(mirrorX(d.centerX_cam), d.centerY_cam);
            const stickerRotation = mirrorOutput ? -st.rotation : st.rotation;
            ctx.rotate((stickerRotation * Math.PI) / 180);
            ctx.drawImage(el, -d.drawW / 2, -d.drawH / 2, d.drawW, d.drawH);
            ctx.restore();
          }

          // 5) Export
          out.toBlob((blob) => {
            if (!blob) {
              win.document.write("<h3>Capture failed</h3>");
              win.document.close();
              return;
            }

            const filename = nextCaptureFilename();
            const url = URL.createObjectURL(blob);

            win.document.write(`
              <title>${filename}</title>
              <div style="margin:0;background:#000;min-height:100vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;padding:18px;">
                <img src="${url}" style="max-width:100%;height:auto;display:block;" />
                <a
                  href="${url}"
                  download="${filename}"
                  style="display:inline-block;padding:10px 14px;border-radius:12px;background:#fff100;color:#060d3d;font:900 14px system-ui;text-decoration:none"
                >
                  Download (${filename})
                </a>
              </div>
            `);

            win.document.close();
            setTimeout(() => URL.revokeObjectURL(url), 15000);
          }, "image/png");
        } catch (err) {
          console.error(err);
          win.document.write(
            `<h3>Capture Error</h3><pre style="white-space:pre-wrap">${String(
              err
            )}</pre>`
          );
          win.document.close();
          alert("Capture failed. Try again.");
        }
      });

      /* =========================
         IMPORTANT: apply initial preview filter
      ========================= */
      applyCameraFilterPreview();
    </script>
  </body>
</html>
